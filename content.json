{"meta":{"title":"螺丝手","subtitle":null,"description":null,"author":"screw-hand","url":"https://screw-hand.com","root":"/"},"pages":[{"title":"关于","date":"2019-04-02T09:48:17.000Z","updated":"2024-03-17T09:23:23.116Z","comments":true,"path":"about/index.html","permalink":"https://screw-hand.com/about/index.html","excerpt":"","text":"一个前端"},{"title":"分类","date":"2019-04-02T09:17:10.000Z","updated":"2024-03-17T09:23:23.124Z","comments":false,"path":"categories/index.html","permalink":"https://screw-hand.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-02T09:09:29.000Z","updated":"2024-03-17T09:23:23.136Z","comments":false,"path":"tags/index.html","permalink":"https://screw-hand.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-03-17T09:23:23.124Z","updated":"2024-03-17T09:23:23.124Z","comments":true,"path":"download/file/style.css","permalink":"https://screw-hand.com/download/file/style.css","excerpt":"","text":".content { width: 50px; height: 50px; margin: 0 auto; text-align: center; } img { width: 100%; height: 100%; }"}],"posts":[{"title":"如何在 VMware Workstation 中配置桥接模式","slug":"config-bridge-mode-in-vmware-workstation","date":"2024-06-13T02:45:50.000Z","updated":"2024-06-13T02:49:55.012Z","comments":true,"path":"/post/config-bridge-mode-in-vmware-workstation/","link":"","permalink":"https://screw-hand.com/post/config-bridge-mode-in-vmware-workstation/","excerpt":"","text":"准备工作 确保宿主机的物理网卡已启用并正常工作。 确保 VMware Workstation 和虚拟机的网络驱动程序是最新的，并且与操作系统兼容。 配置 VMware Workstation 的虚拟网络编辑器 打开 VMware Workstation，点击 “编辑” 菜单，选择 “虚拟网络编辑器”。 选择 “VMnet0”（默认用于桥接模式的虚拟交换机），确保它处于 “桥接模式”。 在 “桥接到” 下拉菜单中，选择 “自动” 或宿主机上用于桥接的特定物理网卡。 点击 “确定” 保存设置。 配置虚拟机的网络适配器 关闭虚拟机（如果正在运行）。 在 VMware Workstation 主界面，选择虚拟机，点击 “编辑虚拟机设置”。 在 “硬件” 选项卡下，选择 “网络适配器”。 将 “网络连接” 更改为 “桥接模式”，并选择 “复制物理网络连接状态”。 点击 “确定” 保存设置。 配置虚拟机内部的网络 启动虚拟机。 编辑 /etc/netplan/01-network-manager-all.yaml 文件（如果文件名不同，请相应调整），配置内容如下： network: version: 2 renderer: NetworkManager ethernets: ens33: dhcp4: yes 应用新的网络配置： sudo netplan apply 检查虚拟机是否已获得与宿主机同一网段的 IP 地址： ip addr show ens33 验证和故障排除 确保虚拟机的网络接口已启用，并已获得正确的 IP 地址。 尝试从虚拟机 ping 宿主机和其他网络设备，以验证连通性。 如果遇到问题，请检查： VMware Workstation 的虚拟网络编辑器设置 虚拟机的网络适配器设置 虚拟机内部的 netplan 配置 宿主机的网络连接和物理网卡状态 sudo systemctl restart NetworkManager","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://screw-hand.com/categories/DevOps/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://screw-hand.com/tags/linux/"}]},{"title":"M系mac设置2k外接显示器使用HiDPI","slug":"m-series-mac-2k-HiDPI","date":"2024-03-19T06:19:06.000Z","updated":"2024-05-13T03:20:33.554Z","comments":true,"path":"/post/m-series-mac-2k-HiDPI/","link":"","permalink":"https://screw-hand.com/post/m-series-mac-2k-HiDPI/","excerpt":"原生系统支持 BetterDummy(BetterDisplay)","text":"原生系统支持 BetterDummy(BetterDisplay) 原生系统支持这是推荐方案，下一章节的BetterDummy(BetterDisplay)有一些痛点。 macOS - 13.2.1 (22D68)可以直接设置，Show all resolutions提供更多的HiDPI分辨率，但肉眼反馈并不是所有标注HiDPI的分辨率都是真实的HiDPI，比如我最喜欢2176*1224。 BetterDummy(BetterDisplay)BetterDummy已更名为BetterDisplay.我使用的是v2.2.1，软件界面已经大变样，使用方式大同小异。 将外接屏幕分辨率调整为默认 创建新的虚拟屏幕 系统设置，为外接屏幕设置为“镜像”虚拟屏幕 在软件菜单中调整虚拟屏幕的分辨率 *高刷屏设置最高刷新率（之前没有） 可参考该教程：解决2K 显示器的尴尬！为MacBook 开启HiDPI（新方法支持M1）-zz的秘密基地 但是我并没有找到教程中“BetterDisplay，真正通过修改配置的方式打开原生的HiDPI”的方式，可能是BetterDummy才有功能。 缺点： 造成输入法卡顿，重启相关软件或者输入法可解决问题 偶现重置外接屏幕壁纸问题，因为虚拟屏幕的壁纸无法设置 合上mac盖子，外接屏幕的软件会自动移动内置屏幕，或者反之，可以在合盖子前拔外接屏的屏幕线 第三方软件和系统设置都可以设置分辨率，会造成外接屏幕实际使用时分辨率混乱问题","categories":[{"name":"geek","slug":"geek","permalink":"https://screw-hand.com/categories/geek/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://screw-hand.com/tags/mac/"}]},{"title":"web应用的服务器环境迁移","slug":"web-env-migrate","date":"2024-01-29T02:29:00.000Z","updated":"2024-05-13T03:20:33.562Z","comments":true,"path":"/post/web-env-migrate/","link":"","permalink":"https://screw-hand.com/post/web-env-migrate/","excerpt":"背景 单体Web应用部署在云服务提供商上。 用户通过域名访问该应用。 计划将应用从一个云服务器（A）迁移到另一个（B），使用Docker进行部署。 迁移的目标是让用户无感知这一变更。","text":"背景 单体Web应用部署在云服务提供商上。 用户通过域名访问该应用。 计划将应用从一个云服务器（A）迁移到另一个（B），使用Docker进行部署。 迁移的目标是让用户无感知这一变更。 核心考虑点 测试阶段：可使用IP地址或直接使用域名进行B服务器的配置，以不干扰现有环境。 迁移策略：迁移时，考虑将配置从IP地址切换到域名（如果之前未使用），确保用户的请求无论通过原IP还是新域名均能正确路由到B服务器。 部署次数：可能需要一次或两次配置调整：一次为测试部署（使用IP或域名），一次为迁移时的最终配置。 部署和测试策略 直接使用域名：可以直接在B服务器上使用域名进行部署和配置。 测试策略：通过修改本地hosts文件、使用子域名或内部DNS进行测试。 注意：如果在Nginx等反向代理中使用域名，确保本地hosts文件的修改与之兼容，否则可能导致访问问题。 本地hosts文件配置： 为了同时访问A和B服务器，可以在本地hosts文件中添加两条记录： A服务器的IP地址 yourdomain.com B服务器的IP地址 test.yourdomain.com 这允许通过yourdomain.com访问A服务器，而通过test.yourdomain.com访问B服务器。 使用IP地址：最初在B服务器上使用IP地址进行部署和配置。 第二次部署：测试完成后，在迁移之前将B服务器配置更新为使用域名。 测试策略：无需特殊配置进行测试。 迁移步骤 准备B服务器：在B服务器上设置Docker环境，并部署Web应用。初期可使用IP地址或子域名进行配置。 测试验证：通过修改本地hosts文件或使用子域名，确保B服务器上的应用运行正常且可以访问。 迁移准备：确认B服务器准备就绪后，将其配置更新为使用正式域名。 DNS更新：在计划的迁移时间点，更新DNS记录，将域名指向B服务器的IP地址。 监控和验证：在DNS记录更新后，密切监控系统，确保流量正确路由到B服务器，并验证所有功能正常运行。 完全切换：一旦确认B服务器稳定运行，可以停止A服务器的服务。 Docker配置建议 在Docker配置中使用域名，提高灵活性和可维护性。 域名&#x2F;IP配置优缺点 使用域名 优点：易于维护，灵活性高，便于未来迁移或更改。 缺点：初始配置和测试可能更复杂，需额外步骤如修改hosts文件。 使用IP地址 优点：测试阶段配置直接，易于控制。","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://screw-hand.com/categories/DevOps/"}],"tags":[{"name":"env","slug":"env","permalink":"https://screw-hand.com/tags/env/"}]},{"title":"缩放倍率设置达到最佳视觉效果","slug":"optimal-visual-effect-scaling","date":"2023-10-19T15:50:00.000Z","updated":"2024-05-13T03:20:33.562Z","comments":true,"path":"/post/optimal-visual-effect-scaling/","link":"","permalink":"https://screw-hand.com/post/optimal-visual-effect-scaling/","excerpt":"计算dpi/ppi 最佳缩放倍率","text":"计算dpi/ppi 最佳缩放倍率 概要1.Retina视网膜屏幕概念： 标准5.0视力、眼睛距离屏幕30cm，可清晰看到300ppi的像素点边界。 手机屏幕为例，其像素密度为300ppi。 由于Mac和大屏显示器使用时距离更远，所需ppi分别降低为172和115。 Windows下的缩放档位与dpi对应关系： 100％缩放 = 96dpi 125％缩放 = 120dpi 150％缩放 = 144dpi 175％缩放 = 168dpi 200％缩放 = 192dpi 如何选择合适的缩放设置： 使用公式：dpi/ppi = 放大倍率。倍率越接近1，显示效果越接近设计师意图。 例如，对于ppi为163的27寸4K显示器，选择175％缩放（168dpi）可得到接近理想的显示效果。 实际应用： 可根据显示器的ppi值和上述公式来调整Windows缩放设置，确保内容显示尺寸与设计师意图一致。 计算对角线的像素数（横向像素数和纵向像素数分别是屏幕分辨率的宽和高的像素值）:对角线像素数横向像素数纵向像素数 计算ppi（或dpi）:或对角线像素数屏幕尺寸英寸 以一个常见的例子为示范：假设一个屏幕分辨率为1920x1080，对角线尺寸为15.6英寸的屏幕，对角线像素数，ppi分别为： 对角线像素数 所以，这个15.6英寸的屏幕的像素密度约为141ppi。 最佳的视觉体验对于不同的屏幕分辨率，选择显示器尺寸和缩放倍率是为了确保用户界面元素和文字保持合适的大小，以提供最佳的视觉体验。以下是对于1080p、2k、4k屏幕在不同显示器尺寸下的一些建议： 1080p (1920x1080) 屏幕: 常见的显示器尺寸: 21.5至24寸。 通常不需要缩放，但如果需要，则推荐100%。 逻辑分辨率: 1920x1080 2K (2560x1440) 屏幕: 常见的显示器尺寸: 24至27寸。 缩放建议: 大多数情况下可以使用100%缩放，但对于某些用户可能需要125%缩放。 逻辑分辨率: 100%缩放: 2560x1440 125%缩放: 2048x1152 4K (3840x2160) 屏幕: 常见的显示器尺寸: 27至32寸。 缩放建议: 由于4K分辨率的物理像素非常多，建议的缩放范围是150%至200%。 逻辑分辨率: 150%缩放: 2560x1440 200%缩放: 1920x1080 总结：根据显示器尺寸和分辨率，可以选择适当的缩放倍率，确保内容在屏幕上的大小适中，且清晰易读。调整缩放倍率后，逻辑分辨率也会相应地改变。逻辑分辨率决定了操作系统和应用程序渲染内容的大小。 接近110%缩放的一个选项可能是2384x1341，这个比2327x1309稍大一些，但应该能提供相似的视觉体验。 接近120%缩放的一个选项可能是2368x1332或者2340x1314，这些比2133x1200稍大，但也是相近的选项。","categories":[{"name":"geek","slug":"geek","permalink":"https://screw-hand.com/categories/geek/"}],"tags":[]},{"title":"如何让mac的vscode-insiders支持在web上直接安装扩展","slug":"vscode-insiders-support-install-extension-by-web","date":"2023-08-14T08:27:43.000Z","updated":"2024-05-13T03:20:33.562Z","comments":true,"path":"/post/vscode-insiders-support-install-extension-by-web/","link":"","permalink":"https://screw-hand.com/post/vscode-insiders-support-install-extension-by-web/","excerpt":"mac使用vscode-insiders，无法直接在网页上直接安装扩展。","text":"mac使用vscode-insiders，无法直接在网页上直接安装扩展。 Dracula Official - Visual Studio Marketplacehttps://marketplace.visualstudio.com/items?itemName=dracula-theme.theme-dracula vscode://在 macOS 上，更改默认的应用程序来处理特定的 URL 方案（如 vscode://）可能需要一些手动的操作： 查找 VS Code Insiders 的 Bundle Identifier：首先，找到 VS Code Insiders 的 Bundle Identifier。这可以通过在终端中运行以下命令来实现： bashCopy code osascript -e &#39;id of app &quot;Visual Studio Code - Insiders&quot;&#39; 请确保应用程序的名称是正确的。 更改 URL 方案的关联：使用一个名为 Duti 的开源工具来更改 URL 方案的关联。首先，安装 Duti，可以通过 Homebrew 安装： bashCopy code brew install duti 设置新的关联：安装完成后，使用下面的命令来设置 vscode: URL 方案与 VS Code Insiders 的关联。使用之前找到的 Bundle Identifier 替换 com.microsoft.VSCodeInsiders： bashCopy code duti -s com.microsoft.VSCodeInsiders vscode code命令行也变成了code-insiders，可以设置别名还原。临时作用，长期使用需要自行加入~/.bashrc文件。 alias code=code-insiders","categories":[{"name":"geek","slug":"geek","permalink":"https://screw-hand.com/categories/geek/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://screw-hand.com/tags/mac/"},{"name":"vscode","slug":"vscode","permalink":"https://screw-hand.com/tags/vscode/"}]},{"title":"ssh配置","slug":"ssh-config","date":"2023-07-05T11:48:57.000Z","updated":"2024-06-13T02:49:55.016Z","comments":true,"path":"/post/ssh-config/","link":"","permalink":"https://screw-hand.com/post/ssh-config/","excerpt":"多个账号配置ssh key ssh免密码登录 …","text":"多个账号配置ssh key ssh免密码登录 … 多个账号配置ssh keycd ~/.ssh ssh-keygen -t rsa -C \"youremail1@xxx.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Users/wu/.ssh/id_rsa): [ssh-key-name] # ~/.ssh/下创建config文件 # ~/.ssh/config start Host github.com HostName github.com PreferredAuthentications publickey # 使用HostName的时候，指定使用~/.ssh/github的ssh密钥 IdentityFile ~/.ssh/github Host 192.168.110.220 HostName 192.168.110.220 PreferredAuthentications publickey Port 22 IdentityFile ~/.ssh/192.168.110.220 # ~/.ssh/config end ssh -T git@192.168.110.220 -p 22 # Welcome to GitLab, @chris! ssh免密码登录cd ~/.ssh # 创建ssh密钥 ssh-keygen -t rsa -C \"youremail1@xxx.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Users/wu/.ssh/id_rsa): [ssh-key-name] # 复制指定ssh密钥到服务器，以后登录的时候就不需要输入密码了 ssh-copy-id -i ~/.ssh/id_rsa.pub -p 22 root@$SERVER # 登录远端服务器 ssh root@$SERVER cat ~/.ssh/authorized_keys exit # 测试跟服务器的连接 ssh -T root@$SERVER 非root用户，如何配置免密码登录# 用非root用户登录到服务器，比如normal: ssh normal@$SERVER sudo mkdir ~&#x2F;.ssh sudo chown $(whoami) ~&#x2F;.ssh sudo touch ~&#x2F;.ssh&#x2F;authorized_keys sudo chown $(whoami) ~&#x2F;.ssh&#x2F;authorized_keys sudo chmod 600 ~&#x2F;.ssh&#x2F;authorized_keys ls -l ~&#x2F;.ssh&#x2F;authorized_keys # -rw------- 1 zsuser root 0 May 23 15:09 &#x2F;home&#x2F;zsuser&#x2F;.ssh&#x2F;authorized_keys 结尾 Using the SSH Config File | Linuxize ssh免密码登录-腾讯云开发者社区-腾讯云 …","categories":[{"name":"cli","slug":"cli","permalink":"https://screw-hand.com/categories/cli/"}],"tags":[{"name":"cli","slug":"cli","permalink":"https://screw-hand.com/tags/cli/"},{"name":"ssh","slug":"ssh","permalink":"https://screw-hand.com/tags/ssh/"}]},{"title":"github中的fork技巧","slug":"fork-skill","date":"2023-06-21T04:50:55.000Z","updated":"2024-03-17T09:23:23.012Z","comments":true,"path":"/post/fork-skill/","link":"","permalink":"https://screw-hand.com/post/fork-skill/","excerpt":"前言进阶fork技巧，对初学者不是那么友好，建议拥有以下前置技能： 使用过github的fork&#x2F;pr操作 熟悉使用git命令的多个分支，多个远端操作 熟练使用git处理合并分支冲突 各个大标题内容独立，可根据自己需求跳读: 如何将fork类型仓库转成自己的仓库 如何同步多个上游仓库 在fork之前clone上游仓库并commit了，怎么提pr","text":"前言进阶fork技巧，对初学者不是那么友好，建议拥有以下前置技能： 使用过github的fork&#x2F;pr操作 熟悉使用git命令的多个分支，多个远端操作 熟练使用git处理合并分支冲突 各个大标题内容独立，可根据自己需求跳读: 如何将fork类型仓库转成自己的仓库 如何同步多个上游仓库 在fork之前clone上游仓库并commit了，怎么提pr 如何将fork类型仓库转成自己的仓库有什么好处？ 可以将其设置成私有仓库：fork类型的仓库无法设置成私有仓库 不打算提pr到上游仓库，并且想要有github的contributions（俗称：绿点&#x2F;绿墙）：fork类型的仓库，就算提交到了主分支，也不会有contributions. 使用github support的分离复刻。 Forks - GitHub 支持 自动弹出这个对话框，执行以下操作： 选择Detach&#x2F;Extract 输入owner/repository-name 选择Yes (committed to this fork) 、选No会让你自己手动复刻一遍 选择I need to use my own GitLFS data allowances and/or data-packs 等待邮件。 上图我选择了screw-hand&#x2F;layui，作为例子。其实之前我已经用过一次了，这是screw-hand&#x2F;github-profile-trophy的邮箱通知： 转成自己的仓库，github官方需要时间去处理， 可以参考一下两封邮箱的相差时间。 刚才选No的结果： 如何同步多个上游仓库一个上游仓库来，Syncing a fork - GitHub Docs, 这里有教我们fork后的repo，如何与上游的repo保持同步。但是只教我们同步一个，如果我们自己的repo是一个N合1（缝合怪），需要跟多个上游仓库保持同步。就需要再执行一些操作了。 多个上游仓库比如我的screw-hand&#x2F;github-profile-trophy，就有两个上游： https://github.com/ryo-ma/github-profile-trophy.git # upstream https://github.com/lucthienphong1120/github-trophies.git # super-upstream 一个叫upstream，一个叫super-upstream，你喜欢叫其他的也行，就跟origin一样，这只是git的远端名称。 我的screw-hand&#x2F;github-profile-trophy经过上文的github support操作，已经不是fork的仓库了。不过以下操作，跟是否为fork类型的仓库无关，你可以假设此仓库还是fork类型的。但是跟commit tree有关，待会我们会遇到的。 接下来的操作，你可以直接复制到你的命令行，随便拿我的screw-hand&#x2F;github-profile-trophy去玩吧。反正你push不了，哈哈。 本质上，同步多个上游仓库是用git命令行去添加多个remote，然后对remote branch进行合并的操作。 以下的命令是同步一个上游仓库，如果你对命令行多个远端操作比较熟悉，可以快速预览甚至跳过。 # 1. 我们已经有一个fork仓库，clone到本地 git clone https://github.com/screw-hand/github-profile-trophy.git cd github-profile-trophy # 2. 检查远端分支，现在只有一个orgin，指向你自己的仓库（fork仓库） git remote -v # origin https://github.com/screw-hand/github-profile-trophy.git (fetch) # origin https://github.com/screw-hand/github-profile-trophy.git (push) # 3. 回到当前分支的第一个commit # 注:为了示例,让下面第7步有输出,特意回退了提交 # 实际情况不需要回退,但如果上游仓库没新提交 # 将是:`Already up to date.` git reset $(git rev-list --max-parents=0 HEAD) --hard # HEAD is now at 5a9cbef first commit # 4. 添加多个远端仓库，分别为: upstream, super-upstream git remote add upstream https://github.com/ryo-ma/github-profile-trophy.git git remote add super-upstream https://github.com/lucthienphong1120/github-trophies.git # 5. 检查远端仓库是否成功设置,将有3个远端仓库 git remote -v # origin https://github.com/screw-hand/github-profile-trophy.git (fetch) # origin https://github.com/screw-hand/github-profile-trophy.git (push) # super-upstream https://github.com/lucthienphong1120/github-trophies.git (fetch) # super-upstream https://github.com/lucthienphong1120/github-trophies.git (push) # upstream https://github.com/ryo-ma/github-profile-trophy.git (fetch) # upstream https://github.com/ryo-ma/github-profile-trophy.git (push) # 6. 更新远端仓库的所有信息（分支、标签） git fetch --all # Fetching origin # Fetching upstream # From https://github.com/ryo-ma/github-profile-trophy # * [new branch] VegaDeftwing-master -> upstream/VegaDeftwing-master # * [new branch] juicyfresh -> upstream/juicyfresh # * [new branch] master -> upstream/master # * [new branch] pr-125 -> upstream/pr-125 # * [new branch] radical -> upstream/radical # * [new branch] spenserblack-theme/dracula -> upstream/spenserblack-theme/dracula # Fetching super-upstream # From https://github.com/lucthienphong1120/github-trophies # * [new branch] main -> super-upstream/main # 7. 执行远端合并, `git fech --all`，你可以看到remote upstream的默认分支是master # 如果不知道怎么找默认分支，去github repo web找：https://github.com/ryo-ma/github-profile-trophy # github repo web当前的分支就是默认分支 git merge upstream/master # 省略输出，此刻成功合并`upstream/master`的所有内容，无冲突 到这里为止，其实我们的操作跟Syncing a fork branch from the command line是完全一样的。但我们合并第二个远端分支，问题就来了。 多个上游仓库的特殊处理# 执行第二个远端分支合并，`git merge super-upstream/main`会成功吗？ git merge super-upstream/main # fatal: refusing to merge unrelated histories # why ?? 因为git觉得super-upstream/main跟我们现在的origin/master的分支毫无相干，你可以理解为没有一致的“commit tree”。但是我们为什么可以执行git merge upstream/master呢？因为origin就是fork了upsteam的remote而来的。所以我们刚直接merge是有一定概率毫无冲突的。 通过stackoverflow的帮助，我们继续执行。 git pull super-upstream main --allow-unrelated-histories # From https://github.com/lucthienphong1120/github-trophies # * branch main -> FETCH_HEAD # hint: You have divergent branches and need to specify how to reconcile them. # hint: You can do so by running one of the following commands sometime before # hint: your next pull: # hint: # hint: git config pull.rebase false # merge # hint: git config pull.rebase true # rebase # hint: git config pull.ff only # fast-forward only # hint: # hint: You can replace \"git config\" with \"git config --global\" to set a default # hint: preference for all repositories. You can also pass --rebase, --no-rebase, # hint: or --ff-only on the command line to override the configured default per # hint: invocation. # fatal: Need to specify how to reconcile divergent branches. # 出现这个是因为没有配置git如何处理冲突，建议使用`merge`,不建议配置成全局 git config pull.rebase false # 再次执行`git pull super-upstream main --allow-unrelated-histories` # 现在是 # From https://github.com/lucthienphong1120/github-trophies # * branch main -> FETCH_HEAD # Auto-merging LICENSE # CONFLICT (add/add): Merge conflict in LICENSE # Auto-merging README.md # CONFLICT (add/add): Merge conflict in README.md # Auto-merging index.ts # CONFLICT (add/add): Merge conflict in index.ts # Auto-merging src/card.ts # CONFLICT (add/add): Merge conflict in src/card.ts # Auto-merging src/github_api_client.ts # CONFLICT (add/add): Merge conflict in src/github_api_client.ts # Auto-merging src/theme.ts # CONFLICT (add/add): Merge conflict in src/theme.ts # Auto-merging src/trophy.ts # CONFLICT (add/add): Merge conflict in src/trophy.ts # Auto-merging src/trophy_list.ts # CONFLICT (add/add): Merge conflict in src/trophy_list.ts # Auto-merging src/user_info.ts # CONFLICT (add/add): Merge conflict in src/user_info.ts # Auto-merging src/utils.ts # CONFLICT (add/add): Merge conflict in src/utils.ts # Automatic merge failed; fix conflicts and then commit the result. 好了，现在已经是合并中的状态了，剩下的就是处理文件冲突了。就像我们平时一样： 查看文件改动历史，比较差异 根据自己需要，调整文件 测试代码 git add . git commit -m XXX git push 为了节约时间，我不处理文件冲突，直接提交到origin/fork-example。因为这是个示范，这些事情我之前做过了，任何时候都不建议将未处理的冲突文件提交！！ git add . git commit -m \"chore: new branch of fork-exapmle\" git checkout -b fork-exapmle git push --set-upstream origin fork-exapmle commit log - fork-example 跟踪多个上游仓库的更新至此第一次同步多个上游仓库就结束了。后续如果想继续跟踪远端上游的变动并且合并，也是大概这样的思路。 # 1. 获取远端信息，如果有新的变动，此次终端会输出信息 git fetch --all # 2. 合并fork的上游，此时大概率需要解决冲突 git merget upstream # 3. 合并非fork的上游，仍然需要注意冲突 git pull super-upstream main --allow-unrelated-histories 记录上游仓库信息建议把remote的信息记录在repo的REAME.md!! README.md - Init Project因为现在的仓库已经不是fork类型的，跟上游完全切断了联系，如果不记录的话。后续更换开发设备，或者意外删除本地的git仓库，将会完全失去与上游的联系！ 实例，为什么要同步多个上游仓库为什么我的github-profile-trophy需要同步两个上游仓库呢？ upsteam 两年内一直在更新 super-upsteam 有upsteam没有的新功能，但是两年没更新了 我也需要对其做一些定制化开发 所以将两个上游仓库一起跟踪合并是最好的。 如果对这个github-profile-trophy感兴趣，你也可以将下面的两个链接添加到你的github profile page，别忘了将screw-hand换成自己的github username。 # 过滤掉指定等级(UNKNOWN，C)的奖杯 https:&#x2F;&#x2F;github-profile-trophy.screw-hand.vercel.app&#x2F;?username&#x3D;screw-hand&amp;rank&#x3D;-UNKNOWN,-C # 只展示所有秘密奖杯，并且全部无条件获得 https:&#x2F;&#x2F;github-profile-trophy.screw-hand.vercel.app&#x2F;?username&#x3D;screw-hand&amp;rank&#x3D;SECRET&amp;wantAll&#x3D;true 在fork之前clone上游仓库并commit了，怎么提pr可能大多数人都是有了pr的想法，就第一时间fork仓库。我更喜欢clone上游仓库到本地。为什么要先clone上游仓库到本地呢？有时候我们只是想随意看看其他人的代码，跑一跑。然后发现一些地方可以新增功能，修复bug，我们本来没有提pr的意思，现在代码也改了。也不想再去fork之后，再cc cv代码到新的fork repo。当然github也可以在线浏览代码，clone到本地的话，除了看代码，也可以直接把项目先跑起来，改着玩玩。这时候也可以直接修改代码然后commit，只是因为远端的仓库我们没有权限无法push。 还有一种情况是： 如果一开始就是冲着提pr，先fork了，改不动代码了，这时候除了删本地的文件夹，还需要在删掉github的fork仓库。 比如我们想给haozi&#x2F;New-Bing-Anywhere提一个pr。 # 1. clone上游仓库到本地 git clone https://github.com/haozi/New-Bing-Anywhere.git cd New-Bing-Anywhere # 2. 浏览代码 / 启动项目 / 更改代码 / commit touch pr-file git add . git commit -m \"feat: pr-file\" # 3. 直接push git push # 因为没有仓库的权限，无法直接push到haozi/New-Bing-Anywhere # fatal: Authentication failed for 'https://github.com/haozi/New-Bing-Anywhere.git/' 这个时候，我们再来fork也不迟，所以我们先到github执行fork操作，得到screw-hand&#x2F;New-Bing-Anywhere # 1. 查看远端 git remote -v # origin https://github.com/haozi/New-Bing-Anywhere.git (fetch) # origin https://github.com/haozi/New-Bing-Anywhere.git (push) # 2. 将origin换成upstream git remote rename origin upstream # 3. 添加fork后的remote为origin git remote add origin https://github.com/screw-hand/New-Bing-Anywhere.git # 4.检查远端 git remote -v # origin https://github.com/screw-hand/New-Bing-Anywhere.git (fetch) # origin https://github.com/screw-hand/New-Bing-Anywhere.git (push) # upstream https://github.com/haozi/New-Bing-Anywhere.git (fetch) # upstream https://github.com/haozi/New-Bing-Anywhere.git (push) # 5. 获取远端分支 git fetch --all 接下来pr的常规流程： 切分支 commit push pr # 1. 检出新分支 git checkout -b pr-example # 2. 推送到指定分支 git push --set-upstream origin pr-example # 3. 删除之前commit的main分支 git branch -D main # 4. 恢复main分支到未commit的状态 git checkout -b main origin/main pr-example 这一顿操作下来，会比第一时间fork更麻烦，可以当做没fork之后的补救措施吧。 clone上游仓库后，创建自己的repo这是一种比如何将fork类型仓库转成自己的仓库、#fork之前clone上游仓库并commit了，怎么提pr更简单的操作方式，效果是一样的。 先clone想要的上游仓库。我觉得用GitHub CLI速度更快更方便，以下实例我用会GitHub CLI，跟在github web上操作是等效的。 以下origin的github username，你需要换成自己的。 设计我们的远端仓库 https:&#x2F;&#x2F;github.com&#x2F;snyk-snippets&#x2F;modern-npm-package.git # upsteam https:&#x2F;&#x2F;github.com&#x2F;screw-hand&#x2F;modern-npm-package.git # origin clone上游仓库 git clone https://github.com/snyk-snippets/modern-npm-package.git *此刻你或许会在这里提交代码，但是你无法推送到别人的远端(snyk-snippets&#x2F;modern-npm-package) 更名远端仓库origin(snyk-snippets&#x2F;modern-npm-package)为upsteam(snyk-snippets&#x2F;modern-npm-package) git remote -v # origin https://github.com/snyk-snippets/modern-npm-package.git (fetch) # origin https://github.com/snyk-snippets/modern-npm-package.git (push) git remote rename origin upsteam git remote -v # upsteam https://github.com/snyk-snippets/modern-npm-package.git (fetch) # upsteam https://github.com/snyk-snippets/modern-npm-package.git (push) 使用GitHub CLI创建一个新repo gh repo new ? What would you like to do? Push an existing local repository to GitHub ? Path to local repository . ? Repository name modern-npm-package ? Description fork from [snyk-snippets/modern-npm-package](https://github.com/snyk-snippets/modern-npm-package) ? Visibility Public ✓ Created repository screw-hand/modern-npm-package on GitHub ? Add a remote? Yes ? What should the new remote be called? origin ✓ Added remote git@github.com:screw-hand/modern-npm-package.git ? Would you like to push commits from the current branch to \"origin\"? Yes Enumerating objects: 77, done. Counting objects: 100% (77/77), done. Delta compression using up to 8 threads Compressing objects: 100% (40/40), done. Writing objects: 100% (77/77), 117.86 KiB | 458.00 KiB/s, done. Total 77 (delta 33), reused 67 (delta 27), pack-reused 0 remote: Resolving deltas: 100% (33/33), done. To github.com:screw-hand/modern-npm-package.git * [new branch] HEAD -> main branch 'main' set up to track 'origin/main'. ✓ Pushed commits to git@github.com:screw-hand/modern-npm-package.git 操作很简单，第一次选项选择Push an existing local repository to GitHub，一路回车即可。Description看你，复制upsteam的也行，我这里自己写了。其他选项是关于仓库的可见性、是否添加远端、添加远端后是否要push。 跟在github web的操作其实是一样的，只是GitHub CLI的引导选项很方便。 再次检查远端仓库 git remote -v origin git@github.com:screw-hand/modern-npm-package.git (fetch) origin git@github.com:screw-hand/modern-npm-package.git (push) upsteam https://github.com/snyk-snippets/modern-npm-package.git (fetch) upsteam https://github.com/snyk-snippets/modern-npm-package.git (push) 查看github web https://github.com/screw-hand/modern-npm-package 结尾为什么有时候提交了没contributions&#x2F;绿点&#x2F;绿墙： Why are my contributions not showing up on my profile? - GitHub Docs …","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://screw-hand.com/tags/github/"}]},{"title":"apt vs apt-get","slug":"apt-vs-apt-get","date":"2023-06-20T03:52:03.000Z","updated":"2024-05-13T03:20:33.554Z","comments":true,"path":"/post/apt-vs-apt-get/","link":"","permalink":"https://screw-hand.com/post/apt-vs-apt-get/","excerpt":"apt和apt-get都是Ubuntu的包管理工具，在较新的系统推荐用apt，apt比apt-get更新，后者的兼容性会更好。apt也会让其依赖项一起升级。","text":"apt和apt-get都是Ubuntu的包管理工具，在较新的系统推荐用apt，apt比apt-get更新，后者的兼容性会更好。apt也会让其依赖项一起升级。 apt vs apt-getOn Ubuntu, both apt and apt-get are package management commands used to handle software packages. Here’s an overview of the differences between the two: User Interface: apt provides a more user-friendly and streamlined interface compared to apt-get. It aims to simplify package management tasks by offering clearer and more concise output, progress bars during installation, and easier-to-understand prompts. Command Syntax: The command syntax for apt and apt-get is different. apt uses a more straightforward and intuitive command structure, while apt-get has a slightly more complex and traditional syntax. Package Dependency Handling: apt includes automatic handling of package dependencies by default. It automatically resolves and installs any necessary dependencies when you use the apt install command. In contrast, with apt-get, you may need to use the separate apt-get build-dep command to install build dependencies for source packages. Compatibility: apt-get is more established and has been around for a longer time. It is compatible with older versions of Ubuntu and other Debian-based distributions. apt, introduced in Ubuntu 16.04, is designed to be backward-compatible with apt-get, meaning you can still use apt-get commands on newer Ubuntu versions without issues. In general, if you’re using a newer version of Ubuntu, apt is recommended due to its improved user experience and simplified syntax. However, both apt and apt-get are capable package management tools, and you can choose the one that best suits your preferences and requirements. It’s worth noting that there are other package management commands available on Ubuntu, such as apt-cache for querying package information and aptitude for a more advanced package management interface. apt update vs apt upgradeupdate 命令只会获得系统上所有包的最新信息，并不会下载或者安装任何一个包。 而是 apt upgrade 命令来把这些包下载和升级到最新版本。 技术|apt 的 update 和 upgrade 命令的区别是什么？","categories":[{"name":"geek","slug":"geek","permalink":"https://screw-hand.com/categories/geek/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://screw-hand.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://screw-hand.com/tags/ubuntu/"}]},{"title":"你的理想生活","slug":"hope","date":"2022-08-22T10:22:11.000Z","updated":"2024-03-17T09:23:23.044Z","comments":true,"path":"/post/hope/","link":"","permalink":"https://screw-hand.com/post/hope/","excerpt":"很多时候我都很好奇别人想法，比如朋友的理想生活到底是怎样的。所以给最珍贵的朋友做了一次人间采访，我想知道，脱离了现实的客观条件，朋友们希望过上一种什么样的生活。 以下回答来自不同的朋友，不同的时间，或者想法会进化或者放弃。但是仍然希望，所有人都记得有某一个人，曾经有这么一个理想过。 因为说出自己的真实想法太过羞耻，很多人并不一定喜欢自我暴露，所有的回答都是采用匿名机制，只保留日期，如果找不到自己的回答，那也说明这个理想生活也不属于你了。 或许某一天，当你迷失了方向，会重新回来这里，寻找你最初的想法。 “你的理想生活是什么，无视所有客观条件?”","text":"很多时候我都很好奇别人想法，比如朋友的理想生活到底是怎样的。所以给最珍贵的朋友做了一次人间采访，我想知道，脱离了现实的客观条件，朋友们希望过上一种什么样的生活。 以下回答来自不同的朋友，不同的时间，或者想法会进化或者放弃。但是仍然希望，所有人都记得有某一个人，曾经有这么一个理想过。 因为说出自己的真实想法太过羞耻，很多人并不一定喜欢自我暴露，所有的回答都是采用匿名机制，只保留日期，如果找不到自己的回答，那也说明这个理想生活也不属于你了。 或许某一天，当你迷失了方向，会重新回来这里，寻找你最初的想法。 “你的理想生活是什么，无视所有客观条件?” 采访结果脚踩天下高富帅坐拥天下白富美 —— 2021&#x2F;08&#x2F;30 住豪宅 喝名酒 抽雪茄 —— 2020&#x2F;08&#x2F;30 弹琴，练字，读书，打游戏，看电视，偶尔带老婆和家里狗子去附近旅游 —— 2022&#x2F;06&#x2F;29 我这半年如果不用考虑还得找工作 就挺理想 睡到自然醒，喜欢干啥干啥 一个长期爱好加若干短期三分钟爱好，加一个健康的身体，核心是充足的时间 结不了婚 在某个方面一眼看的到头对我来说就是灾难 生活态度比较重要 等我xx了我就xxx那多半xxx是只存在脑子里的 —— 2022&#x2F;08&#x2F;09 我想了想，我的理想生活都和收入，金钱相关 我或者我的家人收入自由[皱眉][皱眉][皱眉]，我不会为这个去焦虑和努力自己的收入工作或者事业和美业相关穿着我喜欢的衣服，不会考虑工作外在因素合不合适过一段时间可以随意的去任何城市玩几天日常学学舞蹈和乐器有自己的房产[皱眉] 想想就很开心 [破涕为笑][破涕为笑][破涕为笑][破涕为笑] —— 2022&#x2F;08&#x2F;09 世外桃源 —— 2022&#x2F;08&#x2F;12 做一块石头 —— 2020&#x2F;08&#x2F;16 你上回是不是问过我理想生活什么样我现在觉得等以后有钱买一块地，建个高层，我觉得萧敬腾那种高层挺好就是好像里面什么都有好健身房游泳馆停车场电影院摆手办收藏的什么什么的5530再修个停机坪买个直升机我在抖音看感觉直升机很好开😂 —— 2022&#x2F;08&#x2F;17 不用工作又有花不完的钱 —— 2020&#x2F;08&#x2F;20 我最近小愿望就是希望顺利拿驾照。并且能提升做饭水平其他目前就没啥哈哈计划下周和小姐妹杭州一日游去看看自己梦中情机—徕卡顺带吃一下点都德满足一下欲望 —— 2020&#x2F;08&#x2F;20 没有理想的人不伤心 —— 2020&#x2F;08&#x2F;20 吃好喝好有钱我爱的和爱我的都要身体健康，开心快乐没了吧哈哈哈哈哈哈哈哈哈没什么多大的抱负哈哈哈哈哈哈哈 —— 2020&#x2F;08&#x2F;20 过上我做的梦里的生活花不完的钱数不完的美男，天天有麻将打庸俗得很没有用的呐就是说等我过上了这种生活我又会有其他理想的生活我回答的只是现阶段的 —— 2020&#x2F;08&#x2F;20 说简单也简单，说难也难。能吃想吃的东西，能去想去的地方。经济基础能支撑自己并不太多的欲望就好 —— 2020&#x2F;08&#x2F;24 能做自己觉得有意义的事就行了吧，能让你觉得真正开心的事啊。 —— 2020&#x2F;10&#x2F;26 结尾的话因为我们都在路上，所以我能肯定这个答案后续还有很多补充，希望给出答案的你们，能提醒我，该添加新的采访结果了。 当然也有些朋友回避&#x2F;拒绝回答了这个采访，其实我觉得无所谓，并不介意，毕竟自我暴露真实想法，本来就是需要一点勇气。或许我没有得到你们的答案，但是你们心里给了自己的答案。 当然如果我都有一个共同朋友，你通过自己对他的了解，觉得这个答案是他的，也没必要找他对质，保留给对方一点隐私。 我们都没资格嘲笑别人的想法。 枯燥乏味的生活，有时候需要一点想象力，希望我们都能在生活找到一些乐趣，这也是这篇文章存在的意义。 最后，祝大家都能过自己的理想生活！！","categories":[],"tags":[{"name":"人间采访","slug":"人间采访","permalink":"https://screw-hand.com/tags/%E4%BA%BA%E9%97%B4%E9%87%87%E8%AE%BF/"}]},{"title":"antd源码浅析","slug":"antd-source","date":"2022-08-02T07:47:16.000Z","updated":"2024-03-17T09:23:22.648Z","comments":true,"path":"/post/antd-source/","link":"","permalink":"https://screw-hand.com/post/antd-source/","excerpt":"导读github上面有一些很“哇塞”的项目，在工作中呢，我们只是作为“使用者”的角色，去把这些开源项目应用在项目中。看着官网提供的资料，了解了这是什么、这怎么安装、这怎么使用、这有什么东西……这很常见，从使用者的角度上看，甚至社区上的项目写得好不好跟我们关系也不大。“能用就用，不能用就换一个，反正有很多选择”，这是很多人使用者的态度。这当然没问题。不过作为研发人员，我们可以不止步于此，可以进一步深入了解他们的项目代码。毕竟作者都开源了，肯定是希望社区上的用户能对他们的代码有更多的了解。开源给了所有技术人员一个机会——了解其他优秀开发者的项目机会。遗憾的是大部分开发者都不具备去独立分析一个开源项目的方法。看到优秀的项目代码，常常没办法搞懂整体设计、功能代码，想了解其实现也望而止步。 这是一个系列，以Ant Design UI（react）为示例，一起学习如何分析一个开源项目。","text":"导读github上面有一些很“哇塞”的项目，在工作中呢，我们只是作为“使用者”的角色，去把这些开源项目应用在项目中。看着官网提供的资料，了解了这是什么、这怎么安装、这怎么使用、这有什么东西……这很常见，从使用者的角度上看，甚至社区上的项目写得好不好跟我们关系也不大。“能用就用，不能用就换一个，反正有很多选择”，这是很多人使用者的态度。这当然没问题。不过作为研发人员，我们可以不止步于此，可以进一步深入了解他们的项目代码。毕竟作者都开源了，肯定是希望社区上的用户能对他们的代码有更多的了解。开源给了所有技术人员一个机会——了解其他优秀开发者的项目机会。遗憾的是大部分开发者都不具备去独立分析一个开源项目的方法。看到优秀的项目代码，常常没办法搞懂整体设计、功能代码，想了解其实现也望而止步。 这是一个系列，以Ant Design UI（react）为示例，一起学习如何分析一个开源项目。 通识从“编译层”的维度看（排序：底层依赖-&gt;高层实现），大概分成这几个领域： 机器码 编程语言 语言框架 代码项目 项目依赖 项目插件 …… 从项目类型的维度（排序：从难到易）大致可以分为： 编程语言 语言框架 开源软件 框架&#x2F;类库 框架&#x2F;类库的插件 业务项目（demo） 文档资料 只是粗略的分类，或许你有比我更好的分层方式；而且也不是固定的，比如有些开源项目，本身就是一个语言框架，那他可能就根本没有依赖其他语言框架，所有没有3也是正常的。 编译层和项目类型可以为我们快速定位一个开源项目的信息，以及是否值得你去分析；还有难易度，是否自己满足前置技能有分析其代码的能力。 比如“文档资料”是最没分析价值的，或许是文档的排版格式很漂亮，自己也想搞个很漂亮的文档页面；那应该得去看这个文档是用什么东西生成的，关注点就应该转移到这个文档生成框架了（“开源软件&#x2F;框架&#x2F;类库”）。 虽然我们是以Ant Design——一个ts语言、react框架（这里提前泄漏信息了，在没开始看资料前，应该是不知道这些信息的）的ui库为示例。 比如Spring Boot，是用Java写的，那么要去分析Spring Boot。前置条件是熟悉Java语法，以及对相关领域（网络请求、http、api、数据库操作）有所概念。而Django是用Python的写的，分析前也同样要对相关的编程语言、以及相关领域（同Spring Boot，因为它们都可以用于web开发）有所概念。甚至是需要确切的用过Spring Boot、Django开发过项目。强烈推荐在分析开源代码前，本身得作为“使用者”使用过这些代码有实际的运用，哪怕是最简单的运用。 所以这是一篇通用性非常强的文章，基本上拿到任何源码项目，都可以按照此文的套路进行粗略分析。 初识 写过完全没用过and的读者，如果用antd开发过项目，可以选择跳过此章节。从初窥继续。 官方网站：https://ant.design/index-cn 源码地址：https://github.com/ant-design/ant-design/ 如果之前用过Ant Design，也请忘记掉跟它相关的一切；现在我们仅有的是的一个源码地址、官方网站而已。 先了解一下它是什么，能做什么，怎么安装，怎么使用。 浏览官网先看官网，官网的首页一般都是一些“正确的废话”，很多时候并不能得到有实际作用的信息；最顶部的菜单：设计 文档 组件 资源 国内镜像 ……，这些有很大的信息量，先不看；最底部的脚页：相关资源 社区 帮助 更多产品 四大板块，都是外部链接，也先不看； 首页有个很明显的“开始使用按钮”，是专门写给使用者的，我们要第一个要看的是这个。 这个页面就有很多有效的信息量了，但是表述还是太过官网，个人理解可以用接地点的方法，稍微提取一些： React UI 组件库（是什么） 用来做中后台产品（能做什么） 开箱即用 用TypeScript写的 多语言支持 支持主题定制 最少兼容IE11 支持ssr 也能被Electron使用 用npm、yarn安装 &#x2F; 浏览器引入 &#x2F; 按需加载 （什么安装） 【简单示例 - 见上图】(怎么使用) 那么“它是什么，能做什么，怎么安装，怎么使用”，其实都知道了，这个时候也要知道使用antd的一些前置条件： React Typescript&#x2F;JavaScritpt npm 这也是antd对使用者的前置技能要求，若是不了解，建议先学好前置技能。 链接、谁在使用、如何贡献、社区互助：次要信息，不需要关注。 上图右侧边栏是文档用于文章章节定位；左侧是导航菜单，看完了此页面（Ant Design of React）就继续往下看；把整个文档完整看一遍；可以快速阅读，但不要跳过任何章节。 初用或许在上一章的时候，你已经跟着文档搭建，启动了一个antd的项目；文档提供了好几种方法（浏览器引入、create-react-app、create-react-app+typescript、umi）。这里用官网提供的create-react-app+typescript方式搭建；高级配置 暂时用不上，跳过。 一切顺利的话，我们会在localhost:3000看到一个蓝色的按钮。 项目提交链接 更多的信息把关注点放到官网的“最顶部的菜单”：设计 文档 组件 资源 国内镜像 ……。其实在初用那一章，我们就已经把“文档”模块给看完了；设计 资源 国内镜像 ，这几个点进去一看，没看到有关的使用信息，还是没必要看；而组件模块，才是antd最核心的教程； 把所有的组件都过一遍，试着在刚才的demo进行一些实例试用。 初窥到目前为止，我们都是以“使用者”的角色去使用一个开源项目。通过以上的使用经验，我们是时候开始接触源码层面了。 源码地址：https://github.com/ant-design/ant-design/ 红色：Code、Issuses、Pull requests —— 此代码项目的“代码”、“问题讨论”、“推拉请求”。 黄色：master是当前的分支，分支信息（目前有19个分支），标签信息(529个)； 绿色：“关于”，项目介绍、官网链接、开源许可协议，start、watch、forks等信息。 蓝色：releases信息，开源代码发布正式代码产生的信息。 咖啡箭头：Octotree——一个浏览器插件，可树形结构显示Github项目。 当前查看的代码是默认分支（master，由仓库设置）的代码，想查看其他分支的代码，可以在master那个改变分支名。 在此页面滚动下来的README.md，是根目录下的README.md文件，一般也是些文档资料；关于文档资料，看中文还是英文的，个人建议是：原则是看原文的，即——国内项目看中文，国外项目看英文。 获取源码现在我们要clone源码，点击上图的绿色按钮“Code”，有三种方式Clone代码，最通用的是使用HTTPS方式，红色箭头点击可直接复制url。 不一定要clone源码到本地，有时候我们只是想简单看看源码的几个文件，并不需要全盘分析整个项目。有三个工具，都可以很方便查阅代码。 Octotree——下载对应的浏览器插件，简单配置好github auth token，即可在浏览器左侧使用 github1s——直接在浏览器地址栏github后面加上1s即可：https://github1s.com&#x2F;ant-design&#x2F;ant-design&#x2F; github dev——直接在浏览器地址栏.com换成.dev即可：https://github.dev&#x2F;ant-design&#x2F;ant-design&#x2F; clone下来后，当前的分支(branch)是默认分支，建议是把HEAD切换到最新的release那份代码，这里的最新release是4.21.7。也是此章节蓝框点进去的链接。如果是业务项目出问题了，对项目依赖库进行问题排查，建议切换到项目实际使用的版本。 绿：这次的发布是从master发布的 红：此次发布的代码标签 蓝：此次发布的代码提交id antd的源码仓库1G+，实在太大了，如果真的clone不来，可以去release页面，翻到最下面的“Source Code”选择压缩包下载；代价就是失去git管理的信息。 > $ git clone https://github.com/ant-design/ant-design.git Cloning into 'ant-design'... remote: Enumerating objects: 341830, done. remote: Counting objects: 100% (892/892), done. remote: Compressing objects: 100% (626/626), done. remote: Total 341830 (delta 396), reused 546 (delta 191), pack-reused 340938 Receiving objects: 100% (341830/341830), 937.73 MiB | 3.88 MiB/s, done. Resolving deltas: 100% (227846/227846), done. > $ cd ant-design > $ git reset --hard 10b153f > $ git checkout -b v4.21.7 重置HEAD到最新release的commit，并切出一条新的分支v4.21.7 版本软件工程领域中，版本的问题就跟软件名字一样重要，不同的小版本，也会有一些微小的区别，强烈建议版本要完全匹配；由于官网一般用的是最新发布的文档，所以我们在上一步，获取的是最新release的版本，已经完成了匹配。 这里顺便看看github仓库的分支、tag信息——Branches · ant-design&#x2F;ant-design 根目录分析现在开始正式分析源码，首先看项目根目录。根目录有很多东西，这里按照一个比较通用的分类。对根路径下的目录文件进行简单介绍，先不看文件&#x2F;目录的具体内容。文件&#x2F;目录的命名，一般特定的文件都有约定俗成的名称。 # 项目工程 ## git/github .git .github .gitignore .gitpod.yml .husky ## docker .dockerignore Dockerfile.ui-test docker-compose.yml ## 项目配置 .editorconfig .npmignore tsconfig.json webpack.config.js package.json renovate.json index-style-only.js index-with-locales.js ## 代码格式 .eslintignore .eslintrc.js .prettierignore .prettierrc .stylelintrc.json ## 测试相关 .jest.image.js .jest.js .jest.node.js .jest.site.js jest-puppeteer.config.js ## 其他 .codesandbox .depslintrc.js .remarkrc.js # 文档类 AUTHORS.txt CHANGELOG.en-US.md CHANGELOG.zh-CN.md CNAME CODE_OF_CONDUCT.md LICENSE README-ja_JP.md README-pt_BR.md README-sp_MX.md README-uk_UA.md README-zh_CN.md SECURITY.md # 代码入口文件 index.js # 目录 components docs tests typings scripts site 我们大概知道了根路径下的这些文件是什么东西，但是还有一小部分不知道，有些东西并不重要，可以忽略之；比如以上的项目工程-&gt;git、github、docker、测试、代码格式相关，对于antd的实现没有太大的关系，不建议细看。 项目起点根目录有两个很重要的文件——pckage.json、index.js，后者很有可能是整个项目的启动文件，但是我们目前还无法确定，现在就要来验证一下是否为项目的启动文件。 熟悉前端开发的小伙伴应该都明白package.json的重要性；每个现代前端项目，都会有package.json；里面的信息都是项目级别的元信息；这是最重要的文件了，我愿称之为项目起点文件。 打开常用的编辑器，检阅大致内容，关注以下配置； bin 命令行相关，引用的文件会被添加到PATH。 scripts 定义了一组可以运行的 node 脚本。 dependencies 设置了作为依赖安装的 npm 软件包的列表。 devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。 package.json 指南 scripts 中常用start、dev、server等关键字来启动项目，重点关注这几个字眼； dependencies、 devDependencies 可以知晓项目的一级依赖，大 概知道其技术栈； 其实当我们看到package.json就应该下意识去安装依赖。 > $ npm i # 省略掉npm的输出信息 > antd@4.21.7 prepare > husky install husky - Git hooks installed added 3655 packages in 7m 根目录会出现两个新玩意： package-lock.json——此项目的依赖的所有npm包，亦理解为描述node_modules的目录树文件（比package.json的dependencies更强大，可以在这个文件查看所有、层级依赖） node_modules——项目依赖包 启动项目环境信息： 操作系统—— macOs v12.4 node —— v14.19.3 npm —— v8.12.1 package.json中的第93行，”start”中调用了antd-tools这个东西，但是我们并不知道这个东西是从哪来的。 &#123; ... \"script\": &#123; \"start\": \"antd-tools run clean &amp;&amp; cross-env NODE_ENV=development concurrently \\\"bisheng start -c ./site/bisheng.config.js\\\"\", &#125; ... &#125; node的可执行文件，都会放在node_modules/.bin下面，所有我们要查看这个目录。 > $ ls node_modules/.bin ## 太多东西了，省略掉输出信息 > $ ls -l node_modules/.bin | grep 'antd-tools' antd-tools -> ../@ant-design/tools/bin/antd-tools.js antd-tools-run -> ../@ant-design/tools/bin/antd-tools-run.js # node_modules/.bin/antd-tools是一个软链接，指向 node_modules/@ant-design/tools/bin/antd-tools.js > $ cat node_modules/@ant-design/tools/package.json &#123; \"name\": \"@ant-design/tools\", ... \"homepage\": \"http://github.com/ant-design/antd-tools\", ... \"bin\": &#123; \"antd-tools\": \"./bin/antd-tools.js\", \"antd-tools-run\": \"./bin/antd-tools-run.js\" &#125; ... &#125; 通过node_modules/@ant-design/tools/package.json，我们得知了： antd-tools这个命令是由”@ant-design&#x2F;tools”提供的 “@ant-design&#x2F;tools”还提供了antd-tools-run命令行 首页http://github.com/ant-design/antd-tools 点开”homepage”，就是能看到@ant-design&#x2F;tools的源码了；如果去分析其代码实现，我们的关注点就变了，所以这里建议看完README.md等一些文档资料马上关闭掉这个网页。 package的script&#x3D;&gt;start配置很长，我们需要分成几个部分看看： antd-tools run clean cross-env NODE_ENV&#x3D;development concurrently bisheng start -c .&#x2F;site&#x2F;bisheng.config.js 还是用刚才的方法，从node_modules/.bin查看命令行由哪个依赖包提供，查看依赖包的package.json，从homepage找到一些资料，关于这个依赖包的说明。 当然，知道了包名（node_modes下的目录都是包名）也可以直接去npm官网查找这个包的资料。如node_moudles/@ant-design/tools/ &#x3D;&gt; https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@ant-design&#x2F;tools > $ ll node_modules/.bin | grep -E 'antd-tools | cross-env | concurrently | bisheng' antd-tools -> ../@ant-design/tools/bin/antd-tools.js bisheng -> ../bisheng/bin/bisheng concurrently -> ../concurrently/dist/bin/concurrently.js cross-env -> ../cross-env/src/bin/cross-env.js 结论是： antd-tools —— 专门为antd开发的cli工具 bisheng —— 将Mardown转换成用React构建的静态网站 concurrently —— 同时运行多个命令 cross-env —— 跨平台设置环境变量 所以一条简单的npm start，至少使用了4个依赖包……那就先启动项目吧。 Antd官网的贡献指南- 开发流程章节也有对重要script命令简单介绍。 > $ npm start > antd@4.21.7 prestart > npm run version > antd@4.21.7 version > node ./scripts/generate-version > antd@4.21.7 start > antd-tools run clean &amp;&amp; cross-env NODE_ENV=development concurrently \"bisheng start -c ./site/bisheng.config.js\" antd-tools run clean [0] ℹ Compiling 🚚 Bisheng [0] ℹ ｢wds｣: Project is running at http://localhost:8001/ [0] ℹ ｢wds｣: webpack output is served from undefined [0] ℹ ｢wds｣: Content not from webpack is served from /Users/wu/Documents/code/ant-design/_site [0] ℹ ｢wds｣: 404s will fallback to /index.html [0] ✔ 🚚 Bisheng: Compiled successfully in 55.77s [0] DONE Compiled successfully in 55766ms11:51:08 AM [0] [0] WAIT Compiling...11:51:09 AM [0] [0] ℹ Compiling 🚚 Bisheng [0] ✔ 🚚 Bisheng: Compiled successfully in 801.56ms [0] DONE Compiled successfully in 804ms11:51:11 AM [0] 以上的输出信息都比较重要，建议自行翻译理解。 两次“DONE”之后，浏览器上http://localhost:8001/就能看到启动的官网。所以npm start其实是启动了一个官网项目的网站。这个官网由bisheng（毕升）驱动的，bisheng的指定了配置文件。site/bisheng.config.js，npm start使用了这个配置文件；我们也应该打开看看，35～41行有source的配置；得去bisheng的REAMD.md看看有没有关于配置文件source的资料;source是存放Markdown文件的配置，官网提供的是字符串例子；可是antd却使用了对象方式去配置，遗憾的是没找到对象配置的例子。不再研究bisheng的配置，继续看bisheng的配置文件； source: &#123; components: './components', docs: './docs', changelog: ['CHANGELOG.zh-CN.md', 'CHANGELOG.en-US.md'], 'components/form/v3': ['components/form/v3.zh-CN.md', 'components/form/v3.en-US.md'], 'docs/resources': ['./docs/resources.zh-CN.md', './docs/resources.en-US.md'], &#125; changelog、’components&#x2F;form&#x2F;v3’、’docs&#x2F;resources’，都是配置的是MarkDown文件路径，都扫一眼，发现没啥特殊是，只是网站组成的页面一部分；docs&#x2F;components都是目录，先看看目录有什么东西； > $ ls docs/ components/ components: ## 省略输出 docs/: react resources.en-US.md resources.zh-CN.md spec components下有个我们熟悉的index.tsx，components&#x2F;index.tsx这个模块导出了很多组件，组件名都能跟官网的组件总览一一对应可以得知这个文件时组件的入口文件；我们用最简单的Button示例， http://localhost:8001/components/button-cn/这个页面有“按钮用于开始一个即时操作。”的文本，用vscode全局搜索，得知这段话来源于——components&#x2F;button&#x2F;index.zh-CN.md ，试着修改这段文本，在本地的官网项目查看效果。 然而页面下面的“代码演示”的源码内容并没有包含在此文件里；通过bisheng的主题配置去找“生成规则”太浪费时间了（还是得注意我们的关注点在antd，其他都不关注）；用VScode搜索Primary Button字段，尝试修改components&#x2F;button&#x2F;demo&#x2F;basic.md 小结： components&#x2F;index.tsx 组件的总入口文件 components/[name] 一个目录对应一个组件 components/[name]/index.tsx 组件模块级别的入口文件，导出组件级别模块 components/[name]/index.zh-CN.md 组件页面入口文件 components/[name]/demo 组件页面入口“代码示例” 调试代码 console.log 浏览器断点调试 源码断点调试 React JavaScript Tutorial in Visual Studio Code 包别名npm-link | npm Docs 体系家族Ant Desigin有很庞大的体系，通过之前的阅读源码我们触及到了其体系下的多个npm包——“@ant-design&#x2F;tools”、rc-\\*组件，还有官网footer下的一些相关资源推荐。 Ant Design Charts Ant Design Pro Ant Design Pro Components Ant Design Mobile Ant Design Landing Awesome Ant Design Ant Design Team · GitHub 初心分析开源项目是一件比较费时费力的事情，我们在开始分析代码前，最好确定一下为什么要分析源码，以及真的有必要吗。 学习优秀的同类项目 使用开源项目过程中报错，定位bug是否在此项目 技术调研（成本偏高）","categories":[],"tags":[]},{"title":"《JavaScript高级程序设计（第4版）》的笔记","slug":"《JavaScript高级程序设计（第4版）》","date":"2022-03-20T12:37:34.000Z","updated":"2024-03-17T09:23:23.108Z","comments":true,"path":"/post/《JavaScript高级程序设计（第4版）》/","link":"","permalink":"https://screw-hand.com/post/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89%E3%80%8B/","excerpt":"JavaScript高级程序设计（第4版） 马特·弗里斯比278个想法","text":"JavaScript高级程序设计（第4版） 马特·弗里斯比278个想法 序https://weread.qq.com/web/reader/751326d0720befab7514782k4e73277021a4e732ced3b55 工业革命是钢铁铸就的，互联网革命则是JavaScript造就的。25年的反复锻造与打磨，成就了JavaScript在今天的应用程序开发中毋庸置疑的统治地位，但并非一开始就是如此。Brendan Eich只用10天就写出了JavaScript的第一版。初生的JavaScript看似弱不禁风，但历史表明，第一印象并不代表一切。今天，这门语言的每个细节，也就是这本书所涉及的方方面面，都是反复推敲的产物。并非所有决定都让人满意，也没有完美的编程语言，不过单从无所不在这方面看，JavaScript倒是很接近完美。它是目前唯一一个可以随处部署的语言：服务器、桌面浏览器、手机浏览器，甚至原生移动应用程序中都有它的身影。JavaScript目前的使用者有不同层次的软件工程师，他们的背景各异。无论是以开发设计精良、优雅的软件为目标，还是仅仅为了完成业绩而简单堆砌一个系统，JavaScript都能派上用场。怎么使用JavaScript完全取决于你。一切尽在你的掌握之中。在我超过15年的软件开发生涯中，JavaScript工具和最佳实践已经发生了天翻地覆的变化。2004年，我开始接触这门语言，当时还是雅虎地球村（Geocities）、雅虎群组（Yahoo Groups）和Macromedia Flash播放器的天下。JavaScript给人感觉像个玩具，当时我在RSS、MySpace Profile Pages等流行的沙盒环境中开始使用它。后来我又帮助一些个人网站修改和自定义功能，那种感觉就像在狂野的西部拓荒，而我也因此喜欢上了它。当初我创建第一家公司的时候，配置主机装个数据库要花几天时间，而JavaScript只要扔到HTML里就可以跑起来。“前端应用程序”是不存在的，主要是零七碎八的函数。后来Ajax因为jQuery火了而变得更加流行，这才打开了通向新世界的大门，可靠、稳定的应用程序应运而生。这股风潮愈演愈烈，直到有一天遇到了发展瓶颈，但突然间，强大的框架诞生了。前端模型、数据绑定、路由管理、反应式视图，全都爆发出来了。我就在这个时候搬到硅谷，帮人打理一家公司。很快，使用我代码的用户达到了几百万。置身硅谷这么长时间以来，我也为开源做了一些贡献，培训了不计其数的软件工程师，也走了一点儿运。我的上一家公司在2018年被Stripe收购，我现在就供职于这家公司，致力于为互联网构建其经济基础设施。我很高兴在马特第一次到帕洛阿尔托的一家小型创业公司领导工程化时结识了他。那家公司叫Claco，当时我刚成为它的顾问。他追求伟大软件的活力和激情溢于言表，而这家羽翼未丰的公司很快就开发出一款漂亮的产品。一如为硅谷公司设立标杆的惠普，这家创业公司也诞生在一间平房里。但这可不是寻常的民房，而是一间“黑客屋”，里面十几位才华横溢的软件工程师经常通宵达旦地工作。虽然过的不是什么高档次生活——他们坐的都是别人扔在大街上的那种沙发床和旧椅子——他们在这间房子里每天所写代码的数量和质量却引人瞩目。连续工作几小时后，大多数人会把精力投入到公司的另一个子项目上，然后又是几个小时的工作。不太会写代码的人也常受启发，发现自己学习的渴望，然后仅仅几个星期后就变成了代码能手。马特是促成这种开发效率的关键角色。他是“黑客屋”里经验最丰富的人，恰好也是思维最清晰、最专业的一个。拿到计算机工程学位并不能说明什么，只要在窗户或者白板上看到马特写的算法、性能计算以及代码，你就知道马特又在专注于他的下一个大项目。随着我对他了解的加深，我们成为了好朋友。他的领悟能力，他对培训工作的热爱，以及几乎可以把所有东西转化成笑话的能力，都是我所欣赏的品质。虽然马特是一位极具才华的软件工程师和项目领导，但他之所以能成为本书作者独一无二的人选，还是凭借他独有的经验和知识。他不仅仅花时间教别人，而且还把这本书写完了。在Claco，他开发了多款整体性产品，端到端地帮助教师在课堂上提供更好的学习体验。在DoorDash，他是第一位工程师，开发了一个可靠的物流配送系统并实现了高速增长，目前公司估值超过了120亿美元。最后，在Google，马特写的软件已经被这个星球上的数十亿人使用了。全情投入，快速增长，誉满天下——多数软件工程师终其一生也只能体验到其中一项，而且还得运气好。马特不仅体验到了全部，还成为了畅销书作者。除了本书，他还写了两本JavaScript和Angular的书。说实话，我就想知道他什么时候能写一本书，把自己管理时间的奥秘分享出来。本书是一部翔实的工具书，满满的都是JavaScript知识和实用技术。我热切希望本书读者能够不断学习，并亲手打造属于自己的梦想。欢迎大家多多挑错，多记笔记，别忘了打开代码编辑器，毕竟互联网革命才刚刚开始！Zach TratarStripe软件工程师Jobstart联合创始人、前CEO 1.1 简短的历史回顾 两个版本的JavaScript:Netscape Navigator中的JavaScript，以及IE中的JScript。 1997年，JavaScript 1.1作为提案被提交给欧洲计算机制造商协会（Ecma）。第39技术委员会（TC39）承担了“标准化一门通用、跨平台、厂商中立的脚本语言的语法和语义”的任务（参见TC39-ECMAScript）。TC39委员会由来自网景、Sun、微软、Borland、Nombas和其他对这门脚本语言有兴趣的公司的工程师组成。他们花了数月时间打造出ECMA-262，也就是ECMAScript（发音为“ek-ma-script”）这个新的脚本语言标准。 1.2 JavaScript实现 ECMA-262将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。 https://es6.ruanyifeng.com/ ECMA-262第6版，俗称ES6、ES2015或ES Harmony（和谐版），于2015年6月发布。这一版包含了大概这个规范有史以来最重要的一批增强特性。ES6正式支持了类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型。 https://maninboat.gitbooks.io/you-dont-know-js-es6/content/ch8.3.html ECMA-262第7版，也称为ES7或ES2016，于2016年6月发布。这次修订只包含少量语法层面的增强，如Array.prototype.includes和指数操作符。 ECMA-262第7版，也称为ES7或ES2016，于2016年6月发布。这次修订只包含少量语法层面的增强，如Array.prototype.includes和指数操作符。 ECMA-262第8版，也称为ES8、ES2017，完成于2017年6月。这一版主要增加了异步函数（async&#x2F;await）、SharedArrayBuffer及Atomics API，以及Object.values()&#x2F;Object.entries()&#x2F;Object. getOwnPropertyDescriptors()和字符串填充方法，另外明确支持对象字面量最后的逗号。 ECMA-262第9版，也称为ES9、ES2018，发布于2018年6月。这次修订包括异步迭代、剩余和扩展属性、一组新的正则表达式特性、Promise finally()，以及模板字面量修订。 ECMA-262第10版，也称为ES10、ES2019，发布于2019年6月。这次修订增加了Array.prototype. flat()&#x2F;flatMap()、String.prototype.trimStart()&#x2F;trimEnd()、Object.fromEntries()方法，以及Symbol.prototype.description属性，明确定义了Function.prototype.toString()的返回值并固定了Array.prototype.sort()的顺序。另外，这次修订解决了与JSON字符串兼容的问题，并定义了catch子句的可选绑定。 万维网联盟（W3C, World Wide Web Consortium）开始了制定DOM标准的进程。 目前，W3C不再按照Level来维护DOM了，而是作为DOM Living Standard来维护，其快照称为DOM4。 1.4 小结 JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。❑ ECMAScript：由ECMA-262定义并提供核心功能。❑ 文档对象模型（DOM）：提供与网页内容交互的方法和接口。❑ 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。JavaScript的这三个部分得到了五大Web浏览器（IE、Firefox、Chrome、Safari和Opera）不同程度的支持。所有浏览器基本上对ES5（ECMAScript 5）提供了完善的支持，而对ES6（ECMAScript 6）和ES7（ECMAScript 7）的支持度也在不断提升。这些浏览器对DOM的支持各不相同，但对Level 3的支持日益趋于规范。HTML5中收录的BOM会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共特性。 2.1 &lt;script&gt;元素https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script#%E5%B1%9E%E6%80%A7 &lt;script&gt;元素有下列8个属性。 把所有JavaScript文件都放在&lt;head&gt;里，也就意味着必须把所有JavaScript代码都下载、解析和解释完成后，才能开始渲染页面（页面在浏览器解析到&lt;body&gt;的起始标签时开始渲染）。对于需要很多JavaScript的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。为解决这个问题，现代Web应用程序通常将所有JavaScript引用放在&lt;body&gt;元素中的页面内容后面 defer的属性。这个属性表示脚本在执行的时候不会改变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在&lt;script&gt;元素上设置defer属性，相当于告诉浏览器立即下载，但延迟执行。 async属性与defer类似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与defer不同的是，标记为async的脚本并不保证能按照它们出现的次序执 2.5 小结 JavaScript是通过&lt;script&gt;元素插入到HTML页面中的。这个元素可用于把JavaScript代码嵌入到HTML页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的JavaScript。本章的重点可以总结如下。❑ 要包含外部JavaScript文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。❑ 所有&lt;script&gt;元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在&lt;script&gt;元素中的代码必须严格按次序解释。❑ 对不推迟执行的脚本，浏览器必须解释完位于&lt;script&gt;元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把&lt;script&gt;元素放到页面末尾，介于主内容之后及标签之前。❑ 可以使用defer属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。❑ 可以使用async属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。❑ 通过使用&lt;noscript&gt;元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则&lt;noscript&gt;元素中的任何内容都不会被渲染。 第3章 语言基础 语法❑ 数据类型❑ 流控制语句❑ 理解函数任何语言的核心所描述的都是这门语言在最基本的层面上如何工作，涉及语法、操作符、数据类型以及内置功能，在此基础之上才可以构建复杂的解决方案。 3.1 语法 ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。 所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：❑ 第一个字符必须是一个字母、下划线（_）或美元符号（$）；❑ 剩下的其他字符可以是字母、下划线、美元符号或数字。标识符中的字母可以是扩展ASCII（Extended ASCII）中的字母，也可以是Unicode的字母字符，如À和Æ（但不推荐使用）。 按照惯例，ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写 3.3 变量 ECMAScript变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var、const和let。 let声明的范围是块作用域，而var声明的范围是函数作用域。 let与var的另一个重要的区别，就是let声明的变量不会在作用域中被提升。 在let声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出ReferenceError。 使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）。 let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免SyntaxError，必须确保页面不会重复声明同一个变量。 不能使用let进行条件式声明是件好事，因为条件声明是一种反模式，它让程序变得更难理解。如果你发现自己在使用这个模式，那一定有更好的替代方式。 let出现之前，for循环定义的迭代变量会渗透到循环体外部 改成使用let之后，这个问题就消失了，因为迭代变量的作用域仅限于for循环块内部 const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误。 const声明的限制只适用于它指向的变量的引用。换句话说，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制。 不能用const来声明迭代变量（因为迭代变量会自增） 只想用const声明一个不会被修改的for循环变量，那也是可以的。 ECMAScript 6增加let和const从客观上为这门语言更精确地声明作用域和语义提供了更好的支持。 使用const声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用const来声明变量，只在提前知道未来会有修改时，再使用let。 3.4 数据类型 ECMAScript有6种简单数据类型（也称为原始类型）: Undefined、Null、Boolean、Number、String和Symbol。Symbol（符号）是ECMAScript 6新增的。还有一种复杂数据类型叫Object（对象）。Object是一种无序名值对的集合。 typeof function () {} &#x2F;&#x2F; “function”typeof Function &#x2F;&#x2F; “function”typeof Object &#x2F;&#x2F; “function”typeof Object &#x2F;&#x2F; “function”typeof [] &#x2F;&#x2F; “object”typeof {} &#x2F;&#x2F; “object” Object instanceof Function &#x2F;&#x2F; trueFunction instanceof Object &#x2F;&#x2F; true 对一个值使用typeof操作符会返回下列字符串之一：❑ “undefined”表示值未定义；❑ “boolean”表示值为布尔值；❑ “string”表示值为字符串；❑ “number”表示值为数值；❑ “object”表示值为对象（而不是函数）或null；❑ “function”表示值为函数；❑ “symbol”表示值为符号。 严格来讲，函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象。 Null类型同样只有一个值，即特殊值null。逻辑上讲，null值表示一个空对象指针，这也是给typeof传一个null会返回”object”的原因 任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用null来填充该变量。这样就可以保持null是空对象指针的语义，并进一步将其与undefined区分开来。 这两个布尔值不同于数值，因此true不等于1，false不等于0。 布尔值字面量true和false是区分大小写的，因此True和False（及其他大小混写形式）是有效的标识符，但不是布尔值。 Number类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。 整数也可以用八进制（以8为基数）或十六进制（以16为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数 ECMAScript 2015或ES6中的八进制值通过前缀0o来表示；严格模式下，前缀0会被视为语法错误，如果要表示八进制值，应该使用前缀0o。——译者注 八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。 八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。 要创建十六进制字面量，必须让真正的数值前缀0x（区分大小写），然后是十六进制数字（0~9以及A~F）。十六进制数字中的字母大小写均可。 使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。 因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着0（如1.0），那它也会被转换为整数 对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10的给定次幂的数值。ECMAScript中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10的多少次幂。 科学记数法也可以用于表示非常小的数值，例如0.00000000000000003。这个数值用科学记数法可以表示为3e-17。默认情况下，ECMAScript会将小数点后至少包含6个零的浮点值转换为科学记数法（例如，0.000000 3会被转换为3e-7）。 浮点值的精确度最高可达17位小数，但在算术计算中远不如整数精确。例如，0.1加0.2得到的不是0.3，而是0.30000000000000004。 ECMAScript可以表示的最小数值保存在Number.MIN_VALUE中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在Number.MAX_VALUE中，这个值在多数浏览器中是1.797693134862315 7e+308。如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以Infinity（正无穷大）表示。 console.log(0&#x2F;0); &#x2F;&#x2F; NaNconsole.log(-0&#x2F;+0); &#x2F;&#x2F; NaN 有一个特殊的数值叫NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回NaN 有一个特殊的数值叫NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回NaN console.log(5&#x2F;0); &#x2F;&#x2F; Infinityconsole.log(5&#x2F;-0); &#x2F;&#x2F; -Infinity 如果分子是非0值，分母是有符号0或无符号0，则会返回Infinity或-Infinity 如果分子是非0值，分母是有符号0或无符号0，则会返回Infinity或-Infinity NaN计算操作，返回NaN；NaN不等于其本身，用isNaN()判断。 NaN有几个独特的属性。首先，任何涉及NaN的操作始终返回NaN（如NaN&#x2F;10），在连续多步计算时这可能是个问题。其次，NaN不等于包括NaN在内的任何值。 ECMAScript提供了isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致这个函数返回true。 #TODO 注意 虽然不常见，但isNaN()可以用于测试对象。此时，首先会调用对象的valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用toString()方法，并测试其返回值。这通常是ECMAScript内置函数和操作符的工作方式，本章后面会讨论。 有3个函数可以将非数值转换为数值：Number()、parseInt()和parseFloat()。Number()是转型函数，可用于任何数据类型。 Number()函数基于如下规则执行转换。❑ 布尔值，true转换为1，false转换为0。❑ 数值，直接返回。❑ null，返回0。❑ undefined，返回NaN。❑ 字符串，应用以下规则。__ ■ 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”)返回1, Number(“123”)返回123, Number(“011”)返回11（忽略前面的零）。__ ■ 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。__ ■ 如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。__ ■ 如果是空字符串（不包含字符），则返回0。__ ■ 如果字符串包含除上述情况之外的其他字符，则返回NaN。❑ 对象，调用valueOf()方法，并按照上述规则转换返回的值。如果转换结果是NaN，则调用toString()方法，再按照转换字符串的规则转换。 parseInt()工作机制： 从非空字符开始转换 非数值、加号、减号开头返回NaN 空字符串也返回NaN 非以上情况继续转换 可支持不同的进制格式字符 非数值&#x2F;末尾字符结束转换 第二个参数支持指定2~36进制，强制识别 parseInt(‘0xA’, 10) &#x2F;&#x2F; 0xA 十进制为10，此处返回0 考虑到用Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN。这意味着空字符串也会返回NaN（这一点跟Number()不一样，它返回0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，”1234blue”会被转换为1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为22，因为小数点不是有效的整数字符。假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以”0x”开头，就会被解释为十六进制整数。如果字符串以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。 考虑到用Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN。这意味着空字符串也会返回NaN（这一点跟Number()不一样，它返回0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，”1234blue”会被转换为1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为22，因为小数点不是有效的整数字符。假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以”0x”开头，就会被解释为十六进制整数。如果字符串以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。 传底数参数相当于让parseInt()自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。 parseFloat()函数的工作方式跟parseInt()函数类似，都是从位置0开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，”22.34.5”将转换成22.34。 parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回0。因为parseFloat()只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则parseFloat()返回整数。 https://developer.mozilla.org/zh-CN/docs/Glossary/Unicode String（字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示 String（字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示 注意 如果字符串中包含双字节字符，那么length属性返回的值可能不是准确的字符数。第5章将具体讨论如何解决这个问题。 3.5 操作符 后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。 ECMAScript中的所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位。 4.3 垃圾回收 JavaScript最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。 另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。 开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。 5.3 原始值包装类型 JavaScript字符串使用了两种Unicode编码混合的策略：UCS-2和UTF-16。对于可以采用16位编码的字符（U+0000~U+FFFF） 5.5 小结 JavaScript比较独特的一点是，函数实际上是Function类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。 6.2 ArrayArray.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。 显然form比偶of更加强大。 Array构造函数还有两个ES6新增的用于创建数组的静态方法：from()和of()。from()用于将类数组结构转换为数组实例，而of()用于将一组参数转换为数组实例。 Array构造函数还有两个ES6新增的用于创建数组的静态方法：from()和of()。from()用于将类数组结构转换为数组实例，而of()用于将一组参数转换为数组实例。 function fn () { console.log(Array.from(arguments)) }fn(1,2,3,4,5) &#x2F;&#x2F; Array(5) [ 1, 2, 3, 4, 5 ] Array.of()可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的Array.prototype.slice.call(arguments) Array.of()可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的Array.prototype. slice.call(arguments) 在ES6中，Array的原型上暴露了3个用于检索数组内容的方法：keys()、values()和entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而entries()返回索引&#x2F;值对的迭代器 栈是一种后进先出（LIFO, Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个地方发生，即栈顶。 push()、shift() 队列以先进先出（FIFO, First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。 队列以先进先出（FIFO, First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。 6.3 定型数组只是在介绍一些基础理论还有api使用，并没有涉及具体场景以及区别，详细内容更建议看https://es6.ruanyifeng.com/#docs/arraybuffer 定型数组（typed array）是ECMAScript新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。 定型数组（typed array）是ECMAScript新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。 OpenGL ES是OpenGL专注于2D和3D计算机图形的子集。这个新API被命名为WebGL（Web Graphics Library） 注意 SharedArrayBuffer是ArrayBuffer的一个变体，可以无须复制就在执行上下文间传递它。关于这种类型，请参考第27章。 ArrayBuffer()是一个普通的JavaScript构造函数，可用于在内存中分配特定数量的字节空间。 ArrayBuffer某种程度上类似于C++的malloc()，但也有几个明显的区别 7.1 理解迭代Q 迭代是什么？A 有条件的重复执行，循环是是最基础的迭代方式。迭代器模式——某些内置的类型拥有Symbol.iterator属性（该属性是迭代器工厂模式，调用可返回一个新的迭代器）。很多时候不需要显示调用，某些常用操作语法会自动调用。 迭代器API使用next()方法在可迭代对象中遍历数据。每次成功调用next()，都会返回一个IteratorResult对象，其中包含迭代器返回的下一个值。若不调用next()，则无法知道迭代器的当前位置。 非内置支持迭代器的类型也可使用Symbol.iterator定义一个迭代器，显示声明next函数。须知迭代器是一次性的，为了创建多歌迭代器，Symbol.iterator可以使用闭包返回迭代器。 Q 为了解决什么问题？A迭代之前需要事先知道如何使用数据结构、 遍历顺序并不是数据结构固有的。 Q特点是什么？ A迭代器不关注类型的数据结构和遍历顺序（递增、递减等），也可以提前终止迭代器。 —————— Q 生成器是什么？A 一种异步编程解决方案，函数内能暂停和恢复代码执行、带星号（*）的funciton就是一个生成器，初始化的时状态为暂停执行。通过next()方法让生成器开始或恢复执行。yield关键字可以让生成器停止和开始执行。 Q 生成器的作用A 生成器对象作为可迭代对象，next() 开始&#x2F;恢复执行生成器，yield暂停；yied *可产生迭代器对象。 Q 生成器跟迭代器的联系。A 浅显的理解：基于迭代器实现，也有相同的next()函数。也可以把生成器作为迭代对象使用。 7.1 理解迭代 7.1 理解迭代 在ECMAScript较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现迭代操作。这个解决方案就是迭代器模式。 7.2 迭代器模式 迭代器模式（特别是在ECMAScript这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的Iterable接口，而且可以通过迭代器Iterator消费。 ‘’[Symbol.iterator] &#x2F;&#x2F; function Symbol.iterator()‘’Symbol.iterator &#x2F;&#x2F;String Iterator { } 实现Iterable接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator接口的对象的能力。在ECMAScript中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的Symbol.iterator作为键。 Symbol.iterator是一个默认迭代器，要想知道某个类型的变量是否有迭代功能， 可以检测该变量是否拥有该属性；且此属性返回一个迭代器器工厂函数（调用此工厂函数会返回一个新的迭代器），部分内置类型已实现Iterable接口。 实现Iterable接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator接口的对象的能力。在ECMAScript中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的Symbol.iterator作为键。 实现Iterable接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator接口的对象的能力。在ECMAScript中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的Symbol.iterator作为键。 在进行某些操作的时候，会自动调用类型的Symbol.itator迭代工厂函数生成一个迭代器：for (let i of ‘str’) {console.log(i)} &#x2F;&#x2F; 依次输出s、t、r 实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。 实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。 迭代器API使用next()方法在可迭代对象中遍历数据。每次成功调用next()，都会返回一个IteratorResult对象，其中包含迭代器返回的下一个值。若不调用next()，则无法知道迭代器的当前位置。 为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此，可以把计数器变量放到闭包里，然后通过闭包返回迭代器 7.3 生成器 拥有在一个函数块内暂停和恢复代码执行的能力。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程。 8.1 理解对象 数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。 使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。 8.2 创建对象 ECMAScript的构造函数就是能创建对象的函数。 constructor本来是用于标识对象类型的。不过，一般认为instanceof操作符是确定对象类型更可靠的方式。 构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。 ECMAScript的Object类型有一个方法叫Object.getPrototypeOf()，返回参数的内部特性[[Prototype]]的值。 Object.values()返回对象值的数组，Object.entries()返回键&#x2F;值对的数组。 8.4 类 类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法 ECMAScript中没有正式的类这个类型。从各方面来看，ECMAScript类就是一种特殊函数。声明一个类之后，通过typeof操作符检测类标识符，表明它是一个函数 可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据： 类定义也支持获取和设置访问器。 可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个。 类继承使用的是新语法，但背后依旧使用的是原型链。 派生类的方法可以通过super关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数。 new.target保存通过new关键字调用的类或函数。通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化 ES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型 软件设计原则：“组合胜过继承（composition over inheritance）。” 9.1 代理基础 代理是使用Proxy构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。 使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。 只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。 9.2 代理捕获器与反射方法 对于在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。 Q 捕获器跟反射API的区别？？ get()捕获器会在获取属性值的操作中被调用。对应的反射API方法为Reflect.get()。 get()捕获器会在获取属性值的操作中被调用。对应的反射API方法为Reflect.get()。 9.4 小结 宏观上看，代理是真实JavaScript对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分JavaScript的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从捕获器不变式。 代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。 第10章 函数 因为函数实际上是对象。每个函数都是Function类型的实例，而Function也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。 函数想象为对象，把函数名想象为指针 10.1 箭头函数 箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用arguments、super和new.target，也不能用作构造函数。此外，箭头函数也没有prototype属性。 10.2 函数名 ECMAScript 6的所有函数对象都会暴露一个只读的name属性，其中包含关于函数的信息。 10.3 理解参数 arguments对象是一个类数组对象（但不是Array的实例），因此可以使用中括号语法访问其中的元素 ECMAScript函数的参数只是为了方便才写出来的，并不是必须写出来的。 然箭头函数中没有arguments对象，但可以在包装函数中把它提供给箭头函数 10.5 默认参数值 函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。 10.6 参数扩展与收集 箭头函数虽然不支持arguments对象，但支持收集参数的定义方式，因此也可以实现与使用arguments一样的逻辑： 10.7 函数声明与函数表达式 JavaScript引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。 10.9 函数内部 使用arguments.callee就可以让函数逻辑与函数名解耦 函数名只是保存指针的变量。因此全局定义的sayColor()函数和o.sayColor()是同一个函数，只不过执行的上下文不同。 10.10 函数属性与方法 函数还有两个方法：apply()和call()。 使用call()或apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。 10.14 闭包 包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。 11.1 异步编程 同步行为对应内存中顺序执行的处理器指令。 异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。 第二个指令块（加操作及赋值操作）是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发这个中断，这对JavaScript运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前线程的同步代码执行之后，否则回调都没有机会出列被执行）。无论如何，在排定回调以后基本没办法知道系统状态何时变化。 随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。嵌套回调的代码维护起来就是噩梦。 11.2 期约 2012年Promises&#x2F;A+组织分叉（fork）了CommonJS的Promises&#x2F;A建议，并以相同的名字制定了Promises&#x2F;A+规范。这个规范最终成为了ECMAScript 6规范实现的范本。 ❑ 待定（pending）❑ 兑现（fulfilled，有时候也称为“解决”, resolved）❑ 拒绝（rejected） 无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。 期约故意将异步行为封装起来，从而隔离外部的同步代码。 对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法 Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过try&#x2F;catch捕获，而只能通过拒绝处理程序捕获） 拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try&#x2F;catch块并不能捕获该错误。 then()和catch()的onRejected处理程序在语义上相当于try&#x2F;catch。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。 11.3 异步函数 [插图] 11.4 小结 异步函数是将期约应用于JavaScript函数的结果。异步函数可以暂停执行，而不阻塞主线程。 12.1 window对象 BOM的核心是window对象，表示浏览器的实例。window对象在浏览器中有两重身份，一个是ECMAScript中的Global对象，另一个就是浏览器窗口的JavaScript接口。 如果在这里使用let或const替代var，则不会把变量添加给全局对象 window.devicePixelRatio实际上与每英寸像素数（DPI, dots per inch）是对应的。DPI表示单位像素密度，而window.devicePixelRatio表示物理像素与逻辑像素之间的缩放系数。 12.2 location对象 它既是window的属性，也是document的属性。也就是说，window.location和document.location指向同一个对象。 URLSearchParams提供了一组标准API方法，通过它们可以检查和修改查询字符串。 14.1 节点层级 其中，document节点表示每个文档的根节点。在这里，根节点的唯一子节点是&lt;html&gt;元素，我们称之为文档元素（documentElement）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。 15.1 Selectors API 则querySelector()方法会抛出错误。 querySelectorAll()返回的NodeList实例一个属性和方法都不缺，但它是一个静态的“快照”，而非“实时”的查询。 第16章 DOM2和DOM3 DOM1（DOM Level 1）主要定义了HTML和XML文档的底层结构。DOM2（DOM Level 2）和DOM3（DOM Level 3）在这些结构之上加入更多交互能力，提供了更高级的XML特性。 16.2 样式 浏览器在每个元素上都暴露了getBoundingClientRect()方法，返回一个DOMRect对象，包含6个属性：left、top、right、bottom、height和width。这些属性给出了元素在页面中相对于视口的位置。图16-4[插图]展示了这些属性的含义。 17.1 事件流 IE事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）。 Netscape Communicator团队提出了另一种名为事件捕获的事件流。事件捕获的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件 由于旧版本浏览器不支持，因此实际当中几乎不会使用事件捕获。通常建议使用事件冒泡，特殊情况下可以使用事件捕获。 DOM2 Events规范规定事件流分为3个阶段：事件捕获、到达目标和事件冒泡。 17.2 事件处理程序 在JavaScript中指定事件处理程序的传统方式是把一个函数赋值给（DOM元素的）一个事件处理程序属性。 DOM2 Events为事件处理程序的赋值和移除定义了两个方法：addEventListener()和remove-EventListener()。 大多数情况下，事件处理程序会被添加到事件流的冒泡阶段，主要原因是跨浏览器兼容性好。把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件。如果不需要拦截，则不要使用事件捕获。 IE实现了与DOM类似的方法，即attachEvent()和detachEvent()。这两个方法接收两个同样的参数：事件处理程序的名字和事件处理函数。 17.3 事件对象 preventDefault()方法用于阻止特定事件的默认动作。 stopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后续的事件捕获或冒泡。 17.4 事件类型 当用户按下键盘上的某个字符键时，首先会触发keydown事件，然后触发keypress事件，最后触发keyup事件。 对于非字符键，在键盘上按一下这个键，会先触发keydown事件，然后触发keyup事件。如果按住某个非字符键不放，则会重复触发keydown事件，直到这个键被释放，此时会触发keyup事件。 对于keydown和keyup事件，event对象的keyCode属性中会保存一个键码，对应键盘上特定的一个键。对于字母和数字键，keyCode的值与小写字母和数字的ASCII编码一致。 浏览器在event对象上支持charCode属性，只有发生keypress事件时这个属性才会被设置值，包含的是按键字符对应的ASCII编码。 一旦有了字母编码，就可以使用String.fromCharCode()方法将其转换为实际的字符了。 17.5 内存与性能 事件委托利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件。 被innerHTML删除的元素上如果有事件处理程序，就不会被垃圾收集程序正常清理。 如果在页面卸载后事件处理程序没有被清理，则它们仍然会残留在内存中。之后，浏览器每次加载和卸载页面（比如通过前进、后退或刷新），内存中残留对象的数量都会增加，这是因为事件处理程序不会被回收。 17.6 模拟事件 任何时候，都可以使用document.createEvent()方法创建一个event对象。这个方法接收一个参数，此参数是一个表示要创建事件类型的字符串。 DOM3增加了自定义事件的类型。自定义事件不会触发原生DOM事件，但可以让开发者定义自己的事件。要创建自定义事件，需要调用createEvent(“CustomEvent”)。 18.1 使用requestAnimationFrame 因此，实现平滑动画最佳的重绘间隔为1000毫秒&#x2F;60，大约17毫秒。以这个速度重绘可以实现最平滑的动画，因为这已经是浏览器的极限了。 因为requestAnimationFrame()只会调用一次传入的函数，所以每次更新用户界面时需要再手动调用它一次。同样，也需要控制动画何时停止。结果就会得到非常平滑的动画。 通过requestAnimationFrame节流 19.5 富文本编辑 在空白HTML文件中嵌入一个iframe。通过designMode属性，可以将这个空白文档变成可以编辑的，实际编辑的则是&lt;body&gt;元素的HTML。 20.1 Atomics与SharedArrayBuffer SharedArrayBuffer与ArrayBuffer具有同样的API。二者的主要区别是ArrayBuffer必须在不同执行上下文间切换，SharedArrayBuffer则可以被任意多个执行上下文同时使用。 浏览器的JavaScript编译器和CPU架构本身都有权限重排指令以提升程序执行效率。正常情况下，JavaScript的单线程环境是可以随时进行这种优化的。但多线程下的指令重排可能导致资源争用，而且极难排错。 20.2 跨上下文消息 跨文档消息，有时候也简称为XDM（cross-document messaging），是一种在不同执行上下文（如不同工作线程或不同源的页面）间传递信息的能力。 20.3 Encoding API Encoding API主要用于实现字符串与定型数组之间的转换。规范新增了4个用于执行转换的全局类：TextEncoder、TextEncoderStream、TextDecoder和TextDecoderStream。 20.4 File API与Blob API File API仍然以表单中的文件输入字段为基础，但是增加了直接访问文件信息的能力。 FileReader类型表示一种异步文件读取机制。可以把FileReader想象成类似于XMLHttpRequest，只不过是用于从文件系统读取文件，而不是从服务器读取数据。F blob表示二进制大对象（binary larget object），是JavaScript对不可修改二进制数据的封装类型。包含字符串的数组、ArrayBuffers、ArrayBufferViews，甚至其他Blob都可以用来创建blob。 对象URL有时候也称作Blob URL，是指引用存储在File或Blob中数据的URL。 创建对象URL，可以使用window.URL.createObjectURL()方法并传入File或Blob对象。这个函数返回的值是一个指向内存中地址的字符串。 使用完数据之后，最好能释放与之关联的内存。只要对象URL在使用中，就不能释放内存。如果想表明不再使用某个对象URL，则可以把它传给window.URL.revokeObjectURL()。页面卸载时，所有对象URL占用的内存都会被释放。不过，最好在不使用时就立即释放内存，以便尽可能保持页面占用最少资源。 20.8 Page Visibility API Web开发中一个常见的问题是开发者不知道用户什么时候真正在使用页面。如果页面被最小化或隐藏在其他标签页后面，那么轮询服务器或更新动画等功能可能就没有必要了 20.9 Streams API 流的基本单位是块（chunk）。块可是任意数据类型，但通常是定型数组。 20.10 计时API微秒 [1] ，时间单位，符号μs（英语：microsecond ），1微秒等于百万分之一秒（10的负6次方秒），1毫秒等于千分之一秒（10的负3次方秒） [2] 。 为此，必须使用不同的计时API来精确且准确地度量时间的流逝。HighResolution Time API定义了window.performance.now()，这个方法返回一个微秒精度的浮点值。 为此，必须使用不同的计时API来精确且准确地度量时间的流逝。HighResolution Time API定义了window.performance.now()，这个方法返回一个微秒精度的浮点值。 Navigation Timing API提供了高精度时间戳，用于度量当前页面加载速度。 Resource Timing API提供了高精度时间戳，用于度量当前页面加载时请求资源的速度。 20.11 Web组件 概念上讲，影子DOM（shadow DOM）Web组件相当直观，通过它可以将一个完整的DOM树作为节点添加到父DOM树。 浏览器会尝试将无法识别的元素作为通用元素整合进DOM。当然，这些元素默认也不会做任何通用HTML元素不能做的事。 调用customElements.define()方法可以创建自定义元素。 20.12 Web Cryptography API 生成、使用和应用加密密钥对，加密和解密消息 在需要生成随机值时，很多人会使用Math.random()。这个方法在浏览器中是以伪随机数生成器（PRNG, PseudoRandom Number Generator）方式实现的。所谓“伪”指的是生成值的过程不是真的随机。PRNG生成的值只是模拟了随机的特性。浏览器的PRNG并未使用真正的随机源，只是对一个内部状态应用了固定的算法。 初始状态在重复自身之前都会产生2128-1个伪随机值。这种循环被称为置换循环（permutation cycle），而这个循环的长度被称为一个周期（period）。 伪随机数生成器主要用于快速计算出看起来随机的值。 密码学安全伪随机数生成器（CSPRNG, Cryptographically Secure PseudoRandom Number Generator）额外增加了一个熵作为输入，例如测试硬件时间或其他无法预计行为的系统特性。这样一来，计算速度明显比常规PRNG慢很多，但CSPRNG生成的值就很难预测，可以用于加密了。 加密、散列、签名和生成密钥 ❑ SHA-1（Secure Hash Algorithm 1）：架构类似MD5的散列函数。 ❑ SHA-2（Secure Hash Algorithm 2）：构建于相同耐碰撞单向压缩函数之上的一套散列函数。 这个算法被认为是安全的，广泛应用于很多领域和协议，包括TLS、PGP和加密货币（如比特币）。 21.2 错误处理 错误处理在编程中的重要性毋庸置疑。所有主流Web应用程序都需要定义完善的错误处理协议，大多数优秀的应用程序有自己的错误处理策略，尽管主要逻辑是放在服务器端的。 InternalError类型的错误会在底层JavaScript引擎抛出异常时由浏览器抛出。例如，递归过多导致了栈溢出。 RangeError错误会在数值越界时抛出。 ReferenceError会在找不到对象时发生。 最后一种错误类型是URIError，只会在使用encodeURI()或decodeURI()但传入了格式错误的URI时发生。 使用throw操作符时，代码立即停止执行，除非try&#x2F;catch语句捕获了抛出的值。 捕获错误的目的是阻止浏览器以其默认方式响应；抛出错误的目的是为错误提供有关其发生原因的说明。 何没有被try&#x2F;catch语句处理的错误都会在window对象上触发error事件。 Web应用程序开发中的一个常见做法是建立中心化的错误日志存储和跟踪系统。 21.3 调试技术 浏览器控制台是个读取-求值-打印-循环（REPL, read-eval-print-loop），与页面的JavaScript运行时并发。 21.4 旧版IE的常见错误 旧版IE中所有DOM对象都是用COM对象实现的，并非原生JavaScript对象。在涉及垃圾回收时，这可能会导致很多奇怪的行为。其中，”member not found”错误是IE中垃圾回收程序常报告的错误。 22.2 浏览器对XPath的支持 XPath是为了在DOM文档中定位特定节点而创建的，因此它对XML处理很重要。 第23章 JSON 理解JSON最关键的一点是要把它当成一种数据格式，而不是编程语言。 JSON也不是只能在JavaScript中使用，它是一种通用数据格式。很多语言都有解析和序列化JSON的内置能力。 23.1 语法 JSON没有变量、函数或对象实例的概念。 23.2 解析与序列化 在序列化JavaScript对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为undefined的任何属性也会被跳过。最终得到的就是所有实例属性均为有效JSON数据类型的表示。 24.1 XMLHttpRequest对象 发送GET请求最常见的一个错误是查询字符串格式不对。查询字符串中的每个名和值都必须使用encodeURIComponent()编码，所有名&#x2F;值对必须以和号（&amp;）分隔 XHR模拟表单提交。为此，第一步需要把Content-Type头部设置为”application&#x2F;x-www-formurlencoded”，这是提交表单时使用的内容类型。 现代Web应用程序中经常需要对表单数据进行序列化，因此XMLHttpRequest Level 2新增了FormData类型。FormData类型便于表单序列化，也便于创建与表单类似格式的数据然后通过XHR发送。 24.2 进度事件 Progress Events是W3C的工作草案，定义了客户端-服务器端通信。 24.3 跨源资源共享 最好在访问本地资源时使用相对URL，在访问远程资源时使用绝对URL。 默认情况下，跨源请求不提供凭据（cookie、HTTP认证和客户端SSL证书）。可以通过将withCredentials属性设置为true来表明请求会发送凭据。 24.4 替代性跨源技术 这种动态创建图片的技术经常用于图片探测（image pings）。图片探测是与服务器之间简单、跨域、单向的通信。 图片探测频繁用于跟踪用户在页面上的点击操作或动态显示广告。当然，图片探测的缺点是只能发送GET请求和无法获取服务器响应的内容。这也是只能利用图片探测实现浏览器与服务器单向通信的原因。 JSONP格式包含两个部分：回调和数据。 24.5 Fetch API 系统级网络协议已经成功完成消息的一次往返传输。至于真正的“成功”请求，则需要在处理响应时再定义。 因为服务器没有响应而导致浏览器超时，这样真正的fetch()失败会导致期约被拒绝 Headers对象是所有外发请求和入站响应头部的容器。 Headers对象与Map对象极为相似。这是合理的，因为HTTP头部本质上是序列化后的键&#x2F;值对，它们的JavaScript表示则是中间接口。 顾名思义，Request对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式。 24.6 Beacon API unload事件对浏览器意味着没有理由再发送任何结果未知的网络请求（因为页面都要被销毁了） 24.7 Web Socket 客户端与服务器之间可以发送非常少的数据，不会对HTTP造成任何负担。使用更小的数据包让Web Socket非常适合带宽和延迟问题比较明显的移动应用。 25.1 cookie 所有名和值都是URL编码的，因此必须使用decodeURIComponent()解码。 为绕过浏览器对每个域cookie数的限制，有些开发者提出了子cookie的概念。子cookie是在单个cookie存储的小块数据，本质上是使用cookie的值在单个cookie中存储多个名&#x2F;值对。 25.2 Web Storage Web Storage的第2版定义了两个对象：localStorage和sessionStorage。localStorage是永久存储机制，sessionStorage是跨会话的存储机制。这两种浏览器存储API提供了在浏览器中不受页面刷新影响而存储数据的两种方式。 26.1 理解模块模式 模块系统的核心是管理依赖。 26.3 使用ES6之前的模块加载器 为了统一CommonJS和AMD生态系统，通用模块定义（UMD, Universal Module Definition）规范应运而生。UMD可用于创建这两个系统都可以使用的模块代码。 第27章 工作者线程 工作者线程的价值所在：允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型。 27.1 工作者线程简介 JavaScript环境实际上是运行在托管操作系统中的虚拟环境。在浏览器中每打开一个页面，就会分配一个它自己的环境。 使用工作者线程，浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境。这个子环境不能与依赖单线程交互的API（如DOM）互操作，但可以与父环境并行执行代码。 工作者线程是以实际线程实现的。 工作者线程并行执行。 工作者线程可以共享某些内存 Web工作者线程规范中定义了三种主要的工作者线程：专用工作者线程、共享工作者线程和服务工作者线程。现代浏览器都支持这些工作者线程。 27.2 专用工作者线程 支持传统多线程模型的语言中，可以使用锁、互斥量，以及volatile变量。在JavaScript中，有三种在上下文间转移信息的方式：结构化克隆算法（structured clone algorithm）、可转移对象（transferable objects）和共享数组缓冲区（shared array buffers）。 始终保持固定数量的线程活动，需要时就把任务分派给它们。 27.5 小结 工作者线程可以是专用线程、共享线程。专用线程只能由一个页面使用，而共享线程则可以由同源的任意页面共享。 服务工作者线程用于让网页模拟原生应用程序。服务工作者线程也是一种工作者线程，但它们更像是网络代理，而非独立的浏览器线程。 28.1 可维护性 JavaScript并不强迫开发者把任何东西都定义为对象。它支持任何编程风格，包括传统的面向对象编程、声明式编程，以及函数式编程。 最好的方法是永远不要修改不属于你的对象。只有你自己创建的才是你的对象，包括自定义类型和对象字面量。 28.2 性能 只要函数中有引用超过两次的全局对象，就应该把这个对象保存为一个局部变量。 达夫设备的基本思路是以8的倍数作为迭代次数从而将循环展开为一系列语句。 求模、逻辑AND与和逻辑OR或都很适合替代成位操作。 A.5 数组打平方法 CMAScript 2019在Array.prototype上增加了两个方法：flat()和flatMap()。这两个方法为打平数组提供了便利。如果没有这两个方法，则打平数组就要使用迭代或递归。 A.6 Object.fromEntries() ECMAScript 2019又给Object类添加了一个静态方法fromEntries()，用于通过键&#x2F;值对数组的集合构建对象。这个方法执行与Object.entries()方法相反的操作。 这个方法可以方便地将Map实例转换为Object实例，因为Map迭代器返回的结果与fromEntries()的参数恰好匹配 B.6 类与模块 TC39委员会决定在ES6类和模块中定义的所有代码默认都处于严格模式。","categories":[{"name":"js","slug":"js","permalink":"https://screw-hand.com/categories/js/"}],"tags":[{"name":"js 读书笔记","slug":"js-读书笔记","permalink":"https://screw-hand.com/tags/js-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"webpack5","slug":"webpack5","date":"2022-03-12T14:20:48.000Z","updated":"2024-03-17T09:23:23.108Z","comments":true,"path":"/post/webpack5/","link":"","permalink":"https://screw-hand.com/post/webpack5/","excerpt":"简介：本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。","text":"简介：本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。 base entry 入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 output 输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 loaders 模块转换器，用于把模块原内容按照需求转换成新内容。 plugins 扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 mode 告知 webpack 使用相应模式的内置优化。 module 模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 resolve 配置webpack对模块的解析规则 externals 指定模块为外包模块，构建时不打包 bundle 由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本。 chunk 通常 chunk 会直接对应所输出的 bundle，但是有一些配置并不会产生一对一的关系。bundle 由 chunk 组成，其中有几种类型（例如，入口 chunk(entry chunk) 和子 chunk(child chunk)）。 vendors 第三方模块。 常见配置module.exports = &#123; mode: \"production\", // \"production\" | \"development\" | \"none\" // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: \"./app/entry\", // string | object | array // 默认为 ./src // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path:path.resolve(__dirname, \"dist\"), // string (default) // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"[name].js\", // string (default) // entry chunk 的文件名模板 publicPath: \"/assets/\", // string // 输出解析文件的目录，url 相对于 HTML 页面 library: &#123; // 这里有一种旧的语法形式可以使用（点击显示） type: \"umd\", // 通用模块定义 // the type of the exported library name: \"MyLibrary\", // string | string[] // the name of the exported library /* Advanced output.library configuration (click to show) */ &#125;, uniqueName: \"my-application\", // (defaults to package.json \"name\") // unique name for this build to avoid conflicts with other builds in the same HTML name: \"my-config\", // name of the configuration, shown in output /* 高级输出配置（点击显示） */ /* Expert output configuration 1 (on own risk) */ /* Expert output configuration 2 (on own risk) */ &#125;, module: &#123; // 模块配置相关 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; // Conditions: test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // these are matching conditions, each accepting a regular expression or string // test and include have the same behavior, both must be matched // exclude must not be matched (takes preferrence over test and include) // Best practices: // - Use RegExp only in test and for filename matching // - Use arrays of absolute paths in include and exclude to match the full path // - Try to avoid exclude and prefer include // Each condition can also receive an object with \"and\", \"or\" or \"not\" properties // which are an array of conditions. issuer: /\\.css$/, issuer: path.resolve(__dirname, \"app\"), issuer: &#123; and: [ /\\.css$/, path.resolve(__dirname, \"app\") ] &#125;, issuer: &#123; or: [ /\\.css$/, path.resolve(__dirname, \"app\") ] &#125;, issuer: &#123; not: [ /\\.css$/ ] &#125;, issuer: [ /\\.css$/, path.resolve(__dirname, \"app\") ], // like \"or\" // conditions for the issuer (the origin of the import) /* Advanced conditions (click to show) */ // Actions: loader: \"babel-loader\", // 应该应用的 loader，它相对上下文解析 options: &#123; presets: [\"es2015\"] &#125;, // options for the loader use: [ // apply multiple loaders and options instead \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; // ... &#125; &#125; ], type: \"javascript/auto\", // specifies the module type /* Advanced actions (click to show) */ &#125;, &#123; oneOf: [ // ... (rules) ] // only use one of these nested rules &#125;, &#123; // ... (conditions) rules: [ // ... (rules) ] // use all of these nested rules (combine with conditions to be useful) &#125;, ], /* 高级模块配置（点击展示） */ &#125;, resolve: &#123; // options for resolving module requests // (does not apply to resolving of loaders) modules: [\"node_modules\",path.resolve(__dirname, \"app\")], // directories where to look for modules (in order) extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 使用的扩展名 alias: &#123; // a list of module name aliases // aliases are imported relative to the current context \"module\": \"new-module\", // 别名：\"module\" -> \"new-module\" 和 \"module/path/file\" -> \"new-module/path/file\" \"only-module$\": \"new-module\", // 别名 \"only-module\" -> \"new-module\"，但不匹配 \"only-module/path/file\" -> \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // alias \"module\" -> \"./app/third/module.js\" and \"module/file\" results in error \"module\": path.resolve(__dirname, \"app/third\"), // alias \"module\" -> \"./app/third\" and \"module/file\" -> \"./app/third/file\" [path.resolve(__dirname, \"app/module.js\")]: path.resolve(__dirname, \"app/alternative-module.js\"), // alias \"./app/module.js\" -> \"./app/alternative-module.js\" &#125;, /* 可供选择的别名语法（点击展示） */ /* 高级解析选项（点击展示） */ /* Expert resolve configuration (click to show) */ &#125;, performance: &#123; hints: \"warning\", // 枚举 maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // enum // 通过为浏览器调试工具提供极其详细的源映射的元信息来增强调试能力， // 但会牺牲构建速度。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 都相对于此目录解析 target: \"web\", // 枚举 // the environment in which the bundle should run // changes chunk loading behavior, available external modules // and generated code style externals: [\"react\", /^@angular/], // Don't follow/bundle these modules, but request them at runtime from the environment externalsType: \"var\", // (defaults to output.library.type) // Type of externals, when not specified inline in externals externalsPresets: &#123; /* ... */ &#125;, // presets of externals ignoreWarnings: [/warning/], stats: \"errors-only\", stats: &#123; // lets you precisely control what bundle information gets displayed preset: \"errors-only\", // A stats preset /* Advanced global settings (click to show) */ env: true, // include value of --env in the output outputPath: true, // include absolute output path in the output publicPath: true, // include public path in the output assets: true, // show list of assets in output /* Advanced assets settings (click to show) */ entrypoints: true, // show entrypoints list chunkGroups: true, // show named chunk group list /* Advanced chunk group settings (click to show) */ chunks: true, // show list of chunks in output /* Advanced chunk group settings (click to show) */ modules: true, // show list of modules in output /* Advanced module settings (click to show) */ /* Expert module settings (click to show) */ /* Advanced optimization settings (click to show) */ children: true, // show stats for child compilations logging: true, // show logging in output loggingDebug: /webpack/, // show debug type logging for some loggers loggingTrace: true, // show stack traces for warnings and errors in logging output warnings: true, // show warnings errors: true, // show errors errorDetails: true, // show details for errors errorStack: true, // show internal stack trace for errors moduleTrace: true, // show module trace for errors // (why was causing module referenced) builtAt: true, // show timestamp in summary errorsCount: true, // show errors count in summary warningsCount: true, // show warnings count in summary timings: true, // show build timing in summary version: true, // show webpack version in summary hash: true, // show build hash in summary &#125;, devServer: &#123; proxy: &#123; // proxy URLs to backend development server '/api': 'http://localhost:3000' &#125;, static: path.join(__dirname, 'public'), // boolean | string | array | object, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority // ... &#125;, experiments: &#123; asyncWebAssembly: true, // WebAssembly as async module (Proposal) syncWebAssembly: true, // WebAssembly as sync module (deprecated) outputModule: true, // Allow to output ESM topLevelAwait: true, // Allow to use await on module evaluation (Proposal) &#125;, plugins: [ // ... ], // list of additional plugins optimization: &#123; chunkIds: \"size\", // method of generating ids for chunks moduleIds: \"size\", // method of generating ids for modules mangleExports: \"size\", // rename export names to shorter names minimize: true, // minimize the output files minimizer: [new CssMinimizer(), \"...\"], // minimizers to use for the output files /* Advanced optimizations (click to show) */ splitChunks: &#123; cacheGroups: &#123; \"my-name\": &#123; // define groups of modules with specific // caching behavior test: /\\.sass$/, type: \"css/mini-extract\", /* Advanced selectors (click to show) */ /* Advanced effects (click to show) */ &#125; &#125;, fallbackCacheGroup: &#123; /* Advanced (click to show) */ &#125; /* Advanced selectors (click to show) */ /* Advanced effects (click to show) */ /* Expert settings (click to show) */ &#125; &#125;, /* 高级配置（点击展示） */ /* Advanced caching configuration (click to show) */ /* Advanced build configuration (click to show) */ &#125; 配置速览 基本功能webpack：webpack核心功能 webpack-cli：webpack命令行包，提供命令行的方式调用 webpack-dev-server： webpack开发服务，提供开发周期的服务 初始化项目以上三个包强烈建议全部安装 mkdir 005-webpack-init npm init -y npm i -D webpack webpack-cli webpack-dev-server # 安装html-webpack-plugin管理html npm i -D html-webpack-plugin npm set-script build \"webpack --mode=production --node-env=production\" npm set-script serve \"webpack serve\" npm set-script watch \"webpack --watch\" src&#x2F;index.html - 被html-webpack-plugin所引用为模板，编译后自动引入src&#x2F;index.js脚本 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;h1>Hello world!&lt;/h1> &lt;/body> &lt;/html> src&#x2F;index.js - 指定为 webpack的入口模块，将从这个模块开始便利依赖树 console.log('hello world') webpack.config.js - webpack的配置文件 const path = require('path') const HtmlWebpackPlugin = require('html-webpack-plugin') const config = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name]@[contenthash].js', chunkFilename: '[name]@[contenthash].async.js' &#125;, devServer: &#123; open: false, host: '0.0.0.0', client: &#123; overlay: true &#125; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), ] &#125; module.exports = config 使用 # 编译代码 npm run build # 监听代码变化并自动编译 npm run watch # 启动开发服务 http:&#x2F;&#x2F;lcoalhost:8080 npm run serve build：编译后的源码在dist目录，可以直接在浏览器打开dist&#x2F;index.html以查看编译后的代码（建议每次build之前手动清空dist目录） watch：相当于自动完成build动作，其他同build serve：启动一个本地的开发服务，编译的代码默认不输出在dist，存储在内存中 loader心得原则：webpack默认只能识别js模块，如果入口模块的依赖树有对其他模块（样式&#x2F;html&#x2F;图片）等依赖，需要配置相应的模块规则，匹配对应的文件，使用需要的loader。 使用babel转义js 添加核心编译器&#x2F;库 （babel&#x2F;typescript） npm install -D @babel&#x2F;core @babel&#x2F;preset-env webpack 添加webpack的loader（babel-loader&#x2F; ts-loader） npm install -D babel-loader 配置编译器（.babelrc、tsconfig.json） &#123; \"plugins\": [\"@babel/transform-runtime\"], \"presets\": [ [\"@babel/react\"], [ \"@babel/env\", &#123; \"modules\": false &#125; ] ] &#125; 配置webpack的模块解析规则（webpack.config.js） module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125; &#125; ] &#125; 总结：ES6+ &#x2F; TypeScript &#x2F; Flow &#x2F; Scss Sass &#x2F; Less &#x2F; Styl &#x2F; Rect &#x2F; Vue &#x2F; Angular 的模块解析基本按照以上原则。 js&#x2F;ts脚本分别只需要babel-loader 还有ts-loader，而一般样式模块（Scss Sass &#x2F; Less &#x2F; Styl ）需要使用多个loader，loader的执行顺序是从右到左。 最简单的解析样式module: &#123; rules: [ &#123; // 用正则去匹配要用该 loader 转换的 CSS 文件 test: /\\.css$/, use: ['style-loader', 'css-loader'], &#125; ] &#125; npm install -D style-loader css-loader css-loader用于解析css模块，style-loader把解析的css模块插入到html的style标签中。 解析css预处理语言并使用postcss插件 css预处理语言需要对应的预处理语言核心、loader（styl、styl-loader) *如果需要增强样式功能，可以使用postcss以及其loader（postcss、post-loader）(可选) 此刻预处理语言被转换为css，同样需要使用css-loader解析 使用style-loader插入html成为内联样式 npm install -D styl styl-loader postcss postcss-loader css-loader style-loader module: &#123; rules: [ &#123; test: /\\.styl$/, use: ['style-loader', 'css-loader', 'postcss-loader', 'stylus-loader'], &#125; ] &#125; 分离样式文件默认情况下，webpack将样式内容耦合在js中，然后使用style-loader使样式内容插入html成为内联样式，如果需要使样式文件单独分离出来，webpack5内置了插件——mini-css-extract-plugin，可以分离出独立的样式文件。只需要把style-loader替换成mini-css-extract-plugin的loader，配置插件即可。 const MiniCssExtractPlugin = require('mini-css-extract-plugin') const config = &#123; // ... module: &#123; rules: [ &#123; test: /\\.styl$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'stylus-loader'], &#125; ] &#125;， plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name]@[contenthash].css', chunkFilename: '[name]@[contenthash].async.css' &#125;) ] &#125; css模块化css-loader提供了选项，可配置使得支持css模块化。 module: &#123; rules: [ &#123; test: /\\.styl$/, use: [ /* stylesHandler, */ &#123; loader: MiniCssExtractPlugin.loader &#125;, &#123; loader: 'css-loader', options: &#123; sourceMap: true, modules: &#123; mode: 'local', localIdentName: '[path][name]__[local]--[hash:base64:5]' &#125; &#125; &#125;, 'postcss-loader', 'stylus-loader' ] &#125; ] &#125; 静态资源对于一些静态资源（字体、图片等）可以使用以下loader处理 url-loader 将一个文件作为一个数据URI内联到bundle中（图片） file-loader 将文件发送到输出目录（字体） raw-loader 以字符串形式导入文件（其他文件，不常用） webpack - loaders HTML管理实现MPAwebpack默认不创建html文件，html-webpack-plugin可以用来管理html，自动引入entry的编译后的js、以及分离样式文件等。 实现多页面应用，必须指定多个入口模块（entry），可以多次实例化html-webpack-plugin，并配置不同的chunks选项，以指定不同的入口模块。 const config = &#123; // ... entry: &#123; app: './src/main_client.tsx', pageA: './src/multi-page/pageA.tsx', pageB: './src/multi-page/pageB.tsx' &#125;, output: &#123; filename: \"[name].js\" &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: \"src/index.html\", filename: 'app.html', chunks: ['app'] &#125;), new HtmlWebpackPlugin(&#123; template: \"src/index.html\", filename: 'pageA.html', chunks: ['pageA'] &#125;), new HtmlWebpackPlugin(&#123; template: \"src/index.html\", filename: 'pageB.html', chunks: ['pageB'] &#125;) ] // ... &#125;); 开发体验source mapwebpack把源码编译后，浏览器的开发者工具看到的代码是编译后的代码，不方便调试。 为此source-map可以将编译后的代码映射到源码，让其调试变得方便。 webpack配置文件设置devtool:&quot;source-map&quot; 也可以设置成其他的，为了构建速度，推荐 devtool: &#39;cheap-module-source-map&#39;, // recommend dev devtool: &#39;eval-source-map&#39; // product webpack - devtool devtool:&quot;source-map&quot;只是第一步，调试不同模块的源码，还需在相应loader进行配置，具体还需查阅相关的loader文档。 typescript tsconfig.json compilerOptions.sourceMap: true开启 样式 css-loader options.sourceMap:true webpack的devtool默认设置的是JavaScript source-map-loader 可从现有的source-map文件提取出相应的映射文件。 模块热替换(Hot Module Replacement)live reload：源代码更新，webpack-dev-server自动构建并刷新web HMR：live reload的升级版，可在web不刷新的情况下更新web内容 webpack-dev-server v4.0.0 默认启动HMR 以上仅在开发环境下有效。 entry入口文件结尾追加以下内容（必须） if (process.env.NODE_ENV === 'development' &amp;&amp; module.hot) &#123; module.hot.accept() &#125; 检查代码安装相应的lint，合理地配置lint规则， 使用webpack-[lint]-plugin即可。 在webpack中检查代码会使构建速度变慢 终端会打印lint规则的信息（错误&#x2F;警告） 定位并不一定在源码的行数 建议使用集成代码检查的编辑器 把代码检测步骤放到代码提交之前 优化策略限制webpack处理模块范围 loader include &#x2F; exclude (优先级更高) resolve.modules 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 resolve.mainFields（配置第三方模块使用哪个入口文件，对应package.json的字段) resolve.alias 常用的库可以硬性配置 resolve.extensions 长度减少，更常用的先放在前面 module.noParse 非模块化实现的库可以配置不解析，并使用script标签引入 IgnorePlugin 忽略指定模块的生成，一些体积比较大的库只需要使用部分可以排除掉 提取公共代码痛点 相同的资源被重复的加载，浪费用户的流量和服务器的成本； 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。 optimization.SplitChunks，适用于SPA、MPA，SPA的效果并不是很明显。 效果 减少网络传输流量，降低服务器成本； 虽然用户第一次打开网站的速度得不到优化，但之后访问其它页面的速度将大大提升。 代码分割按需加载&#x2F;异步加载&#x2F;预加载 import() import(/* webpackChunkName: \"chunk_script\" */ '../src/script.js').then(() => &#123; console.log('1') &#125;) 压缩代码webpack v4+在生产模式下默认使用terser-webpack-plugin压缩代码，也可以使用closure-webpack-plugin压缩，结合optimization.minimizer一起使用。 dll (well？)cdn加速output.publicPath: &#39;&#x2F;&#x2F;js.cdn.com&#x2F;id&#x2F;&#39; new MiniCssExtractPlugin(&#123; filename: &#39;style&#x2F;[name]_[hash].css&#39;, chunkFilename: &#39;style&#x2F;[id]_[hash].css&#39;, pubicPath: &#39;&#x2F;&#x2F;css.cdn.com&#x2F;id&#x2F;&#39; &#125;) Tree Shaking基于ES2015的模块化实现（import、export），因为ES2015的模态化是静态机制的，所以webpack在构建的时候，能剔除一些引入但未被使用的代码。webpack内置功能。 输出分析原理编译后的代码 异步模块 热更新 loader plugin 生态圈 webpack webpack-cli webpack-dev-server webpack-dev-middleware webpack-merge webpack-chain loader https://webpack.js.org/loaders/ plugin https://webpack.js.org/plugins/ 命令行 https://webpack.js.org/api/cli/ npm包 https://www.npmjs.com/search?q=keywords:webpack github https://github.com/webpack 版本差异v3~v4 Release v4.0.0 · webpack v4~v5 2020-10-10-webpack-5-release 使用持久化缓存提高构建性能； 使用更好的算法和默认值改进长期缓存（long-term caching）； 清理内部结构而不引入任何破坏性的变化； 引入一些breaking changes，以便尽可能长的使用v5版本。 其他构建工具 grunt gulp vite esbuild rollup 参考资料深入浅出 Webpack Node.js+Webpack开发实战-夏磊 Webpack实战：入门、进阶与调优","categories":[{"name":"工程化","slug":"工程化","permalink":"https://screw-hand.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://screw-hand.com/tags/webpack/"}]},{"title":"代码规范整改的项目实践","slug":"code-style","date":"2021-12-27T09:10:18.000Z","updated":"2024-03-17T09:23:22.984Z","comments":true,"path":"/post/code-style/","link":"","permalink":"https://screw-hand.com/post/code-style/","excerpt":"背景 痛点: 项目的代码写得太乱了，风格不统一。团队成员的编辑器格式化设置也不一样，经常在提交记录出现大量的格式化代码风格修改，影响日志追溯。 动机：npm script(prettier)似乎不起作用，虽然有 git hooks，项目也没有安装 eslint，也缺少 stylelint。 预期：团队统一代码风格，统一设置好编辑器，安装必要的编辑器插件，尽量用工具去自动整理代码 原则：让工具去管理规范，配置好相应的工具就行，让开发者少操心格式问题，把精力多放点在代码的实现 结果：预期想法基本满足。","text":"背景 痛点: 项目的代码写得太乱了，风格不统一。团队成员的编辑器格式化设置也不一样，经常在提交记录出现大量的格式化代码风格修改，影响日志追溯。 动机：npm script(prettier)似乎不起作用，虽然有 git hooks，项目也没有安装 eslint，也缺少 stylelint。 预期：团队统一代码风格，统一设置好编辑器，安装必要的编辑器插件，尽量用工具去自动整理代码 原则：让工具去管理规范，配置好相应的工具就行，让开发者少操心格式问题，把精力多放点在代码的实现 结果：预期想法基本满足。 工具的共性 node 包管理器安装依赖工具 创建对应的配置文件 编写 npm script 以便携使用 下载扩展，设置对应的配置项以集成编辑器 git hooks 配置文件类型 1、2 是为了基本的正常使用； 3 是方便团队成员正确地使用工具； 4 是在编写代码的过程，能即使获得工具的检测反馈，以及在配置文件中拥有一定的代码提示，也能提供相应的编辑器命令以完成快捷操作。 5 是为了保证提交的代码格式都是正常的，团队成员的本地代码，随便折腾。这是最后的底线。 这是一个基于umijs构建的项目，有些工具已经配置好的，检查已有的，补充需要的工具即可。 准备工作 本文并不想讨论代码规范、代码风格、代码格式等术语之间的区别的联系，这仅仅是一次“一站式自动整理代码”的实践而已。 clone 另一份项目代码 检出新的 git 分支 备份 vscode 设置 vscode 禁用插件，还原用户设置 新增编辑器项目级别的配置文件 mkdir .vscode # 新建vscdoe的项目文件 touch .vscode/settings.json # 此处用了一条关于vscode的命令行，指定扩展存储目录，以隔离之前下载的扩展 code . --extensions-dir .vscode/ext 下列所有关于编辑器的设置全部都是项目级别的设置，建议直接编辑.vscode/settings.json文件以配置。 EditorConfigEditorConfig 是最简单的，项目根路径下编写配置文件.editorconfig，安装插件即可——EditorConfig for VS Code。 # http:&#x2F;&#x2F;editorconfig.org root &#x3D; true [*] indent_style &#x3D; space indent_size &#x3D; 2 end_of_line &#x3D; lf charset &#x3D; utf-8 trim_trailing_whitespace &#x3D; true insert_final_newline &#x3D; true [*.md] trim_trailing_whitespace &#x3D; false [Makefile] indent_style &#x3D; tab prettier安装npm install --save-dev prettier 配置文件.prettierrc &#123; \"semi\": true, \"singleQuote\": true, \"jsxSingleQuote\": true, \"trailingComma\": \"all\", \"printWidth\": 80, \"bracketSameLine\": true, \"overrides\": [ &#123; \"files\": \".prettierrc\", \"options\": &#123; \"parser\": \"json\" &#125; &#125; ] &#125; npm scriptpackage.json &#123; ... \"scripts\": &#123; \"prettier\": \"prettier --write **/*.&#123;js,jsx,tsx,ts,css,less,md,json&#125;\", \"prettier:check\": \"prettier --check **/*.&#123;js,jsx,tsx,ts,css,less,md,json&#125;\", &#125; &#125; 两条npm script分别是使用prettier格式化代码（改动文件），以及使用 prettier 检测代码（不改动文件）。 不建议立即将格式化后的代码马上提交到 git，若有改动，应丢弃更改。待到配置完所有的工具后，合并回到主要的分支后，在主要的分支执行此脚本，提交后，再通知团队成员拉取最新代码，以避免无妄之灾的合并冲突。 让 CI&#x2F;CD 去执行脚本也行。 编辑器集成安装 vscode 的 prettier 插件，Prettier - Code formatter，并检查。 格式化代码：使用编辑器命令（F1 &#x2F; Ctrl + Shift + p)，输入Format Document或者使用快捷键(Alt + Shift + F)。安装完插件后第一次格式化，编辑器会因为有多种格式化方案（编辑器内置、prettier 共两种）而让用户配置默认的方案。需要选择prettier。代码正确格式化时，会在上图的OUTPUT &gt; Prettier 打印日志。 刚才的那个默认配置，会让编辑器自动在用户的配置添加默认格式化，编辑器命令Preferences: Open Settings(JSON)以检查，将&quot;editor.defaultFormatter&quot;相关的删除。（工具没配置好前，不要改变用户级别的配置！！） \"[typescriptreact]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125; 如果配置的话，应该在.vscode/settings.json中配置。 \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" 格式化时也可使用编辑器命令Format Document With...指定编辑器使用何种方式格式化。 eslintprettier与eslint联系与区别。 eslint prettier 文件 检测 js 语法，针对的是 js(x),ts(x)的文件。（非 js(x),ts(x)的文件，eslint 也是能检测的，只是这完全是愚蠢的做法） 除了能前者，还支持 html&#x2F;xml&#x2F;Vue&#x2F;Angular、css&#x2F;less&#x2F;scss&#x2F;、Markdown 等一系列文件。 定位 格式化与代码质量检测 只格式化代码，无代码质量检测能力 生态 很多规则，很多插件、扩展…… 少量的规则，极少的插件和扩展 不管怎么看，eslint 除了兼容文件这一块，似乎都完爆 prettier。那么我们为什么还需要 prettier 呢？ 事实上，eslint 比 prettier 还早出现，问题在于，eslint 关于格式化的规则太多了，开发者都在吵到底应该怎么配置格式化的规则。这在我看来完全是被工具给限制住了。后来就 prettier 就站出来：你们别吵了，我这边就提供这些关于格式化的配置给你们，你们就这么配置就行了， eslint 也继续用。 现在更多的是流行prettier组合eslint一起使用，前者负责代码格式化，后者负责质量检测，互不打扰。 Prettier vs. Linters · Prettier 事实上 prettier 跟 eslint 结合使用会有一小部分冲突的，但是这也是能通过安装扩展、配置去解决。 基本使用# 安装 npm install eslint --save-dev # 初始化eslint，根据实际情况选择 ./node_modules/.bin/eslint --init ? How would you like to use ESLint? ... To check syntax only > To check syntax and find problems To check syntax, find problems, and enforce code style ? What type of modules does your project use? ... > JavaScript modules (import/export) CommonJS (require/exports) None of these ? Which framework does your project use? ... > React Vue.js None of these ? Does your project use TypeScript? » No / Yes √ ? Where does your code run? ... (Press &lt;space> to select, &lt;a> to toggle all, &lt;i> to invert selection) √ Browser √ √ Node ? What format do you want your config file to be in? ... JavaScript YAML > JSON Local ESLint installation not found. The config that you've selected requires the following dependencies: # eslint的初始化脚本根据刚才用户的选择，将采用下列依赖包 # 选择Yes，将会安装，并自动生成配置文件，选择No——白给 eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest eslint@latest ? Would you like to install them now with npm? » No / Yes √ 结合 prettier先别急着使用 eslint，使用之前还需要 eslint 结合 prettier——禁用 eslint 中关于代码格式的规则，让 prettier 去接管即可——eslint-config-prettier npm install --save-dev eslint-config-prettier 更新 eslint 配置。 &#123; \"extends\": [\"some-other-config-you-use\", \"prettier\"] &#125; 目前为止.eslintrc.json长这样，rules是针对项目的情况，暂时屏蔽错误才加的。 &#123; \"env\": &#123; \"browser\": true, \"es2021\": true &#125;, \"extends\": [ \"eslint:recommended\", \"plugin:react/recommended\", \"plugin:@typescript-eslint/recommended\", \"prettier\" ], \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": &#123; \"ecmaFeatures\": &#123; \"jsx\": true &#125;, \"ecmaVersion\": 2021, \"sourceType\": \"module\" &#125;, \"plugins\": [\"react\", \"@typescript-eslint\"], \"rules\": &#123; \"react/react-in-jsx-scope\": 0, \"react/jsx-uses-react\": 0, \"@typescript-eslint/no-explicit-any\": 0, \"@typescript-eslint/no-unused-vars\": 0, \"@typescript-eslint/ban-types\": 0, \"no-control-regex\": 0, \"@typescript-eslint/ban-ts-comment\": 0, \"no-empty\": 0, \"no-prototype-builtins\": 0, \"@typescript-eslint/no-empty-function\": 0, \"prefer-const\": 0, \"react/display-name\": 0, \"@typescript-eslint/no-non-null-asserted-optional-chain\": 0, \"@typescript-eslint/no-non-null-assertion\": 0, \"react/prop-types\": 0, \"no-empty-pattern\": 0, \"no-fallthrough\": 0, \"react/no-children-prop\": 0, \"no-unsafe-optional-chaining\": 0, \"react/jsx-key\": 0 &#125; &#125; .eslintignore忽略掉一些不需要格式化的目录。 .vscode dist build node_modules 配置文件中的extends、plugins字段Plugins——针对解析器的相关的，配置解析器以解析不同文件。 extends——继承指定配置文件的所有特性（规则、插件、语言选项）。 配置推荐eslint-config 插件推荐eslint-plugin npm script&#123; \"scripts\": &#123; \"lint\": \"eslint --fix **/*.&#123;js,jsx,ts,tsx&#125;\", \"lint:check\": \"eslint **/*.&#123;js,jsx,ts,tsx&#125;\" &#125; &#125; 集成编辑器安装ESLint，如果有这个弹窗，选“Allow”即可。 &#123; // 始终在状态栏显示eslint状态 \"eslint.alwaysShowStatus\": true, // 启用eslint格式化 \"eslint.format.enable\": true, // 编辑器默认格式化方案 \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", // 指定语言默认格式化方案 \"[javascript]\": &#123; \"editor.defaultFormatter\": \"dbaeumer.vscode-eslint\" &#125;, \"[javascriptreact]\": &#123; \"editor.defaultFormatter\": \"dbaeumer.vscode-eslint\" &#125;, \"[typescript]\": &#123; \"editor.defaultFormatter\": \"dbaeumer.vscode-eslint\" &#125;, \"[typescriptreact]\": &#123; \"editor.defaultFormatter\": \"dbaeumer.vscode-eslint\" &#125;, // eslint格式化修复错误 \"eslint.codeActionsOnSave.mode\": \"all\" // 保存时自动修复错误， 不建议 // \"editor.codeActionsOnSave\": &#123; // \"source.fixAll.eslint\": true // \"source.fixAll.stylelint\": true // &#125;, &#125; 因为eslint只支持js(x)|ts(x)，所以这里针对这几种语言做定制化，默认还是得使用prettier。 Stylelint“脚本家族”——js(x)|ts(x)有 eslint，“样式家族”——css/less/sass/scss/SugarSS等就由stylelint去保证代码质量，代码格式仍然是由prettier去接管。（也可以选择不结合使用 prettier）同样是需要安装，配置，然后使用合适的工具。 stylelint postcss-less &#x2F;&#x2F; less预处理语言语法 stylelint-config-standard &#x2F;&#x2F; 标准配置 stylelint-config-css-modules &#x2F;&#x2F; css-modules相关规则 stylelint-config-rational-order &#x2F;&#x2F; css规则排序 stylelint-config-prettier &#x2F;&#x2F; 结合prettier stylelint-config-prettier是一个命令行工具，可以检测stylelint跟prettier的配置是否存在冲突。 npm i -D stylelint postcss-less stylelint-config-standard stylelint-config-css-modules stylelint-config-rational-order stylelint-config-prettier 配置文件 .stylelintrc.json &#123; \"extends\": [ \"stylelint-config-standard\", \"stylelint-config-rational-order\", \"stylelint-config-css-modules\", \"stylelint-config-prettier\" ], \"customSyntax\": \"postcss-less\", \"rules\": &#123; \"selector-class-pattern\": null, \"no-descending-specificity\": null, \"max-line-length\": null, \"function-url-quotes\": null, \"font-family-no-duplicate-names\": null, \"declaration-block-no-redundant-longhand-properties\": null, \"font-family-no-missing-generic-family-keyword\": null, \"declaration-block-no-duplicate-properties\": null, \"font-family-name-quotes\": null, \"property-no-unknown\": null, \"no-duplicate-selectors\": null, \"keyframes-name-pattern\": null, \"color-function-notation\": \"modern\", \"color-hex-alpha\": \"never\", \"block-closing-brace-empty-line-before\": [ \"never\", &#123; \"except\": [\"after-closing-brace\"] &#125; ] &#125; &#125; npm script &#123; \"scripts\": &#123; \"stylelint-check\": \"stylelint-config-prettier-check\", \"stylelint\": \"stylelint --fix **/*.&#123;css,less&#125;\", \"stylelint:check\": \"stylelint **/*.&#123;css,less&#125;\" &#125; &#125; npm run stylelint-check，先检测一下配置是否存在冲突。 $ npm run stylelint-check > @ stylelint-check D:\\source_code\\hs-npm > stylelint-config-prettier-check Conflicting rule(s) detected in your stylelint configuration: block-closing-brace-empty-line-before npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! @ stylelint-check: `stylelint-config-prettier-check` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the @ stylelint-check script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. 这里stylelint的 block-closing-brace-empty-line 跟prettier的规则冲突了，从配置中删除即可。 $ npm run stylelint-check > @ stylelint-check D:\\source_code\\hs-npm > stylelint-config-prettier-check No conflicting rules detected in your stylelint configuration! 编辑器的集成同样是安装相应的插件Stylelint，插件的配置，只需要设置默认格式化方案即可。如果想手动修复错误，可使用编辑器命令stylelint.executeAutofix（针对当前文件，一次性修复）。 &#123; \"[css]\": &#123; \"editor.defaultFormatter\": \"stylelint.vscode-stylelint\" &#125;, \"[less]\": &#123; \"editor.defaultFormatter\": \"stylelint.vscode-stylelint\" &#125; &#125; PostCSS plugin rules plugins 自动整理代码应该在格式化时修复错误还是保存时自动格式化？? 最佳体验是格式化时修复错误，通过Formatting Toggle切换保存是否格式化。 在禁用保存时自定格式化的时候，也可以选择手动格式化修复错误。 Formatting Toggle需要设置editor.defaultFormatter配置，否则不生效！ 手动格式化推荐使用Format Document With...命令。（起码自己知道是这次操作是按照哪种格式化方案运行的。） git hooks工具经全部安装并配置完成，开发者的编辑器也有了相应的配置。这些只能保证目前还有以后，自己编写的代码规范是没问题的。团队开发中，还有其他成员的代码规范也要保证。这时候就需要使用 git hooks 才解决了，这是最后的一个把关。（或者团队成员会不配置编辑器、不装相应的扩展。但是只要有 git hooks，就一定能保证代码提交的格式没毛病。） 延续项目已经有的lint-staged、yorkie，继续配置即可。 lint-staged可以对 git 暂存的文件进行 shell 操作，在提交代码前触发。相当于我们自己手动npm run eslint/pretter/styleint一次，只不过仅作用于即将要提交的文件。相比手动运行命令行格式化工具，lint-staged的速度会更快。 Husky - Git hooks是一个git hooks库，会在代码提交的时候触发一些动作。 You can use it to lint your commit messages, run tests, lint code, etc… when you commit or push. Husky supports yorkiefork 了husky，使用更加简单。 package.json 添加相应的配置。 &#123; \"gitHooks\": &#123; \"pre-commit\": \"lint-staged\" &#125;, \"lint-staged\": &#123; \"*.&#123;js?(x),ts?(x)&#125;\": [ \"eslint --fix\", \"prettier --parser=typescript --write\" ], \"*.&#123;css,*.less&#125;\": [\"stylelint --fix\", \"prettier --write\"], \"*.&#123;md,json&#125;\": [\"prettier --write\"] &#125; &#125; 使用命令行提交代码, running pre-commit hook: lint-staged表示运行了 git hooks，使用了&#96;lint-staged，如此代码提交的时候，会自动格式化。 $ git commit -m 1 > running pre-commit hook: lint-staged [STARTED] Preparing... [SUCCESS] Preparing... [STARTED] Running tasks... [STARTED] Running tasks for *.&#123;js?(x),ts?(x)&#125; [STARTED] Running tasks for *.&#123;css,*.less&#125; [STARTED] Running tasks for *.&#123;md,json&#125; [SKIPPED] No staged files match *.&#123;css,*.less&#125; [SKIPPED] No staged files match *.&#123;md,json&#125; [STARTED] eslint --fix [SUCCESS] eslint --fix [STARTED] prettier --parser=typescript --write [SUCCESS] prettier --parser=typescript --write [SUCCESS] Running tasks for *.&#123;js?(x),ts?(x)&#125; [SUCCESS] Running tasks... [STARTED] Applying modifications... [SUCCESS] Applying modifications... [STARTED] Cleaning up... [SUCCESS] Cleaning up... [feat_1.1.8_npm be3198f] 1 2 files changed, 3 insertions(+) create mode 100644 src/a.jsx lint 和 prettier 的执行顺序？ 个人理解应处理完错误后，再来整理代码，所以这里是先lint后prettier。 行尾结束符问题（LF&#x2F;CRLF）结论，使用 LF，配置好 git 还有 prettier 的规则就行。 添加* text=auto eol=lf到.gitattributes文件。 prettier 设置endOfLine规则为&quot;lf&quot;或者干脆不设置。 v2.0.0 起默认值从auto更改为的lf。 执行prettier --write。 提交代码，然后让团队的所有(windows)成员删除代码仓库，重新 clone，以保证所有的文件都以正常更新为LF。 Options · Prettier 后续工具的配置也已经完成了， 应跟团队成员交流，并试用规则是否不太苛刻。确定都同意后，方可合并回主要的分支。并且执行相应的npm script。 npm run lint npm run stylelint npm run prettier 如果有格式问题，处理完再提交。通知其他团队成员拉取最新代码。（重新 clone 也行，“行尾结束符问题”相关有讲过。） 示例源码 未提及的 提交规范 感悟 每个项目的 lint 工具跟编辑的插件都不太一样，建议是使用 VS CodeWorkspaces特性，分别配置项目的设置、还有插件的使用状态，以提升开发体验。 规范是为了统一风格，是为了在追溯日志（git diff)、code review 的时候，能少一点关系格式的问题。 规范是一个很灵活且主观的问题，最重要的是团队的成员都能接受，工具应该是有加成效果，而不是限制所有人的枷锁。 想要获得比较省事的开发体验，前提还是要折腾编辑器和插件以及合理设置好他们的配置项。 工具去保持代码格式的下限，团队的意识形态去突破代码质量的上限。","categories":[{"name":"工程化","slug":"工程化","permalink":"https://screw-hand.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://screw-hand.com/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"使用代理解决跨域问题","slug":"cors-proxy","date":"2021-07-17T01:54:08.000Z","updated":"2024-03-17T09:23:23.000Z","comments":true,"path":"/post/cors-proxy/","link":"","permalink":"https://screw-hand.com/post/cors-proxy/","excerpt":"前言如今主流开发模式前后端分离已是普遍的开发模式，相对于传统的前后端耦合，前后端各拥有自己的一套开发环境。开发完成后，又一起部署到是测试&#x2F;线上环境。 因为后端的API服务并不部署在前端的开发环境上，所以在开发时，经常会遇到需要跨域的场景；即便是部署到测试&#x2F;线上环境，也不一定是部署到同一台服务器（单体、集群式服务）。 内容：介绍跨域、同源策略的基本概念；收跨域影响的场景；常用的跨域方案、代理；反向代理、正向代理；开发、线上环境配置代理。","text":"前言如今主流开发模式前后端分离已是普遍的开发模式，相对于传统的前后端耦合，前后端各拥有自己的一套开发环境。开发完成后，又一起部署到是测试&#x2F;线上环境。 因为后端的API服务并不部署在前端的开发环境上，所以在开发时，经常会遇到需要跨域的场景；即便是部署到测试&#x2F;线上环境，也不一定是部署到同一台服务器（单体、集群式服务）。 内容：介绍跨域、同源策略的基本概念；收跨域影响的场景；常用的跨域方案、代理；反向代理、正向代理；开发、线上环境配置代理。 跨域、同源策略我们经常遇到，跨域的问题。在讲跨域前。先来了解下同源策略吧。 同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 MDN-浏览器的同源策略 说的很长，按照个人的理解的是———— 同源策略(Same Origin Policy)，是浏览器的一个安全策略，为了网站的安全，不同源的资源无法进行交互。 解读： 只有浏览器才受到同源策略的限制 这是个安全策略，使用不当会影响网站的安全性 影响不同源的资源交互 那么再延伸一个，什么是“源”？ 如果两个 URL 的 protocol、port (en-US) (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议&#x2F;主机&#x2F;端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重&#x2F;三重&#x2F;四重&#x2F;五重&#x2F;等的通用形式）。 个人理解：协议(protocol)、域名(host)、端口(port)；三者一致，才是同源，其中一个不一样，就不是同源，会受到同源策略的限制无法交互。** 理解了同源策略，再来看跨域。 跨域(cross domain)：是一种场景，也是一种方案，跨域名(源)资源交互。 个人理解：当我们请求不同源的资源，受到同源策略的限制，这个时候说明，我们遇到了跨域的场景，也需要用到相关的跨域方案，绕过同源策略的限制。 ps：其实一直很疑惑，如果按照浏览器的同源策略命名，跨域(cross domain)应该叫做跨源(cross origin)。 常用的跨域方案、代理 JSONP CORS postMessage(iframe) websocket proxy window.name + iframe location.hash + iframe document.domain + iframe 看似方法很多，其实很多原理就两种: 绕过同源策略 —— JSONP是动态创建一个script标签发起GET请求，服务端响应一个可以供js回调使用的函即可；iframe是其标签的特性就决定本身不受同源策略的限制，可以跨资源访问，加上使用其相关的一些api，进行通讯交互；webscoket同理，也是本身可跨资源访问，连接打开双端可互相通讯；proxy，前端不直接请求目的资源，向代理服务器请求，代理服务器转发请求，转发后端api响应的数据给前端。 破解同源策略 —— CORS 直接在服务器设置HTTP相关的header，允许服务器资源可被跨域访问。 然后，在实际开发中… 很多方案能实现的机率，很少。JSONP、 iframe 需要双端配合，有时候我们用的是第三方的服务器资源，我们很难要求第三方的API配合我们开发。**websocket 更是对后端的技术选型的一个要求。**为了解决跨域，是否值得让后端使用websocket也是一种取舍。CORS是需要在服务器上设置的，如果又是第三方的资源，也是没有条件设置。 代理则是在双端之间加入代理层，转发客户端的请求，由于同源策略只是限制浏览器，代理服务器不受其影响，可以直接跨域。 根据个人的经验，代理（proxy）是可实现性最高的一种。我愿称之为代理是跨域最好、也是最后的解决方案。 反向代理、正向代理代理服务器(proxy server)是一个中介，位于客户端和目标服务器之间的一个服务器。将请求转发到目标地址，再响应目标地址的数据给客户端而已。 正向代理（forward proxy）：客户端发送请求到代理服务器，代理服务器自己再去发送请求到目标地址。这个请求其实是由代理服务器发的，代理服务器接收到目标地址的响应，再响应给客户端。服务端不知道不知道代理服务器是否为真正的客户端。 反向代理（reverse proxy）：客户端发送请求到代理服务器，代理服务器直接转发请求到目的地址。目标地址响应的数据，由代理服务器响应给客户端。客户端不知道代理服务器的存在。 配置开发环境的代理前端目标主流的vue、react项目的开发环境（web server）都是基于node使用webpack运行的，webpack的devServer.proxy支持配置正向代理，以完成跨域。但其实devServer.proxy是基于http-proxy-middleware实现的，也就是说http-proxy-middleware才真正的代理服务器，webpack只是集成了其工具，开放了一个devServer.proxy的配置入口来配置相应的功能。区别这点很重要，代理不知道怎么配置，应该查阅http-proxy-middleware的相关资料！然而vue表面看起来并不使用webpack，事实上是：vue-cli是基于webpack封装后实现的，vue.config.js可以配置相应的webpack。而react，官方的脚手架craete-react-app隐藏了webpack的配置，可以使用npm run eject暴露出webpack的配置。个人对于官方脚手架，只觉得练习demo简洁，开发生产项目更偏好于craco。而craco本意上是指Create React App Configuration Override(create-react-app配置覆盖)，所以可以理解为基于官方脚手架的封装。 vue-cli => webpack => http-proxy-middleware craco (=> craete-react-app) => webpack => http-proxy-middleware 前置准备 react项目，使用craco配置 url设计 127.0.0.1:9999&#x2F;server &#x3D;&gt; 127.0.0.1:9999&#x2F;proxy 创建文件 public&#x2F;server&#x2F;data.json &#123; \"code\":1, \"msg\":\"success\", \"data\": &#123; \"key\": \"value\"&#125; &#125; public&#x2F;server&#x2F;index.html &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;h1>Hello, World!&lt;/h1> &lt;/body> &lt;/html> 检查web服务是否能正常访问到上一步的两个资源（建议使用postman）; http://127.0.0.1:9999/server 、 http://127.0.0.1:9999/server/data.json 访问代理的url（由于还没开始设置代理，被代理url响应结果跟上面是不一致的） http://127.0.0.1:9999/proxy 、 http://127.0.0.1:9999/proxy/data.json 配置http-proxy-middleware// craco.config.js module.exports = &#123; devServer: &#123; proxy: &#123; \"/proxy\": &#123; target: \"http://localhost:9999\", changeOrigin: true, pathRewrite: &#123; \"^/proxy\": \"server\", &#125;, &#125;, &#125;, &#125;, // ... &#125;; 编写两个请求，来验证在浏览器中的表现效果。 // src/index.js const webInit = () => &#123; const path = \"/data.json\"; checkServer(path); checkProxy(path); &#125;; ​ // 检测local server const checkServer = async (path) => &#123; const serverRequest = await fetch(`//$&#123;window.location.host&#125;/server/$&#123;path&#125;`, &#123;&#125;) .then(function(response) &#123; return response.text(); &#125;) .then(function(respText) &#123; console.log(respText); &#125;); return serverRequest; &#125;; ​ // 检测代理 const checkProxy = async (path) => &#123; const proxyRequest = await fetch(`//$&#123;window.location.host&#125;/proxy/$&#123;path&#125;`, &#123;&#125;) .then(function(response) &#123; return response.text(); &#125;) .then(function(respText) &#123; console.log(respText); &#125;); return proxyRequest; &#125;; ​ webInit(); 重启项目后，在浏览器中访问，两个fetch请求的响应结果一致，即跨域成功。 生产环境项目开发完成后，我们要打包后再部署到服务器。 $ npm run build 部署到服务器后，浏览器访问生产环境的url，会发现两个fetch还是会遇到跨域问题。这是为什么呢。开发环境使用的node环境，拥有webpack和http-proxy-middleware的功能和配置；打包后只剩下静态资源文件———— *.html， *.css , *.js *.jpg/png/gif 等… 服务器上是用nginx作为HTTP web server，所以需要在nginx再配置一次代理。如果是node，就用node配置，服务器上静态资源文件被哪种HTTP web server处理，就在哪个环境配置代理。 还是以 &#x2F;server &#x3D;&gt; &#x2F;proxy 代理策略举例。 http &#123; #... server &#123; listen 9999； location /proxy/ &#123; proxy_pass http://127.0.0.1:9000/server/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_read_timeout 300s; &#125; #... &#125; #... &#125; 说到nginx，也给一下CROS的配置方案吧。 location /proxy/ &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; &#125; 结尾这次我们以跨域为讨论主题，重点放在代理上，了解了正向代理，反向代理，开发环境(http-proxy-middleware)、线上环境(nginx)的配置。代理能做的事情不仅仅是跨域，还可以实现负载均衡、匿名访问等。可是在跨域中，代理是最好的解决方案，一劳永逸。","categories":[],"tags":[]},{"title":"浏览器下载与上传文件","slug":"file","date":"2021-01-30T07:37:05.000Z","updated":"2024-03-17T09:23:23.008Z","comments":true,"path":"/post/file/","link":"","permalink":"https://screw-hand.com/post/file/","excerpt":"前言浏览器&#x2F;服务器如何生成、下载与上传文件，以及js的文件处理。","text":"前言浏览器&#x2F;服务器如何生成、下载与上传文件，以及js的文件处理。 浏览器生成文件下载一个文件前，要先确定文件是从哪里生成的，一种是由浏览器生成，另一种是服务端生成文件。生成文件之后，方可供用户下载到本地设备（计算机&#x2F;移动设备）的存储空间。 实例代码：001-file 我们先讨论浏览器的，再来讨论服务端。 接下来我们会分别用几种方式生成同一个文件——文件名为hello-world.json，内容为&#123;&quot;hello&quot;:&quot;world&quot;&#125;。 new File使用js的File对象可以创建一个文件 —— new File。 const file = new File([JSON.stringify(&#123; hello: \"world\" &#125;)], 'hello-world.json', &#123; type: 'application/json' &#125;) 这是js文件对象最容易使用的一个Web Api了，接下来介绍的都是二进制文件对象，而且这几个对象互相都有继承关系，也可互相转换。 application/json——这是Content-Type（内容类型），常用于HTTP协议，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件。 BlobBlob对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取。 const blob = new Blob([JSON.stringify(&#123; hello: \"world\" &#125;)], &#123; type: 'application/json' &#125;) 直接打印显示的是一个Blob对象而且没办法直接查看文件的内容，我们可以用Blob.text()查看，该函数返回一个Promise对象。 blob.text().then(x => console.log(x)) // &#123;\"hello\":\"world\"&#125; Data URLsData URLs，即前缀为 data: 协议的URL，其允许内容创建者向文档中嵌入小文件。 data:application/json,&#123;\"hello\":\"world\"&#125; 直接丢到浏览器的地址栏访问，即可。 Data URLs也可以表达用base64编码后的文件。 使用在线网站将“JSON转换Base64”，编码后可得eyAiaGVsbG8iOiAid29ybGQiIH0=，按照Data URL的格式组合。 data:application/json;base64,eyAiaGVsbG8iOiAid29ybGQiIH0= 其他文件到目前为止，我们分别用new File ，Blob，Data Url创建了一个JSON文件，那么如果要创建其他格式的文件呢。比如*.txt，*.html。上述的方法都有application/json的字符，也介绍过这是Content-Type，我们只需要更换相应的Content-Type类型即可，比如：用html的格式输出一级标题（h1），内容为&#123;&quot;hello&quot;:&quot;world&quot;&#125;。 data:text/html,&lt;h1>&#123;\"hello\":\"world\"&#125;&lt;/h1> 更多文字格式可以自行搜索“Content-Type 手册”。 下载文件现在来下载文件，通过浏览器生成的文件都可以通过使用a超链接标签下载，可能会疑惑为什么a标签可以下载文件，H5后，a标签多了一个donwload属性，此时浏览器会下载href指定的url表示的文件。 &lt;a href=\"data:application/json,&#123; &amp;quot;hello&amp;quot;: &amp;quot;world&amp;quot;&#125;\" download=\"hello-world.json\">data URL&lt;/a> HTML中引号需要转义，即为&amp;quot; 点击之前先对浏览器进行两个设置，一个是设置不自动保存文件，一个是设置对JSON文件的处理方式。 确保设置生效后点击刚才的超链接，将会出现这个“打开文件”的弹窗提醒，可以选择打开也可以选择保存文件。 “打开”会直接通过指定的本地程序打开，此时目录保存在操作系统的缓存目录，比如我的是C:\\Users\\Chris\\AppData\\Local\\Temp\\hello-world.json。 “下载”会使其文件保存在本地存储设备，因为刚设置了“每次都问您要存在哪”，所以会让我们选择保存目录。 刚还只是Data URL方式创建的文件下载，要知道new File还有Blob并没有直接提供url。此时我们可以使用URL.createObjectURL()，直接将new File、Blob类型转换成一个URL。这次我们不用纯HTML实现，我们将通过交互动态创建一个a元素挂载到网页上。 &lt;button id=\"new-file\">new File button&lt;/button> const newFileBtn = document.querySelector('#new-file') newFileBtn.onclick = function () &#123; // 创建文件 const file = new File([JSON.stringify(&#123; hello: \"world\" &#125;)], 'hello-world.json', &#123; type: 'application/json' &#125;) console.log(file) // 下载文件 const aLink = document.createElement('a') aLink.setAttribute('href', URL.createObjectURL(file)) aLink.setAttribute('download', file.name) document.body.append(aLink) aLink.click() document.body.removeChild(aLink) &#125; 点击之后，跟上述的功能是一样的，只是“打开文件”的弹窗显示的“来源”将会是”Blob”，因为本身new File就是继承Blob实现的。写到这里，就顺便封装成一个函数吧。 // 下载文件 function downloadFile(fileName, file) &#123; const isBlob = file instanceof Blob const href = isBlob ? URL.createObjectURL(file) : file const aLink = document.createElement('a') aLink.setAttribute('href', href) aLink.setAttribute('download', fileName) document.body.append(aLink) aLink.click() document.body.removeChild(aLink) &#125; 服务端生成文件这一章开始会涉及到服务端，将使用express——一个node的web框架搭建一个api服务，拥有文件上传与下载的功能，具体实现不会讲得太详细，因为我们的重心还在放在浏览器。 我们先设计一个上传文件的api——POST方法，使用form-data传递参数，这个接口接收文件后保存在服务器。 上传文件api 文档 POT localhot:3000&#x2F;api&#x2F;file&#x2F;upload 文件上传 form-data - &#123; file: &lt;文件&gt; &#125; 接口实现 // ... 省略部分express代码 // 配置上传功能 const multer = require('multer') const uploadPath = path.join(__dirname, './uploads/') // 上传目录 const upload = multer(&#123; dest: uploadPath, storage: multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, uploadPath) &#125;, filename: function (req, file, cb) &#123; cb(null, file.originalname) &#125; &#125;) &#125;) //初始化 uploadPath fs.exists(uploadPath, exists => &#123; if (!exists) &#123; fs.mkdir(uploadPath, e => &#123; e &amp;&amp; console.error(e) &#125;) &#125; &#125;) // 上传文件 app.post('/api/file/upload', upload.fields([&#123; name: 'file', maxCount: 1 &#125;]), (req, res) => &#123; res.json(&#123; code: 1, msg: 'success', data: null &#125;) &#125;) app.listen(port, () => console.log(`Example app listening on port $&#123;port&#125;!`)) 前端上传实现 &lt;form action=\"/api/file/upload\" method=\"POST\" enctype=\"multipart/form-data\"> &lt;input type=\"file\" name=\"file\" /> &lt;button type=\"submit\">上传&lt;/button> &lt;/form> 这里提供三个文件，作为测试文件依次上传： html (事实上这个一个html文件，只是文件名为html而已) logo.png style.css ls查看上传目录有相应的文件且Length大于0，则表示以上代码能正常运行功能。 下载文件由服务端生成的文件，api可能响应以下三种类型的数据： 直接响应文件，供浏览器直接下载 响应文件内容，由浏览器生成匹配的文件格式后方可下载 响应文件路径，由浏览器自行处理（参考1，2） 直接响应文件，浏览器可以使用window.open() 或者 &lt;a downlaod href=&quot;&quot;&gt;&lt;/a&gt;直接下载。响应内容稍微比较麻烦，如果是直接响应文件内容（不是base64），浏览器需要转成base64（存在不知道其文件格式转换失败的场景），如果是直接响应base64字符串则可以用URL.createObjectURL处理。响应文件路径一般浏览器直接打开此路径即可下载。 我们还是先设计一个api，让其拥有下载功能，这个api应该接收两个参数，一个是指定的文件，另一个是指定响应的数据类型 GET &#x2F;api&#x2F;file&#x2F;download query fileName [String] 文件名称 query type [String] 数据类型 content - 文件内容、base64-base64、path-文件路径、file-返回文件 // 下载文件 app.get('/api/file/download', (req, res) => &#123; const &#123; type, fileName &#125; = req.query // 是否缺失必填参数 if (!type) &#123; return res.status(200).json(&#123; code: -1, msg: 'query type is must need!' &#125;) &#125; else if (!fileName) &#123; return res.status(200).json(&#123; code: -1, msg: 'fileName type is must need!' &#125;) &#125; if (type === 'file') &#123; // 返回文件 let fileURL = path.join(uploadPath, fileName) res.download(fileURL) &#125; else if (type === 'content') &#123; // 返回文件内容 let fileURL = path.join(uploadPath, fileName) let fileData = fs.readFileSync(fileURL) let bufferData = Buffer.from(fileData).toString() res.json(&#123; code: 1, msg: 'success', data: bufferData &#125;) &#125; else if (type === 'base64') &#123; // 返回base64 let fileURL = path.join(uploadPath, fileName) let fileData = fs.readFileSync(fileURL) let bufferData = Buffer.from(fileData).toString('base64') let base64 = 'data:' + mineType.lookup(fileURL) + ';base64,' + bufferData.toString('base64') res.json(&#123; code: 1, msg: 'success', data: base64 &#125;) &#125; else if (type === 'path') &#123; // 返回路径 res.json(&#123; code: 1, msg: 'success', data: `/api/uploads/$&#123;fileName&#125;` &#125;) &#125; &#125;) &lt;p> &lt;input id=\"file-name\" name=\"fileName\" /> &lt;select id=\"download-type\"> &lt;option value=\"file\">file&lt;/option> &lt;option value=\"content\">content&lt;/option> &lt;option value=\"base64\">base64&lt;/option> &lt;option value=\"path\">path&lt;/option> &lt;/select> &lt;button id=\"download-api-btn\">下载&lt;/button> &lt;/p> const downloadApiBtn = document.querySelector('#download-api-btn') downloadApiBtn.onclick = function () &#123; const fileName = document.querySelector('#file-name').value const type = document.querySelector('#download-type').value fetch(`/api/file/download?fileName=$&#123;fileName&#125;&amp;type=$&#123;type&#125;`) .then(async response => &#123; if (type === 'file') &#123; let blob = await response.blob() downloadFile(fileName, blob) // 也可以使用window.open // window.open(`/api/file/download?fileName=$&#123;fileName&#125;&amp;type=$&#123;type&#125;`, '_blank') return &#125; let json = await response.json() if (json &amp;&amp; json.code === 1) &#123; const data = json.data if (type === 'content') &#123; const blob = new Blob([data.toString()]) downloadFile(fileName, blob) &#125; else if (type === 'base64') &#123; downloadFile(fileName, data) &#125; else if (type === 'path') &#123; window.open(data, '_blank') &#125; &#125; &#125;) &#125; 其实当这里type为file的时候直接返回文件，是可以不需要发起http请求，直接window.open()就可以的，这里只是为了演示，实际开发中建议返回文件直接window.open() 或者 &lt;a downlaod href=&quot;&quot;&gt;&lt;/a&gt;。 其次/api/file/download?fileName=logo.png&amp;type=content 可以下载图片，不过无法打开。为什么呢，首先这是一张图片，type=content只是返回了图片文件的内容，浏览器接收到了文件的内容，可是并不知道用什么格式去解析，所以这里导致图片下载下来了，然后并不能预览。所以服务器返回文件内容需要双端约定好文件格式。然而就算如此，浏览器也需要将起转成Blob或者是其他文件对象再下载下来。 相对于base64字符串，也是要使用URL.createObjectURL将其转成Data URLs，相对来讲base64浏览器就无需关注文件格式了。 最方便处理的莫过于直接响应文件了。 结尾这次我们主要介绍了浏览器和服务器的生成、下载、上传文件，还介绍了浏览器中的&lt;a download=&quot;fileName&quot; href=&quot;content&quot;&gt;，以及 new File，Blob和Data URLs三种方式表达一个文件。前此文还有未提及的Array Buffer、XMLHttpRequest.responseType需要我们后续自行了解。","categories":[],"tags":[]},{"title":"浏览器图片机制","slug":"image","date":"2020-11-06T10:48:40.000Z","updated":"2024-03-17T09:23:23.056Z","comments":true,"path":"/post/image/","link":"","permalink":"https://screw-hand.com/post/image/","excerpt":"前言浏览器中引用图片是一种很常见的情况，使用方式的不同，他们的意义也不同。比如————作为“内容主体”、“背景”、“图标”等，而设计师有时候也会提供不同的格式图片（img&#x2F;png&#x2F;svg&#x2F;）。在不同的场景，我们对同一份图片素材，要根据图片在web界面中的意义合理运用。个人会列举浏览器常用使用图片的方式。 img background-image icon-font svg webpack 与 img base64","text":"前言浏览器中引用图片是一种很常见的情况，使用方式的不同，他们的意义也不同。比如————作为“内容主体”、“背景”、“图标”等，而设计师有时候也会提供不同的格式图片（img&#x2F;png&#x2F;svg&#x2F;）。在不同的场景，我们对同一份图片素材，要根据图片在web界面中的意义合理运用。个人会列举浏览器常用使用图片的方式。 img background-image icon-font svg webpack 与 img base64 img、background-imageHTML的img标签、css的background-image样式是最原始的使用图片方式，在H5时代前，相当长的一段时间都是用这两方式引用图片资源的。 &lt;img&gt;标签，将图片作为内容主体引入web页面，故其是占位的；而background-image样式，起修饰作用，不占位。 基本用法img &lt;img src=\"https://mdn.mozillademos.org/files/7693/catfront.png\" /> background-image &lt;div class=\"background\">&lt;/div> .background &#123; width: 30px; height: 64px; margin: 0 auto; background-image: url('https://mdn.mozillademos.org/files/7693/catfront.png'); &#125; .background { width: 30px; height: 64px; margin: 0 auto; background-image: url('https://mdn.mozillademos.org/files/7693/catfront.png'); } 虽然呈现的效果一致，意义却不一样。 img之尺寸、居中img标签提供了关于设置尺寸的属性，分别是width和height，单位可以是css像素，也可以是百分比。 &lt;img src=\"https://mdn.mozillademos.org/files/7693/catfront.png\" width=\"100%\" height=\"100%\" /> 然而尺寸的百分比单位并不是相对于图片资源的比例，而是其容器的百分比。 所以并不推荐使用img标签的width及height设置属性，推荐使用css的width及height属性编写。 其实很多web开发者设置100%的本意是想让图片按父容器宽度自动缩放，并保持图片原本的长宽比。 img &#123; width: auto; height: auto; max-width: 100%; max-height: 100%; &#125; 除此之外，img的居中方式也是很容易让人误解，因img的display属性为inline-block，其居中方式（水平、垂直都是）更是让人误解。 &lt;div class=\"block\"> &lt;img src=\"https://mdn.mozillademos.org/files/7693/catfront.png\" /> &lt;/div> .block &#123; width:150px; height: 150px; border: 1px solid #333; /* 垂直居中 */ display: table-cell; vertical-align: middle; /* 水平居中 */ text-align: center; &#125; img &#123; max-width: 50%; max-height: 50%; &#125; 没想吧？居然是加在img的容器标签上，虽然绝对居中（水平、垂直都同时居中）还有其他的方法，常见的margin auto居中还有绝对定位50%。不过个人觉得这是最值得开发着去记住的。除此之外，也建议给容器设置font-size: 0;，这可以解决两个相邻的img标签之间的空隙问题。 说了那么多的img，现在得回过头来谈论background-image了。 background-image之位置、尺寸及重复虽然前面我们说的background-image一直说的是css的样式特性，然而background-image只能指定使用的图片资源（可以是一张、也可以是多张）。背景图片样式（如本节小标题所说的位置、尺寸及重复）的设置，往往还需要结合其他css特性。 background-position可以给背景图片定义位置，设置的是其图片的左上角要在容器的哪个偏移度位置。 background-size 可设置背景图片大小。contain理解为等比例缩放图片，高度&#x2F;宽度其一先与容器尺寸相等，则停止缩放，若图片和容器宽高比例不一致，会出现白边；cover也是等比例缩放，高度&#x2F;宽度其一先与容器尺寸相等，继续缩放，（此时图片溢出），直到另一方向的尺寸占满容器，停止缩放。 更简易的理解： contain为最小化等比例缩放图片，cover则为最大化等比例缩放。 除了这两个关键字，也可以用两个单位值指定背景图片的宽高，对于绝对单位（px、em、rem）没啥好说的，对于相对单位（百分比），是相对于容器的尺寸来计算的，有意思的是100% 100%，这代表着破坏原比例，把图片拉伸&#x2F;挤压到容器的尺寸。（很多css属性的相对单位都是根据容器来计算的，或许有特殊的属性我忘了。;-) background-repeat 设置图片重复使用的方式。 以上就是关于背景常用的css样式特性，完整的css背景样式如下，并不复杂。 background-attachment background-clip background-color background-image background-origin background-position background-position-x background-position-y background-repeat background-size 不建议使用css简写属性background一次性设置背景特性。 CSS SpritesCSS Sprite(CSS 精灵), 又名雪碧图，是一种图片合并技术，我们可以把一些小图，整合放在一张大图中，每次单独使用小图的时候，裁剪出指定位置，尺寸即可正常显示。 像上图就可以作为雪碧图的素材使用，以实现改方案。 简单分析一下这张图片： 尺寸：134 * 44 小图数量：3 规范：固定大小，水平排列 那我们可以定义一个通用的class，设置小图的尺寸；再定义一个class，设置图片裁剪位置即可。 .css-sprite &#123; width: 44px; height: 44px; background: url(\"./CSS-Sprites.gif\"); background-repeat: no-repeat; &#125; .hourse &#123; background-position-x: 0; &#125; .left-arrow &#123; background-position-x: -44px; &#125; .right-arrow &#123; background-position-x: -88px; &#125; 特性 减少服务器压力：多图合并成一张，只发送一次HTTP请求，并且可以被缓存，有助于提升页面加载性能 维护困难： 后期维护成本较高，添加一张图片需要重新制作。 应用麻烦：每应用一张图片都需要调整位置，误差要求严格。 局限：只能用在背景图片background-image上，不能用&lt;img&gt;标签来使用。 不同方式实现 CSS Sprites如果会使用gulp、webkack 等构建工具，可以借助工具自动生成雪碧图。 spritesmith，是一个node工具，可以将多张图片合成一张图片——雪碧图，也提供了grup和 gulp插件，甚至是命令行工具。 gulp 结合spritesmith的插件 gulp.spritesmith webpack结合对应的loader webpack-spritesmith svg svg-sprite-loader icon-font首先我们得明白，icont-font本质上不是图片，而是一种比较特殊字体，这种字体，以图标的方式显示。 web字体得益于css3的新特性“web字体”，我们可以为自己的网页定义在线字体，无论用户是否安装了我们指定的字体，我们都可以让网页呈现出我们想要的字体，突破了传统Web-safe 字体的限制。 /* 定义名为“Open Sans”字体 */ @font-face &#123; font-family: \"Open Sans\"; src: url(\"/fonts/OpenSans-Regular-webfont.woff2\") format(\"woff2\"), url(\"/fonts/OpenSans-Regular-webfont.woff\") format(\"woff\"); &#125; /* 应用于网页 */ body &#123; font-family: \"Open Sans\"; &#125; web字体不是我们这次要重点的谈论范围，了解即可，这里提供了一些相关资料： Web 字体 @font-face font-family 所以icon-font，指的是使用自定义的字体展示图标。运用了上述介绍的web字体技术。 基本使用字体图标技术已经是web主流使用icon的一种方案了，很多UI库都内置提供了一套图标库供开发者使用，当然也可以独立使用开源的图标库，或者使用工具生成自定义的图标库。 这里用常用的UI框架elemment-ui举例，其UI库提供了icon组件，内置了图标库，使用方式也很简单。 基本上，正确引用了icon-font，直接设置的类名即可展示对应的UI，那么我们究竟引用了什么东西呢？在icon页面上，使用F12打开开发者工具、找到element-ui-*.css源码。 独立的开源图标库有很多，名气比较大的有Font Awesome。使用方法也是类比UI库，引入相关的css源文件即可。css源文件也是类似element-ui-*.css的格式，引用外部资源、定义web字体、使用web字体，内置定义了class。直接在相关dom中使用class即可。 实际项目中，这种开源的集成图标库往往不能满足需求设计稿，我们需要使用一些自定义图标。我们可以使用一些工具：iconfont、fontello、icomoon，都是很优秀的在线生成图标库，具体使用方式网站也有介绍，不再累述。教程中引入的css，也是跟element-ui-*.css的格式类似。 特性icon-font最大的特性就是样式有更多的灵活性。我们可以像处理文字一样处理图标的样式。使用font-size控制图标的尺寸，text-align、line-height控制其居中方式，甚至是color为图标设置不同的样式。 一般使用icon-font都是一套一套的使用，而不是一个一个独立使用，所以这对减少网络请求次数也有优势。 矢量图形也意味着我们可以随意调整图标大小而不用担心其失真。 不过icon-font只适用于纯色图标，当然渐变效果也可以使用css样式编写。 svgsvg——可缩放矢量图形(Scalable Vector Graphics)，是一种文件格式， 用XML 的格式定义图像。我们可以使用代码编辑器编辑svg文件，使用浏览器可直接预览。 &lt;svg version=\"1.1\" baseProfile=\"full\" width=\"300\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"> &lt;rect width=\"100%\" height=\"100%\" fill=\"red\" /> &lt;circle cx=\"150\" cy=\"100\" r=\"80\" fill=\"green\" /> &lt;text x=\"150\" y=\"125\" font-size=\"60\" text-anchor=\"middle\" fill=\"white\">SVG&lt;/text> &lt;/svg> 可以先将其拷贝保存为x.svg，待会用到的 。 将在浏览器中呈现… 基本使用有几种使用方式，第一种是直接作为标签嵌入HTML源码中。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;svg version=\"1.1\" baseProfile=\"full\" width=\"300\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"> &lt;rect width=\"100%\" height=\"100%\" fill=\"red\" /> &lt;circle cx=\"150\" cy=\"100\" r=\"80\" fill=\"green\" /> &lt;text x=\"150\" y=\"125\" font-size=\"60\" text-anchor=\"middle\" fill=\"white\">SVG&lt;/text> &lt;/svg> &lt;/body> &lt;/html> 第二种是将svg代码保存为一个单独的文件，如同png，jpg，git等图片资源一样使用。 &lt;h1>img svg&lt;/h1> &lt;img src=\"x.svg\" alt=\"\"> &lt;h1>object svg&lt;/h1> &lt;object data=\"x.svg\" type=\"\">&lt;/object> &lt;h1>iframe svg&lt;/h1> &lt;iframe src=\"x.svg\" frameborder=\"0\">&lt;/iframe> 背景图片也是可以的。 &lt;div id=\"div-svg\">&lt;/div> &lt;style> #div-svg &#123; width: 300px; height: 200px; background: url('./x.svg'); &#125; &lt;/style> 特性svg基于XML语法实现，可以用DOM选择器获取该DOM对象。前提是用第一种方式直接将svg嵌入HTML。 &lt;!-- 先给刚才的svg加上id属性 --> &lt;svg id=\"dom-svg\" ...> ... &lt;/svg> const domSvg = document.querySelector('#dom-svg') console.log(domSvg) // &lt;svg id=\"dom-svg\" version=\"1.1\" baseProfile=\"full\" width=\"300\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"> console.log(domSvg.childNodes) // NodeList(7) [ #text, rect, #text, circle, #text, text, #text ] const divSvg = document.querySelector('#div-svg') 如果有用过icon-font，会知道我们可以用多个svg制作成一套字体图标库。虽然字体图标然比传统的img，background方式有着更好的css样式灵活性，可终究直接使用的时候是纯色的。而svg有着更好的色彩表现能力，同样也是矢量图形，且可以进行DOM操作，这也意味着我们可以随时动态地改变图片的结构。而且svg不仅仅可以制作成字体图标库，也可以转换成png、jpg等传统图片格式甚至是canvas。 svg文件格式现在已经是主流web开发图片使用方案了，而且是目前最灵活的图片文件格式。 webpack 与 imgwebpack是一个前端打包工具，前端项目的每个静态资源都是一个单独的模块，webpack内部会自动管理这些依赖关系，编译源码时会自动根据这些依赖关系进行打开，最终生成bundle。其特点是拥有模块化机制、loader可以对各种类型的模块加载时运动不同的任务、插件化更是令其可以跟其他的构建工具（grunt、gulp等）结合使用、*模块热替换***更是大大加大了开发速度，模块的更新无需重新加载整个页面。 webpack功能多样且强大，我们本次将重点放在webpack是如何处理图片资源的。webpack一般是跟vue或者react框架集成使用，当然也可以独立使用。原理都差不多，框架的脚手架会基于webpack进行对框架场景的适合或者说扩展。为了方便，这里以vue为例。 基本使用vue-cli已有相关介绍，简单来说，就是在template中，还有在js中有不同的使用图片方式。 原生html 跟vue的template语法是一样的。 &lt;img src=\"./image.png\"> script 或者叫js中是这样使用的。 imgURL = require('./image.png') &lt;img :src=\"require('./image.png')\"> background也类同&lt;img&gt;。 裂图&#x2F;空图裂图：指定的图片资源地址不存在，或者加载失败（404），此时界面出现一张小的占位“裂图”； 空图：不指定图片资源地址，如果样式有设置尺寸大小，会根据img&#x2F;background的原生特性占位。 裂图一般是bug，我们需要根据bug的场景去解决。 空图也有其使用的场景：如，初始img标签，动态加载不同的图片资源地址，默认占位。 实现空图也很简单，src=&quot;&quot; :src=&quot;null&quot; 即可，也可以直接不使用src属性。 有意思的是，当src的属性值为空时，chrome 和 firefox 渲染的DOM略有差异。 &lt;!-- chrome --> &lt;img src(unknown)> &lt;!-- firefox --> &lt;img> 小图自动转成base64有时候我们会发现webpack自动把一些小内存的图片自动转换成databas64格式的编码。在vue-cli也有相关的资料介绍 —— 从相对路径导入。 我们知道vue-cli是一个集成了webpack常用的功能实现的vue脚手架，为了是配置管理vue项目更加方便快捷，内置静默配置了webpack的常用功能。 究其原因还是使用了webpack的file-loader处理资源最终引用的路径。url-loader将小于指定大小的资源转成内联（这里包括css、javascript、图片字体等静态资源），css javascript 都拥有html对用的标签，图片资源则是处理成base64格式。为了是节约 HTTP 请求数量。 vue-cli可以使用chainWebpack设置指定大小，如果是单独使用webpack，则应该配置url-loader，以下是参考的url-loader配置。 module: &#123; loaders: [ &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' &#125; ] &#125; base64base64是一种编码的方法，可以用来表示二进制数据。所以图片也可以被编码成base64，形成一条字符串。 试试将下面的这串字符复制在浏览器地址栏直接访问，看看是本文的出现的哪张图片。 data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAABACAIAAACC1lByAAAABnRSTlMAAAAAAABupgeRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAOjUlEQVR42iXWS6+t2VXe8WeMMed7W7d9OfvsOuUqW3YZ28GWLIgUJJAQNDBCIEXp5ZOELp8njdCnGymNRIJEGBxju27nfmrf1l57rfcy5xgPjfoK&#x2F;8ZPf&#x2F;lvf&#x2F;t30ZBOMHyp8zKNT&#x2F;O71+&#x2F;effmuy&#x2F;ZHf&#x2F;0nV88uCDVqzdVgmakmT6IKHceRnq2PnHqNZIlUq3UWBsAkphYuWj2EiS8uP3k6PN7e3lOEGrpISDaZK1VEQPVUFQmAizd9FmgSkwTNOs+LRNQyQ5T0JAAkBUQgSfJq6Dfb9Xq3279&#x2F;XJ4eHW6yhBpDNESkShhBGAW2zGVZpq5paOhcUD3lpgBmOh2LhglJC6GVfmim&#x2F;dP9uw9tkr&#x2F;6L38xbLYlkosaFRqAgwyIgQQB18TNqltthufXl7ltrc2pbbphEFGzULKKuGsok1c&#x2F;POy9BBemLv35X&#x2F;1ZzgVQKkTMVavwdDoeR3doqZVVmpR7bWKcoe7V57LMsz8eH8ZlSiKUSKqlgkrxOPm8FGmiJhnSZ9c&#x2F;ur29&#x2F;bDfb1e7zWb48PbdzYfb+TheXT9LJldX17Q6lnu3pmRQaNDj8QFaXUtSkUiLEBBErV5lmk95dZaa8fTwtF8d7u7vvvn6A4Hzi+18mp8eRmtTmcfn3&#x2F;vOetciqpimPrWWl&#x2F;Ak1q8MVEanFI1Q+KqpKSLGaRpP8&#x2F;F4nOZlrn775vb1569LyBLFAx&#x2F;&#x2F;8NPNs1VuxaxR0fCScpKmJxLVQJ3nERTST+NTMlCgtFNQ1FWAZRznaWyHVdO3+6e7ftPOx&#x2F;nF1bNPPvvBZz&#x2F;65Hi7H7bb7WZo+46lmmKyYqIaUMQ4L&#x2F;NUxqd9breJYSKJMrsCzrzaXgzd7vo7Neb5VFbr3dnVdbe26+cvrl9cbjfrH&#x2F;&#x2F;8J+3Q9+shwQSV4zydDkKlpToe6MWybXdnJppgAbgQVsFkbZfGw1KX07Dph9Ua1xTTH3z&#x2F;e0lks15Jk37v93+4fzw0bU5iyihdw9MBQuES4iIwiqhUMhE01iJz0pZqNqy71So1lttWRc+252M5RURerzQ3gA+rnlB4FTVIaJNTNopOx3FZFlGCAaBORZWZKsY2VCGiOfWrVW47hW63Z3lourZ&#x2F;Op1MNSWAAkmiomaKyJLW66HpV&#x2F;Ay1xESwhDJVBn6PilYASrIaqB7nmpcnq9h&#x2F;Nd&#x2F;&#x2F;uU88qMX59vd9i41w6cfNWbui8&#x2F;z0+Mx5Xx2sUqazne7rx&#x2F;upuUoESEh0SaURXJygYgZ4OGkOQpctWuuXzz&#x2F;3&#x2F;&#x2F;zn375j78+X7c&#x2F;&#x2F;vlPq&#x2F;Pq+cXZ2e71q7d&#x2F;&#x2F;9&#x2F;&#x2F;x7TwP3z2gz&#x2F;9yz8209Ph+L&#x2F;+4f9M09GQPRaBOkMUCSJSoyaqGhcH6DqNx7HU+MV&#x2F;&#x2F;sV2s&#x2F;7q81dlnubTXJ0e&#x2F;vbLr81rM+Oz3&#x2F;t+bhtV++rl61e&#x2F;ebWMozTBohSnG9STeRVVEY0IFfUwuh8eD&#x2F;ubu2fPr&#x2F;76v&#x2F;7N5&#x2F;&#x2F;2u89&#x2F;9VtNctjvV33z3R9+7+Lqclh3u4tdn5uIuH91iwTA5iIpIlDpDmqKBGEAIqhMWSIUUk7z&#x2F;u4hNSl3tttu1tt1VJmnSVWurp73Xdf0bdsYhGWa85B&#x2F;9h9&#x2F;onQqUaGmCrpEgoRQCYOqUEQtwRZdnh5P55e+TGV&#x2F;&#x2F;5Capp4eseym47T7eAfxAEkj+Prt+2HVNN99RoEABJQSikYiESkg5vDkacmeqiSTmqF8OhymeSqTG9J4GuvD6bh+4IvrnDv3WnypxW9u3kaeM7NLVWnCZkhuA4AnKCEoqE1YtVBnaq1r8+K1LCFSc2OizbPrnxw&#x2F;3H60G2qpSxQRBGOap2msSZJkJSC+JGSgqJJoEggXz1VobljR62l&#x2F;3Fyuu94kQsKgAbFpXEaR&#x2F;cOodt80mlQg7LuutTRDKa5MakElkAJIUKUWBZnULYMFGWLx&#x2F;v3d4&#x2F;4pqj8c97c396fTodb5&#x2F;GJDWQ77h9N4nGs1a5NhWK1MIKImITQBiEgEAkkjXFxdjGyalSaeWMdvTof7hy8ex3n0p8Nhd3Hxs&#x2F;&#x2F;0Ixua5X7fdSvrcj+ImJhZt27kG1EWCRAIVEESIBQpmDQ8JDQLM5PkfisfNe3h8Wjd1Nf5ojkfhv7weLy43l4+&#x2F;yiZ9X3fNX1OirA2DwCERmqYmJsgUykaSd1FRNTNe7XERjft2q2mnCSlae8GfufTjzbrfrvZtKlJpikLEEIV0912m7RdWKssClDt2+5gSiEhkZSqneYcwW&#x2F;xa0&#x2F;vl&#x2F;Lyi+n2prGcfvy9i+cXbc6qpsksJUuAiEKtSZZFWBMpc6U1IlApgaThBECJgKbcrtaDJrU27x9u5PChwyjz6fDF5yZKESSYMiELzNRg3rZJFVIDzioKd7K4AKJKR9TiYcIiwb7rNttNlJif9kIVUVpMh6emaZKaBUhQwgBGrSUipO3WoaFUJIaRoiKqnJUeEZXhlW5i0ACRcsrtKiSUIlG7YQivIgpIQExUoABUKFLbrgGTA+YwUQgDDqgynBDSvXpliVLDq2Vdn1&#x2F;6sHKGZH3+wx9ECSGCNYFmoMDdw0Mg634QmkSI1IBImIZCkIgF0RBE8XkuzQQzN+ezq&#x2F;P29&#x2F;9Aj&#x2F;vu8nz78QsXEROlJGsJiLiaqalPPmz6ZLa4gn0ojQnhrp6iZlFXNpHrsvg8PwmqZTPl9cfX691PSkyqzEr32qSUkhmgUELpEERuvt0CQsLCICWUgGllcY8aYymT18UDEbVOtY5LJRafzYzOsjAqkzZmCqSgECRImFhOmhwOVtABb1wtQqO6u6OG09wZdaGHKFJOqmTAxOalqlnTNJaEQQ+nOCQACNiY5cYUDlKCEVEUBDXczYUEa6BGKVHDwys96OHz9PR0kBIKNwUEAVdQSaOQhIgohs1aAHoCSEDIYFVElIgIKFPEUotHIQhRpQpEylgqUUsJJ1QEpIqoBhAsEiTj&#x2F;Oyi789MECEaKeDGTt2DdEjKZhRVhhqookAwmj4TNVjnuYazlqoqphoUMsJLSDFLbdeknAOgzIJKUlC1SKlRVAmhmBBJGFJcu5SpQqSsAiAhOHspQXefvJZvhVAYgJxaU6EGRCkQ0BGqrspk0keohpMlXGhmYov7NI7rzWYYOi&#x2F;VXasv4aE0iKmpqoopxCxhtVml1DCEDvEsYeoeYYSFipCmtKKRcq5LQFiqNu26zW1WmabJa4AAtMtt02SzLCICUqAi4U4QAKSSoR5BF3VVJAGJUIqqpTYLRLVGnTWr5maajrXGtwcACRETmIYRoUjLUhCEB4OoFkIFoSFQEVOBQcIrUqNNl9uh7ftegGWcWGnITWoASZZFFeFkeITCcmO73aaoRwhDii2kJndQqkuhZYIRVsIFKTdNNgtSm3Z6fETKKTVQNTOVCGcQdEIrIBopDZ2hcUxCiItoVQ+v1S3EmEwahGNepnlU0dS0uU8KLo7pOKmEiAoIKIJeSzDEBa4exUQ8HLCAk1pZtVQPRghVKqW6Yym+jEcGm9S1ab1&#x2F;PJ3G0RlqbcrJzAQAtCzV3aswogql79ZD16h4EAEnWv3w8iiu6hokRNx9GZd5LF5cDE2Thcvp8QAoJNyreyVQa51Oo5MMhYIAvQa0kgIYoKzar+XpcCjLUrkoQlQr6vG4HI&#x2F;HiKqJlvrT8RS+SFBVVaGSDscH1yoigiADHvcPD9N4EGcA7hnIenmx06a9edzPU0RkEarEcTyeDsdaKqi505QbYQpAxCAK8dPhKFRBuItXd&#x2F;L4dCgupAbJCHpJxcfXX950fbPqhiY1mqWKxFyXpSzzFDG0qWdUiJhYo2qmp+mkggRElRAPFxHOU415ISFMlBKAfniz3z88PB5Oh&#x2F;1+PI0sFJfA8nC3Px3mqGGteVSRUJVQqqTj4RGplSRBeiUZHpWmSzgCoAhUQtPbr1+HGLHcfPOobQ5hMvOIw+P+9DSOc1lvNs1mZ0bLpqJGOU3jqlsFjSji9Aj3Op8mqUKJUBdUCtPs1qih+u3N41I8FtnsGlou8+n29m59vh761bBqKCk3aqYBmqokAyRq8UpA9ofDzZs3dSnRqFUEFCZJDZZzMpnnU7ldVHwpl5tNB9rD3cP6m2F7frbut01KObVNbiRpCERIMujjab49PH35qy&#x2F;vXn+jjuBS3brVsPv0me3Wz+GEsm1bFT+dxlJF1YDKQNfms7NdahPJzXY39D0Z7z+8b9tOQIC&#x2F;&#x2F;uLdb3&#x2F;9BirSZmaTOp+Oy7BedbtevYYos+ZxPs0TLDdPh4ebd3dl5lSfHk&#x2F;7+&#x2F;3dZr2uUWqd5mUK4WaziigKPT6V+7vDaqWIZX4c728ef&#x2F;XbD6WW9fkFZySAdSmLtV58tUHbmFd6nbsht5ZiYSkVdFM8PNyXsrStDW0&#x2F;jsdI9f7wgKj1cTo9Pr599y7medvky+uraNXn2TbdFZI6Fgpy2yyz1xJN1hBvunaz3mxWfagnS69evhJLSs1tC9H72&#x2F;svP395+PD+&#x2F;v7xzcv3eVw+++Tq+sWz4fn54fDU9pZCaUov0rcJ1ZfC3KdTqcdXt6c5rj6+ki6t15u2ax72jw83DwLZnG2mUv&#x2F;l&#x2F;&#x2F;7m8Wa&#x2F;fzoe7u5Sma8vL07TfP1sM0LaVvvGbDN8FEuoEhI1iIhGc6kzi5fjGMKr5xeXz66c9eUXb&#x2F;Z3p65vk+nLl2++&#x2F;t2r+&#x2F;vD&#x2F;sN9N6eL3dZNR8fmk4&#x2F;HMl6st9NxSgoJq4ROhT2USSOcNSzlMH39u7f&#x2F;L7XfvLq7uX+6+eb+O9&#x2F;9dB6Xz&#x2F;&#x2F;&#x2F;6y8&#x2F;&#x2F;8pjPuyfLmxYXwzFQIn1xZlKs+6aw+kYXpKp5Nx5eJ2mmXljic4whFUjqw9ffPH6n3&#x2F;5b1i0265&#x2F;+oc&#x2F;Pd3cffHVa&#x2F;dQk&#x2F;PzYdWtLGXxGOnb5xfH+XG7zrfvH7a7jZ2fX8MBImgIR9bV2a7MBWIIkqHWd20DUTE53N9&#x2F;9du3ZZ5Lmc5WQ9+027MNBhVhNwyXnz57&#x2F;bt39Hp+tSZzqgWgB0FWUIiy2q0BnMYjAgAjlm4zrJ+fa07Z7Nm2h2q23LfSt7vRZ5HUDd3588vjzen+zf3Z7sWmWz+U+d8BxLQ80KidgBcAAAAASUVORK5CYII&#x3D; 这条字符串有特定的格式的，这种格式叫Data URL scheme，意为data协议（类同http协议）。base64编码不仅仅可以表示图片，也可以表示其他类型的数据。 data:[&lt;mediatype&gt;][;base64],&lt;data&gt; 再次区别：base64是一种编码方法。Data URL表示一个文件，可以是图片，也可以是其他格式的文件。base64对其来说更是一种可选的编码方法。 特性 体积会比原来大1&#x2F;3 不需要请求服务器资源，减少HTTP请求次数 编码、解码方便，算法可逆，不适用于私密信息通信 无法缓存，不建议使用在改动频繁的地方 js创建base64的方法： canvas 将图片转化为 base64 编码 FileReader 将图片转化base64格式 使用场景base64的使用场景比较少，个人之前的工作经历是img url 有token认证机制，直接使用&lt;img src=&quot;https://HOST/xx.jpg&quot;&gt;，接口状态码返回403。而后端整个api系统都是有token认证的机制，不太好改，img标签又不支持添加HTTP请求头。最后用js发起http请求，设置token请求头。 使用XHR发送http请求，设置响应类型 xhr.responseType = &#39;blob&#39; 构建 new FileReader()实例，实例事件 onloadend获取base64 将base64 赋值给&lt;img&gt;标签的src属性 其他常见的编码格式 Unicode UTF-8 URL12 Unix时间戳 Ascii&#x2F;Native Hex Html 小结我们介绍了从各个话题介绍了浏览器中使用的图片，现在是时候来一波总结了。 img &#x2F; background - 原生html、css实现，分别作为内容主体、样式装饰功能 CSS Sprites （技术方案） - 一种优化图片方案，有不同的实现方式 icon-font - 基于h5的web-font特性实现，使用在线工具可生成一套矢量图片库，样式控制灵活 svg - 一种很灵活的图片格式，浏览器原生支持，可转换成传统图片格式或者制作成icon-font webpack中使用img - img在工程化中的简单实现 base64 - 一种编码方式，格式为Data URL scheme， 可表示图片等二进制文件流 结尾此本从开发者拿到一张图片素材开始。以在不同场景在，选择最合适的实现方式。尽管写得比较长，可还是少了一点东西。比如canvas没有讲，不过一般canvas用于脚本绘制渲染可视化数据多一些，当然能渲染成img，场景少，就没在这里讨论。本意也是觉得一张图片在浏览器上有多种使用方式，就整理了一下，写下以上内容，算是个人的知识总结回顾吧。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://screw-hand.com/tags/web/"}]},{"title":"同步遍历调用异步请求","slug":"async-to-call-async-request-foreach","date":"2020-10-06T03:11:50.000Z","updated":"2024-03-17T09:23:22.984Z","comments":true,"path":"/post/async-to-call-async-request-foreach/","link":"","permalink":"https://screw-hand.com/post/async-to-call-async-request-foreach/","excerpt":"业务场景：一次性发送多个http请求，并且这些请求有先后顺序之分。","text":"业务场景：一次性发送多个http请求，并且这些请求有先后顺序之分。 异步调用用单个http请求// mock http 请求，并且服务器响应了请求 function mockRequest(requestBody, delayTime) &#123; return new Promise(resolve => &#123; setTimeout(function () &#123; // 随意resolve一个json即可 resolve(&#123; statusCode: 200, requestId: Math.random().toString().split('.').join(''), data: requestBody &#125;) &#125;, delayTime || 0) &#125;) &#125; // 简单的这样调用是不够的，因为是异步请求，我们需要一个回调函数（call back） mockRequest(&#123; id: '000', query: 'a' &#125;, 1000) async function getSilgleRequestData () &#123; const res = await mockRequest(&#123; id: '000', query: 'a' &#125;, 2000) if (res &amp;&amp; res.statusCode === 200) &#123; console.log(res) // &#123; statusCode: 200, requestId: '00896521783396853', data: &#123; id: '000', query: 'a' &#125; &#125; &#125; &#125; getSilgleRequestData() 实际开发中比较常用的单个调用http请求我们已经实现了，那么也有在项目中一次操作（或者叫事件）触发多个请求，如果接口之间没有依赖关系，一般都是并发执行发送请求的。 异步并行调用多个http请求// 仍然保留之前定义的 mockRequest // 第一条接口 async function getRequestA () &#123; const res = await mockRequest(&#123; id: '00A', type: 'getRequestA' &#125;, 2000) if (res &amp;&amp; res.statusCode === 200) &#123; return res &#125; &#125; // 第二条接口 async function getRequestB () &#123; const res = await mockRequest(&#123; id: '00B', type: 'getRequestB' &#125;, 1000) if (res &amp;&amp; res.statusCode === 200) &#123; return res &#125; &#125; async function getMutilRequestData () &#123; console.time() const resA = await getRequestA() const resB = await getRequestB() console.timeEnd() // 输出为？？ if (resA.statusCode === 200) &#123; console.log(resA) &#125; if (resB.statusCode === 200) &#123; console.log(resB) &#125; &#125; getMutilRequestData() 因为上述两条api没有依赖关系，所以我们可以这些写： const resA = await getRequestA() const resB = await getRequestB() 如果是有依赖关系的话——getRequestA的**响应数据(response data)会被getRequestB作为请求参数(request data)**使用，那么应该这样做： const resA = await getRequestA() if (resA.statusCode === 200) &#123; const resB = await getRequestB(resA.data.id) if (resB.statusCode === 200) &#123; console.log(resB) &#125; &#125; 同步遍历中发送异步http请求所以结合以上所有，我们需要一次性发送多条api，有顺序的要求，那么我们可以定义一个数组，这个数组的每个元素都是请求参数，循环此数组，使用递归函数的方式调用api请求。 // ... mockRequest // 递归函数，遍历requestList元素，依次发送请求，当前请求响应成功后才会发送下一个请求 async function getData (requestList, callback, i = 0) &#123; let delayTime = 0 const res = await mockRequest(requestList[i], delayTime+=1000) if (res &amp;&amp; res.statusCode === 200) &#123; callback(res) if (++i &lt; requestList.length) &#123; getData(requestList, callback, i) &#125; &#125; &#125; // 定义请求参数，每一个元素都是一次请求，元素的内容都是请求参数 const requestList = [ &#123; id: '001', query: 'x' &#125;, &#123; id: '002', query: 'y' &#125;, &#123; id: '003', query: 'z' &#125; ] getData(requestList, function (res) &#123; console.log(res) &#125;) 更多这只是一个比较简陋的实现方案，并非最佳实践。比如此回调是每次请求成功的回调，有些业务场景需要全部请求完成后执再执行回调，还有这是依次发送请求的，也可以实现一个并行请求的方式，更多的扩展功能不再讲述。","categories":[{"name":"js","slug":"js","permalink":"https://screw-hand.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://screw-hand.com/tags/js/"}]},{"title":"vue生态圈","slug":"vue-ecosystem","date":"2020-02-05T15:22:39.000Z","updated":"2024-03-17T09:23:23.104Z","comments":true,"path":"/post/vue-ecosystem/","link":"","permalink":"https://screw-hand.com/post/vue-ecosystem/","excerpt":"这是一次资料整理，关于vue的生态圈。包括工具、插件，这里不按照库的类型分类。 思维导图体现的是这些库由什么原理实现，或者说深入了解库会接触到的一些关键点。 官方也整理了生态圈，不过修改记录是两年前。","text":"这是一次资料整理，关于vue的生态圈。包括工具、插件，这里不按照库的类型分类。 思维导图体现的是这些库由什么原理实现，或者说深入了解库会接触到的一些关键点。 官方也整理了生态圈，不过修改记录是两年前。 mind文件下载地址：传送门","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://screw-hand.com/tags/vue/"}]},{"title":"vue技巧篇：渲染函数 & JSX","slug":"render-JSX","date":"2020-01-28T12:01:25.000Z","updated":"2024-03-17T09:23:23.096Z","comments":true,"path":"/post/render-JSX/","link":"","permalink":"https://screw-hand.com/post/render-JSX/","excerpt":"前言官方文档介绍的渲染函数似乎有点太过偏重表现而放轻原因。已经看过这部分好几次，还是有点不知所以然。这也不是第一次看不明白文档的介绍了，还是需要自己整理下知识点。所以，这里的内容是对文档做降级处理，好让这一块知识点更容易理解一点。文档有的东西，这里不会再重复。 建议阅读顺序：先粗略浏览下官方文档；精读这篇文章同时结合文档。","text":"前言官方文档介绍的渲染函数似乎有点太过偏重表现而放轻原因。已经看过这部分好几次，还是有点不知所以然。这也不是第一次看不明白文档的介绍了，还是需要自己整理下知识点。所以，这里的内容是对文档做降级处理，好让这一块知识点更容易理解一点。文档有的东西，这里不会再重复。 建议阅读顺序：先粗略浏览下官方文档；精读这篇文章同时结合文档。 render先讨论render，再讨论JSX。因为JSX是为了render的编写更加方便。 基础渲染函数 &amp; JSX - 基础 这一小节官网介绍的是render的使用的场景。还举了个例子，真的不尽人意，起码看完我没能回答自己，render是啥。 render是一个实例方法，跟字符串模板&#x2F;template选项一样可以创建DOM。比起字符串模板，render的强大之处在于：字符串模板创建的DOM是静态的；render可以借助js的能力动态创建DOM。（不要忘了render 本质上是一个被vue框架封装的js函数） 静态&#x2F;动态DOM如何理解？template不是也可以使用v-if v-show v-for之类的指令吗？虽然template可以使用以上指定，对DOM进行修改，可是其无法改变HTML tag。以上的指令只是切换&#x2F;移除&#x2F;新增固定的HTML tag罢了。（举个反例，随机生成HTML tag 试试？） 官网基础这一小节，我们只需知道render是可以使用js能力创建HTML，是template的升级版就够了。 接下来的三个小节都是在讲如何使用render，我们先从虚拟DOM这个知识点入手。【基础】小节的例子，也会相应的介绍。 [节点 树以及虚拟 DOM](https://cn.vuejs.org/v2/guide/render-function.html#节点、树以及虚拟 DOM) createElement 参数 使用 JavaScript 代替模板功能 节点、树以及虚拟 DOMHTML DOM 节点的知识点相信基础扎实的你烂熟于心了，也看过文档复习了，这里不重复。 虚拟节点（virtual node）：描述 DOM 节点的JS对象，该对象保存着节点的相应信息。别名 VNode。 那 DOM 是由节点组成，虚拟DOM的概念也自然很好理解：由Vnode组成的节点树结构。 而render返回的值就是一个虚拟DOM，虚拟DOM最终也会被转换为真实的DOM挂载在页面上。 最简单的使用方式我学东西喜欢由简单到复杂，如果文档一开始就写个Hello World该多好。 &lt;div class=\"skill-render\">skill-render&lt;/div> 我们用template，render分别创建以上相同的dom。 // skill-template.vue &lt;template> &lt;div class=\"skill-render\"> &#123;&#123;$options.name&#125;&#125; &lt;/div> &lt;/template> &lt;script> export default &#123; name: 'skill-render' &#125; &lt;/script> 自行与下面的版本找不同。 // skill-render.vue &lt;script> export default &#123; name: \"skill-render\", render(createElement) &#123; return createElement( \"div\", &#123; class: \"skill-render\" &#125;, this.$options.name ); &#125; &#125;; &lt;/script> 终于我们知识点足够使用最简单的render，可是这里还是要说明下。render返回的是createElement函数运行后的返回值。所以其实是**createElement有能力创建虚拟DOM，而render依赖createElement的能力渲染为HTML**。两者的作用很符合函数名（笑）。 你已经知道createElement可以创建虚拟DOM，现在可以好好看看 createElement 参数了。 基础示例到现在，我们才要开始讲文档的基础示例，说实话，这个示例真的挺基础。文档要解决的问题其实就是要设计一个anchored-heading组件。 这个组件里面的HTML tag（h1~h6）可以使用prop动态决定，并且标题内部使用了插槽。 而使用template方案，代码冗长又存在重复问题。 所以使用了render函数动态创建HTML tag。 在基础小节的最后还进行了一波劝退：**深入渲染函数之前推荐阅读实例属性 API**。 深入使用 只要在原生的 JavaScript 中可以轻松完成的操作，Vue 的渲染函数就不会提供专有的替代方法。 文档也写得很详细了，深入底层的代价可以更好地控制交互细节。 这里略过不重复。 render: h =&gt; h(App)当你认认真真把关于渲染函数的资料看完，你也自然理解了main.js中，render为什么这么写。 new Vue(&#123; render: h => h(App) &#125;).$mount('#app') 小结render函数并不复杂，理解其需要返回虚拟DOM，最后会挂载在页面上就可以了。编写会比较繁琐，具体的体现就是vue提供的某些指令需要自己实现。用途会比较少，不过有助于我们研究vue，如果你想之后阅读vue源码的话。 JSXvue为了render编写更加方便，createElement可以使用JSX替换之。vue也支持JSX语法，不过需要一个Babel 插件支持。 什么是JSXJSX的定义，我们引用下官网的描述。 JSX - a faster, safer, easier JavaScript ……… 好吧，那我按照自己的理解来介绍了。 JSX是JavaScript的语法扩展。类似模版语言，本质上是js语法。 安装配置安装配置也很简单，使用也有介绍。 npm install @vue&#x2F;babel-preset-jsx @vue&#x2F;babel-helper-vue-jsx-merge-props 如果是vue-cli 2.x创建的vue项目，需要.babelrc配置，vue-cli 3.x+安装后忽略配置，可直接使用。 &#123; &quot;presets&quot;: [&quot;@vue&#x2F;babel-preset-jsx&quot;] &#125; 实现新建一个vue文件。 &lt;!-- JSX.vue --> &lt;script> export default &#123; name: \"skill-jsx-vue\", data() &#123; return &#123; type: \"vue\" &#125;; &#125;, render() &#123; return ( &lt;p> hello &lt;b> &#123;this.type&#125;&lt;/b> &lt;/p> ) &#125; &#125; &lt;/script> 然后发现，这里甚至可以使用去掉&lt;script&gt;标签，直接用js文件编写，不更方便？于是我们删除&lt;script&gt;标签，另存为JSX.js，相应改变组件名还有type数据就能得到以下文件。 // JSX.js export default &#123; name: 'skill-jsx-js', data() &#123; return &#123; type: 'js' &#125; &#125;, render() &#123; return &lt;p>hello &lt;b>&#123;this.type&#125;&lt;/b>&lt;/p> &#125; &#125; 美哉美哉。以后可以抛弃*.vue文件直接使用*.js编写组件了，可把自己高兴坏了。我也不喜欢*.vue的格式。 经常要考虑当前行的作用域问题，是vue示例呢，还是原生js的作用域呢。 but！！ vue实现css-in-js// JSX.vue &lt;script> export default &#123; // .. render() &#123; return ( &lt;p class=\"skill-jsx-vue\"> hello &lt;b> &#123;this.type&#125;&lt;/b> &lt;/p> ) &#125; &#125; &lt;style lang=\"stylus\"> .skill-jsx-vue &#123; color: green; &#125; &lt;/style> JSX.js是原生js文件，不支持&lt;style lang=&quot;stylus&quot;&gt;的语法解析。那也没关系，css-in-js就是为了解决在js中编写css样式而出现的一种方案。 虽然隔壁框架也有成熟的JSX还有css-in-js解决方案，不过这与本文无关，相关内容不会讨论。 vue的css-in-js 解决方案是vue-styled-components，当然不止这一个，还有其他的解决方案等待我们去探索。 安装完后，我们需要声明一个组件，这个组件只有样式，内容是使用插槽传入的，插槽自动定义的，这个组件供render使用即可。 // JSX.js import styled from 'vue-styled-components'; const StyledP = styled.p` color: wheat; ` export default &#123; name: 'skill-jsx-js', data() &#123; return &#123; type: 'js' &#125; &#125;, render() &#123; return &lt;StyledP class=\"skill-jsx-js\">hello &lt;b>&#123;this.type&#125;&lt;/b>&lt;/StyledP> &#125; &#125; StyledP也是一个vue组件，而render的&lt;StyledP&gt;&lt;/StyledP&gt; 相当于使用这个vue组件，组件名是js变量，大小写敏感。 思考一下，写一个带有样式的DOM，就需要声明一个vue组件，这样情况会不会造成组件滥用？ 当然你可能会觉得，这是不是违背了关注点分离的原则。对于组件化系统的框架，组件是组成项目的基本单位，更加关注的是，以组件为单位，而一个组件又包括HTML、CSS、JS，vue觉得将其所有组合起来比较合理。怎么看待关注点分离？ 当然我也会提供这一章的源码还有示例给你，还顺便实现了vue-styled-components官网的例子。 JSX.vue 源码 示例 JSX.js 源码 示例 css-in-js.js源码 示例 尾声今天我们从render出发，知道了虚拟DOM这一很重要的概念。途中认识了JSX，最后还结合了css-in-js实现JSX+css-in-jss。可是这些东西实际作用比较低。render函数示例开发中应用场景并不多，而JSX，css-in-js，vue对其的支持又有点不知道说什么好。不过如果你是抱着研究vue的精神而不是使用vue的想法看待以上内容，相信还是对你有点帮助的。","categories":[{"name":"vue","slug":"vue","permalink":"https://screw-hand.com/categories/vue/"}],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://screw-hand.com/tags/vue-skill/"}]},{"title":"git笔记","slug":"git-note","date":"2020-01-27T15:04:27.000Z","updated":"2024-03-17T09:23:23.036Z","comments":true,"path":"/post/git-note/","link":"","permalink":"https://screw-hand.com/post/git-note/","excerpt":"简介部分重要概念。 HEAD Working Directory &#x2F; Repository &#x2F; Stage branch remote tag repo","text":"简介部分重要概念。 HEAD Working Directory &#x2F; Repository &#x2F; Stage branch remote tag repo 配置 打开Git Bash，配置用户名字和邮件地址 $ git config --global user.name \"Your Name\" $ git config --global user.email \"email@example.com\" 本机创建SSH，Github配置SSH 一路回车 $ ssh-keygen -t rsa -C \"youremail@example.com\" win+r输入%USERPROFILE%/.ssh,成功打开且有以下文件则成功. id_ras：私钥，不能泄露 id_ras.pub：公钥，可以告诉任何人 以下操作需要Github账号，若无需注册。 添加SSH密钥 传送门 测试配置 Github新建仓库，初始化 本地clone下来，修改后提交，查看提交者信息是否正确 推送至远端仓库，输入密码 再次修改后提交，若SHH配置成功，无须输入密码 操作省略.. 文件状态 简写 英文 翻译 M modified 修改 R renamed 重命名 C both modified 冲突 R Untracked 未跟踪 命令分析一些常用的命令分析，我很喜欢命令行，不过source tree也挺方便的。 git status输出信息 当前分支 远端分支状态（是否拉取&#x2F;更新） 暂存区 工作区 实例分析 On branch master Your branch is ahead of 'origin/master' by 1 commit. (use \"git push\" to publish your local commits) Changes to be committed: (use \"git reset HEAD &lt;file>...\" to unstage) modified: src/main.js Changes not staged for commit: (use \"git add &lt;file>...\" to update what will be committed) (use \"git checkout -- &lt;file>...\" to discard changes in working directory) modified: src/components/person-filed/index.vue modified: src/router.js modified: src/views/loop-action/index.vue # ===== 翻译分割线 ===== 位于master分支 您的分支超前“origin / master”一次提交。 （使用“git push”发布您的本地提交） 要提交的更改： （使用“git reset HEAD &lt;file> ...”取消暂存） 修改：src / main.js 未提交更改的更改： （使用“git add &lt;file> ...”来更新将要提交的内容） （使用“git checkout - &lt;file> ...”来丢弃工作目录中的更改） 修改：src / components / person-filed / index.vue 修改：src / router.js 修改：src / views / loop-action / index.vue git commit输出信息 提交分支 commit hash值 修改文件数量 增删行数 实例分析 [master 2918d65] 1 1 file changed, 1 insertion(+) # ===== 翻译分割线 ===== [master 2918d65] 1 1个文件已更改，1行插入（+） git checkout自修改后还没有被放到暂存区–回到版本库的状态；已经添加到暂存区后，又作了修改–就回到添加到暂存区后的状态。 git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 常用命令个人常用命令，整理到一块，以后忘记了就直接复制，省事也方便。 克隆仓库# 克隆仓库 $ git clone &lt;remote_repo> # 克隆仓库到指定path（path推荐相对目录） $ git clone &lt;remote_repo> -- &lt;path> # 克隆仓库指定分支 $ git clone -b &lt;branch> &lt;remote_repo> 工作区暂存区文件管理# `git restore` v2.23.0 支持 # 清除工作区指定路径(&lt;path>)下的所有文件修改（重置文件） / 重置未暂存的文件 $ git checkout -- &lt;path> # or $ git restore -- &lt;path> # 清空暂存区指定路径(&lt;path>)文件（不重置修改）/ 取消已暂存文件 $ git reset -- &lt;path> # or $ git restore --staged -- &lt;path> # 清空工作和暂存区的所有更改（重置本次提交，不会处理untracked files） $ git reset HEAD --hard # 删除 untracked files(-f) 包括目录(-d) $ git clean -fd 比对文件# 比较暂存区和工作区的差异 $ git diff # 比较暂存区和工作区和的差异 $ git diff -- #比较上一次提交和工作区和的差异 $ git diff HEAD -- # 比对指定路径（&lt;path>）文件和暂存区的区别 $ git diff &lt;commit> -- &lt;path> # 比对已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异 $ git diff --cached $ git diff --staged # 比对指定路径（&lt;path>）两次提交 $ git diff &lt;old_hash> &lt;new_hash> -- &lt;path> # 比对指定路径（&lt;path>）旧提交与已暂存的变动(未暂存的变动将忽略） $ git diff &lt;old_hash> --staged -- &lt;path> # 比对指定路径（&lt;path>）旧提交与当前工作区的变动（包括已暂存未暂存） $ git diff &lt;old_hash> -- &lt;path> # 比对行改动，不显示具体内容 $ git diff --stat 提交文件# 全部暂存并提交 $ git commit -am \"commit log\" # 多行插入空行提交 $ git commit -m '1.line-1' - m '2.line-2' # 多行提交 $ git commit -m ' 1. line-1 2. line-2 ' # 修改上一次提交信息 $ git commit --amend -m \"New commit message\" 工作日志# 简化工作日志 $ git log --pretty=oneline # 查看分支合并情况 $ git log --graph # 查看分支合并情况，简化提交信息、hash简写 $ git log --graph --pretty=oneline --abbrev-commit # 美化输出、查看分支合并情况、简化提交信息、hash简写 $ git log --color --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset' --graph --abbrev-commit 分支# 查看本地分支 $ git branch # 查看本地分支简单信息（分支名 最后一次commit id， commit message） $ git branch -v # 查看所有分支信息（本地还有远端) $ git branch -a # 查看本地跟踪远端分支情况 $ git branch -vv # 组合使用 -vv -v -a $ git branch -vv -v -a $ git branch -vvav # 重命令分支 $ git branch -m &lt;old_name> &lt;new_name> # 切换分支 $ git checkout &lt;branch> # 指定提交检出新分支 $ git checkout &lt;hash> -b &lt;branch_name> # 拉取远端分支到本地新分支，并自动切换到此分支 $ git checkout -b &lt;new_branch> &lt;remote>/&lt;branch> # 拉取远端分支到本地新分支 $ git branch &lt;new_branch> &lt;remote>/&lt;branch> # 合并分支 $ git merge &lt;branch> 远端# 远端版本信息 $ git remote -v # 添加git远端仓库 $ git remote add &lt;name> &lt;url> # 更改远端地址 $ git remote set-url &lt;name> &lt;new_url> # 拉取远端分支提交 $ git pull origin master # 推送远端分支提交 $ git push origin master # 拉取远端分支到本地新分支 $ git checkout -b &lt;new_branch> &lt;remote>/&lt;branch> # 删除远端分支 $ git push &lt;remote> -d &lt;branch> 贮藏# 快速贮藏 git stash # 指定信息贮藏 git stash \"...\" # 查看贮藏列表 git stash list # 查看指定贮藏改动（文件，行改动） git stash show [index] # 查看指定贮藏改动（文件具体内容） git stash show -p [index] # 应用并删除贮藏（不太建议使用） git stash pop [index] # 应用贮藏 git stash apply [index] # 删除贮藏 git stash drop [index] 配置# 查看全局配置列表 $ git config --global --list # 查看本地仓库配置列表 $ git config --local --list 其他# 命令历史 $ git reflog # 变基 $ git rebase -i skill一些简简单单的小技巧。 忽略文件&#x2F;目录根目录创建.gitignore文件。 windows系统需使用命令行创建，打开cmd，定位。 > type nul > .gitignore .gitignore文件添加需要忽略的文件&#x2F;目录即可。 一般不需要自己编辑，github官方也提供了不同语言的.gitignore 传送门 提交空目录创建 .gitkeep 文件，内容如下 # Ignore everything in this directory * # Except this file !.gitkeep 别名GIt 支持为命令自定义别名，比如我们希望全局设置 git br 映射为 git branch，仓库设置 git st 映射为 git status，我们可以在终端这样配置。 # 配置别名 git config --global alias.br branch git config --local alias.st status 现在就可以使用git br 、git st了，不过git st是仓库级别的设置，切换到其他仓库就无效了。我不需要省敲几个键，这样子的映射对我无效，我需要映射的是一些很长难输入又实用的命令。我们先删除它，再配置我自己偏好的别名。 # 删除别名 git config --global --unset alias.br git config --local --unset alias.st 我们本地还有全部的别名都被删除了，当然你也可以直接修改配置文件，但是不推荐。 git config --global alias.logs \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset' --abbrev-commit\" git config --global alias.detail-log \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset' --abbrev-commit\" 现在git logs 还有git detail-log都可以输出漂亮的git日志 :-) 速查表","categories":[{"name":"git","slug":"git","permalink":"https://screw-hand.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://screw-hand.com/tags/git/"}]},{"title":"vue技巧篇：生命周期","slug":"lifecycle","date":"2020-01-25T14:17:01.000Z","updated":"2024-03-17T09:23:23.076Z","comments":true,"path":"/post/lifecycle/","link":"","permalink":"https://screw-hand.com/post/lifecycle/","excerpt":"前言 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 其实对生命周期而言，我们要搞懂的是。 什么阶段初始化数据 什么阶段初始化事件 什么阶段渲染DOM 什么阶段挂载数据","text":"前言 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 其实对生命周期而言，我们要搞懂的是。 什么阶段初始化数据 什么阶段初始化事件 什么阶段渲染DOM 什么阶段挂载数据 生命周期图示 生命周期钩子函数可以分成6个类型，除了一个最少用的子孙组件错误钩子函数。每个类型都有 “beforeXX” “XXed”，总共有11个生命周期钩子函数。 序 类型 钩子函数名 - 1 钩子函数名 - 2 1 创建 beforeCreate created 2 挂载 beforeMount mounted 3 更新 beforeUpdate updated 4 销毁 beforeDestroy destroyed 5 激活 activated deactivated 6 错误 errorCaptured \\ 生命周期钩子官方api 传送门 别看有11个钩子函数，看似一时间难以掌握。其实也不是很需要全部掌握，常用的就那么几个。这几个钩子函数会一一介绍，也会先大家演示一遍完整的生命周期。且实际开发中我们更在意的是，这些钩子函数对组件实例数据&#x2F;事件的影响。 完整的生命周期这一章基本是在翻译生命周期图示的内容。不过很多开发者都对完整的生命周期流程一知半解。虽然提供源码，还是建议每个人按照自己的理解写一下实例。 新建lifecycle目录，定义lifecycle.vue，导入process.vue &lt;!-- lifecycle.vue --> &lt;template> &lt;lifecycle-process>&lt;/lifecycle-process> &lt;/template> &lt;script> import LifecycleProcess from './process' export default &#123; components: &#123; LifecycleProcess &#125; &#125; &lt;/script> 我们在process.vue体现完整的生命周期。 虽然官网的示例都是new Vue() 初始化vue实例。单文件组件(*.vue)使用export default也同样是初始化vue实例。 这里有几个概念： 数据观测 (data observer) : prop， data， computed 事件机制 (event &#x2F; watcher)： methods 函数， watch侦听器 我们只简单搞清楚每个阶段发生了什么事情。其他还没有开始做的事情不想提及。毕竟未开始也未完成，默认就是还没初始化嘛，有什么好说的呢？ create本小节标题是create，是指vue实例的create阶段。不是生命周期钩子函数 beforeCreate &#x2F; created。 我们不打算从生命周期的钩子函数作为切入点。只要搞清楚了vue实例xx阶段做了什么事情，那beforeXX &#x2F; XXed 的区别自然知晓。 我们也根据官方api的资料来表述，实例阶段做了什么事情。 实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch&#x2F;event 事件回调。 那我们应该定义 prop， data， computed methods watch，然后使用beforeCreate， created前后对比一下。 // process.vue export default &#123; // prop， data， computed methods watch // 自行定义，这里不浪费篇幅 props: &#123;&#125;, data () &#123; return &#123; msg: 'Hey Jude!' &#125; &#125;, methods: &#123;&#125;, watch: &#123;&#125;, beforeCreate () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'beforeCreate--实例创建前状态') console.log(\"%c%s\", \"color:skyblue\", \"$props :\" + this.$props) console.log(\"%c%s\", \"color:skyblue\", \"$data :\" + this.$data) console.log(\"%c%s\", \"color:skyblue\", \"computed :\" + this.reverseMsg) console.log(\"%c%s\", \"color:skyblue\", \"methods :\" + this.reversedMsg) // this.msg = 'msg1' &#125;, created () &#123; console.log(\"%c%s\", \"color:red\", 'created--实例创建完成状态') console.log(\"%c%s\", \"color:skyblue\", \"$props :\" + this.$props) console.log(\"%c%s\", \"color:skyblue\", \"$data :\" + this.$data) console.log(\"%c%s\", \"color:skyblue\", \"computed :\" + this.reverseMsg) console.log(\"%c%s\", \"color:skyblue\", \"methods :\" + this.reversedMsg()) // this.msg = 'msg2' &#125; &#125; prop， data， computed， methods， watch。除了watch比较特殊，其他都得到了验证效果。要验证也很简单，取消 beforeCreate， created 对 this.msg赋值的注释。watch msg 看看控制台会打印msg1还是msg2，或者两者皆可。聪明的你肯定知道控制台只打印msg2的，所以我就不取消注释了。 mount el 被新创建的 vm.$el 替换。 如果根实例挂载到了一个文档内的元素上，当mounted被调用时vm.$el也在文档内。 &lt;template> &lt;div class=\"skill-lifecycle-process\"> &#123;&#123; msg &#125;&#125; &lt;/div> &lt;/template> export default &#123; beforeMount () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'beforeMount--挂载之前的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\",this.$el) &#125;, mounted () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'mounted--已经挂载的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\", this.$el) &#125; &#125; mount阶段，由于vue支持多种方式挂载DOM。而vue实例在created之后，beforeMounted之前这一阶段，对挂载DOM的方式有判断机制，这里的流程稍微复杂也比较重要。 多种挂载DOM的方式。 el &#x2F; $mout template render 这里打算分别使用n个组件对着这几种挂载方式。你可以选择暂时跳过，先走完整个周期流程再回来。 create mount是每个组件都必须经历的生命周期，但接下来的生命周期就比较有选择性了。 下一实例阶段 update 这里会按照判断机制的顺序介绍不同的挂载方式。 el &#x2F; $mount首先会判断有无el选项声明实例要挂载的DOM。 el选项：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。 如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。 el选项需要使用显示使用new创建的实例才生效。为了方便，这里新建了skill-lifecycle-el.html放在public（静态资源目录）下。 &lt;!-- skill-lifecycle-el.html --> &lt;body> &lt;div id=\"app\"> &lt;p>&#123;&#123; msg &#125;&#125;&lt;/p> &lt;p v-text=\"msg\">&lt;/p> &lt;/div> &lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.min.js\">&lt;/script> &lt;script> window.onload = function() &#123; var vm = new Vue(&#123; el: '#app', props: &#123;&#125;, data () &#123; return &#123; msg: 'Hey Jude!' &#125; &#125;, computed: &#123;&#125;, methods: &#123;&#125;, watch: &#123;&#125;, beforeMount () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'beforeMount--挂载之前的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\",this.$el) console.log(\"%c%s\", \"color:skyblue\", \"el :\" + this.$el.innerHTML) // debugger &#125;, mounted () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'mounted--已经挂载的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\", this.$el) console.log(\"%c%s\", \"color:skyblue\", \"el :\" + this.$el.innerHTML) &#125; &#125;) // vm.$mount('#app') &#125; &lt;/script> &lt;/bdoy> el 还有 vm.$mount 必须要有一个，不然vue的声明周期就停止，beforeMount不触发。 vm.$mount 手动地挂载一个未挂载的实例。 两种挂载方式的效果是一样的。 值得注意的是，beforeMount真实的DOM确实是会渲染双花括号还有指令的，mounted之后会被替换成真正的数据。 template判断完el选项，接下来会判断有无template选项 一个字符串模板作为 Vue 实例的标识使用。模板将会替换挂载的元素。 如此说来，作用跟el选项差不多，都是挂载元素的。 那我们声明template选项，写上html tag string，然后把#app DOM里面的内容注释掉。（DOM保留） &lt;!-- skill-lifecycle-template.html --> &lt;!-- \"#app\" DOM --> &lt;div id=\"app\"> &lt;!-- &lt;p v-text=\"msg\">&lt;/p> &lt;p>&#123;&#123; msg &#125;&#125;&lt;/p> --> &lt;/div> &lt;script> new Vue(&#123; el: '#app', template: '&lt;b> &#123;&#123; msg &#125;&#125;&lt;/b>', // template 选项 beforeMount () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'beforeMount--挂载之前的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\",this.$el) // debugger &#125;, mounted () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'mounted--已经挂载的状态') console.log(\"%c%s\", \"color:skyblue\", \"$el :\", this.$el) console.log(\"%c%s\", \"color:skyblue\", \"#app :\", document.querySelector('#app')) &#125; &#125;) &lt;/script> 我们在挂载后找一下#app还在不在。 从这图，我们可以知道： vm.$el在beforeMount反应的是el选项的#app DOM（此时#app DOM还是模板状态） 很明显，template选项把el选择的#app给替换掉了，故**template选项的优先级比el选项&#x2F;vm.$mount()高**。 el选项：比较温和，只是霸占人家的屋子自己住在里面。template选项：直接端掉人家的老窝，自己筑新巢。 renderrender选项是一个渲染函数，返回虚拟节点 (virtual node），又名VNode。 render函数的用法稍微复杂，又牵扯到虚拟DOM、JSX等技术点，之后会另写一篇详细讲解。 假设我们现在并不明白render的用法，只知道它会返回虚拟节点，就够了。 &lt;!-- skill-lifecycle-template.html --> &lt;script> new Vue(&#123; el: '#app', template: '&lt;b> &#123;&#123; msg &#125;&#125;&lt;/b>', // template 选项 render: function (createElement, context) &#123; return createElement('b', this.msg + ' from render') &#125;, // render函数 &#125;) &lt;/script> 可以看到这里template选项我们不注释，就算我们把注释掉template选项， 输出结果也还是一样。 可以粗暴理解为：render是template的升级版，template字符串模板，render返回的是由函数创建生成的VNode。 所以通过判断机制的流程，我们也很清楚了这几种方式挂载DOM的区别。 判断有无挂载DOM：el选项或者 vm.mount()， 无则停止。 判断有无template选项，有则替换掉挂载DOM元素。 判断有无render函数，有则替换掉挂载DOM元素&#x2F;template选项。 这几种挂载方式是有优先级的，不过因为按照顺序分析，也不用特意去记，后面的会覆盖前面的。 vue不同构建版本的区别（编译器、运行时）vuejs有不同的构建版本，他们按照两个维度来分类，模块化及完整性。 模块化容易理解，这取决于使用环境的模块化机制决定。 完整性的话，引用官网资料。 完整版：同时包含编译器和运行时的版本。 编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。 运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。 什么时候必须使用完整版(编译器+运行时)？ template 选项、挂载DOM（el选项&#x2F;vm.$mount)，需要依赖编译器编译，这时必须使用完整版。 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。 可以看看三个html文件的源码引用的vue版本。 skill-lifecycle-el.html skill-lifecycle-template.html skill-lifecycle-render.html 如何选择？ 推荐运行时，拥有预编功能，性能比完整版的要好，打包资源也小；一个小代价就是不能使用template选项。完整版是在运行的时候编译，性能相对一般，而且也需要把编译器一起打包。 update 数据更改导致的虚拟 DOM 重新渲染和打补丁。 实例data属性更新将会触发update阶段，数据的值改变，才会触发，并不是每次赋值都会触发。 &lt;template> &lt;div class=\"skill-lifecycle-process\"> &lt;p>&#123;&#123; msg &#125;&#125; &lt;/p> &lt;p>&lt;button @click=\"handleClick\">update&lt;/button>&lt;/p> &lt;/div> &lt;/template> export default &#123; data () &#123; return &#123; msg: 'Hey Jude!' &#125; &#125;, methods: &#123; handleClick () &#123; this.msg = 'Hello World!' &#125; &#125;, watch: &#123; msg () &#123; console.log(this.msg) &#125; &#125;, beforeUpdate () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'beforeUpdate--数据更新前的状态') console.log(\"%c%s\", \"color:skyblue\", \"el :\" + this.$el.innerHTML) console.log(this.$el) console.log(\"%c%s\", \"color:skyblue\", \"message :\" + this.msg) console.log(\"%c%s\", \"color:green\", \"真实的 DOM 结构:\" + document.querySelector('.skill-lifecycle-process').innerHTML) &#125;, updated () &#123; console.log(\"%c%s\", \"color:orangeRed\", 'updated--数据更新完成时状态') console.log(\"%c%s\", \"color:skyblue\", \"el :\" + this.$el.innerHTML) console.log(this.$el); console.log(\"%c%s\", \"color:skyblue\", \"message :\" + this.msg) console.log(\"%c%s\", \"color:green\", \"真实的 DOM 结构:\" + document.querySelector('.skill-lifecycle-process').innerHTML) &#125; &#125; 不难看出，vue的响应式机制是先改变实例数据。此时新的实例数据并还没有挂载到DOM，只是存在于虚拟DOM(el);再通过虚拟DOM重新渲染DOM元素。 如果这个更新的数据有侦听器，侦听器会在update阶段前触发。 destroy 对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。 销毁指的是销毁vue的响应式系统，事件还有子实例。都是针对vue层面的，并非销毁DOM之意。 调用vm.$destroy()触发 传送门 调用这个实例方法后，DOM并没有什么变化。vue实例也还是存在的，只是vue的响应式被销毁。DOM与vue切断了联系。 active 被 keep-alive 缓存的组件激活&#x2F;停用时调用 这里需要在lifecycle.vue引用process.vue的地方包裹一层keepa-alive &lt;!-- lifecycle.vue --> &lt;p>&lt;button @click=\"handleClick\">toggle show&lt;/button>&lt;/p> &lt;keep-alive> &lt;lifecycle-process v-if=\"isShow\">&lt;/lifecycle-process> &lt;/keep-alive> v-if指令切换组件挂载&#x2F;移除触发；v-show指令切换组件显示&#x2F;隐藏不触发。 // lifecycle-process.vue export default &#123; // ... activated () &#123; console.log('activated') &#125;, deactivated () &#123; console.log('deactivated') &#125; &#125; 有意思的是，页面初始化的时候，activated会在mounted之后触发。 单纯的切换组件的挂载&#x2F;移除状态，activated &#x2F; deactivated 会触发；组件不会重新实例化走一遍生命周期，尽管这里用是的v-if。 而当我们destroy组件，之后的每一次切换挂载&#x2F;移除，组件都会重新实例化，我们只是第一次destroy而已。 errorCapture* 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 这个钩子函数是用来捕获错误的，而且只应用于子孙组件，实际开发中并不常用。 传送门 那么整个周期流程已经介绍完毕了，同样的提供了process.vue源码。也可以选择重新回头深入了解mount机制了。 常用生命周期函数11个钩子函数就这样介绍完了，常用的钩子函数并不多。 created此时数据&#x2F;事件可用，可以在此动态创建数据或者定义自定义事件。 export default &#123; created () &#123; this.$data.staticString = 'static' // 定义变量 this.$on('on-created', () => &#123; // 定义自定义事件 console.log(this.$data.staticString) &#125;) &#125; &#125; 注意：created创建的变量，更新不会被vue所监听。 在此处定义变量数据，是为了提升性能，如果这个变量更新与view层无关的话。 mountedDOM渲染完毕，可以执行页面的初始化操作（移除遮罩），获取DOM（如果有必要的话）。 export default &#123; mounted () &#123; this.init() console.log(this.$refs.controlPanel.$options.name) &#125; &#125; vue 并不推荐直接操作DOM，不过还是提供了$ref作为应急解决方案。 useful.vue写的比较简单。 结语然而， 本篇的内容仅仅讨论的是vue组件的生命周期相关钩子函数。路由守卫，自定义指令，多个组件引用的钩子函数这些并未提及，推荐几篇文章。看完相信能收获得更多。 vue 生命周期深入 针对多个组件引用情况（父子、兄弟组件）等情况生命周期的执行顺序 vue生命周期探究（一） 包括组件、路由、自定义指令等共计28个的生命周期 vue生命周期探究（二） 路由导航守卫的钩子函数执行顺序","categories":[{"name":"vue","slug":"vue","permalink":"https://screw-hand.com/categories/vue/"}],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://screw-hand.com/tags/vue-skill/"}]},{"title":"vue技巧篇：组件通讯","slug":"component-communication","date":"2020-01-24T12:05:19.000Z","updated":"2024-03-17T09:23:22.996Z","comments":true,"path":"/post/component-communication/","link":"","permalink":"https://screw-hand.com/post/component-communication/","excerpt":"前言组件化也是vue的一大特点之一，组件是组成vue项目的基本单位。一个组件可以做什么？ 这取决于组件的设计，组件一般由以下几点组成： 选项 实例属性&#x2F;方法 生命周期 全局API 指令 导入的其他组件 组件是可复用的vue实例，可以复用，导入导出，组成组件化系统。 vue的组件都是保持相对独立的关系，可是又可以进行相互依赖（导入导出机制）；这种规范下，实际开发又难免会出现组件之间传递数据、转发事件的场景。而vue又对组件间的数据、事件做了一定的限制；正因如此，我们需要好好探讨vue的组件通讯。","text":"前言组件化也是vue的一大特点之一，组件是组成vue项目的基本单位。一个组件可以做什么？ 这取决于组件的设计，组件一般由以下几点组成： 选项 实例属性&#x2F;方法 生命周期 全局API 指令 导入的其他组件 组件是可复用的vue实例，可以复用，导入导出，组成组件化系统。 vue的组件都是保持相对独立的关系，可是又可以进行相互依赖（导入导出机制）；这种规范下，实际开发又难免会出现组件之间传递数据、转发事件的场景。而vue又对组件间的数据、事件做了一定的限制；正因如此，我们需要好好探讨vue的组件通讯。 父子组件通讯由于组件通讯，有时候是为了传递数据，而有时候是为了转发事件；这里不对这两种场景做区分，统一要解决的场景为“组件通讯”。 其实vue组件通讯并不复杂，官方文档提供了几个方法。 props 向子组件传递数据 传松门 emit 向父组件抛出事件 传送门 v-model 父子组件数据同步（带有一定的抛出事件机制） 传送门 props+sync修饰符 传松门 slot-scope 作用域插槽 传送门 由于官方文档介绍得很详细，也提供了传送门，具体实现并不详细介绍。不过vue组件有一个设计概念还是有大家了解下的——单向数据流 传送门 单向数据流 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 而如果需要改变父组件的数据，则子组件抛出事件；父组件定义自定义事件，在自定义事件中改变自己的数据。 这些方法有所缺点，不同的业务场景需要开发者自行衡量；不过适应的业务场景都局限于父子组件的通讯。 其实父子组件通讯的是最好解决的，毕竟有直接联系。 非父子组件通讯由于非父子组件没有直接联系，只能使用间接联系。两个组件使用相同的“代理“，由”代理“转发数据或者事件的交互。 ”代理“各式各样，也有不同的实现方式。 备注：这里的“代理”是中转站的意思，为了方便理解，表述为：“代理”。 官方也提供几种解决方案： $root.data 传送门 vuex 传送门 vue-router 传送门 $root.data我们知晓：一个vue项目由组件为单位组成。但是，一个vue项目只有一个根组件。且所有组件实例均可访问根组件实例this.$root。官方文档也提供了相应的实现方式传送门。 实际开发中，并不使用这种方式进行组件通讯。我们并不希望$root.data 挂载庞大的数据变量。我们仅希望他只负责渲染HTML DOM元素。 vuexvuex专用于vue项目，作为状态管理模式插件。（理解为集中存储全局变量的地方就好了。） 前面说到“单向数据流”理念，并不适用多个组件共享状态场景。 因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。 vuex的核心是store（仓库），”store”是一个容器，包含应用中大部分的状态(state)，与单纯的全局对象有两点不同： Vuex 的状态存储是响应式的。 不能直接改变 store 中的状态，若想改变，唯一途径就是显式地提交 (commit) mutation。 一个store可以包含state：储存状态 单一状态树action： 提交mutation方法，可执行异步操作mutation：更改store状态，必须是同步操作getter：从state派生状态，返回值会根据依赖缓存modules：将store分割成模块 简单分析下这张图： State 直接渲染在vue组件 组件可以可以通过Dispatch触发 Actions Actions可以Commit触发Mutations Mutations可以Mutate更改State vue组件计算属性更新State的值 还有几个注意点： vuex的范围：组件外部的 State &#x3D;&gt; Actions &#x3D;&gt; Mutations &#x3D;&gt; State Actions、Mutations： Actions可以执行异步（一般用于后端Api交互）、Commit Mutations；Mutations必须是同步，（一般用于更改State状态） 执行顺序：组件也可以跳过Actions 直接 Commit Mutations， 不过执行顺序是不可逆的。 Actions是可以Dispatch 其他Actions的，同理一个Actions也可以Commit 多个Mutations vue-routervue-router也可以拥有组件通讯的能力，不过这些组件针对的是直接挂载在路由的页面组件。 路由元信息 传送门 路由组件参数 传送门 导航守卫 传送门 $route.query 传送门 总线模式（bus）总线模式需要实例化一个空Vue实例，我们把非父子组件的事件统一集中到这个空Vue实例，让这个实例监听，触发这些自定事件就可以。 Vue 其实是一个构造函数，既然是构造函数，那就可以多次实例化。而构造函数又有原型对象prototype，原型就是为了共享。 那第一步我们可以在Vue的原型对象上实例化一个空Vue实例。 Vue.prototype.bus = new Vue() 备注：如果是大规模使用，可以在main.js直接定义原型bus属性。局部使用可以包装成一个js模块，需要时引入即可。 再看实例事件 vm.$on vm.$emit 我们可以知晓：$emit 会触发 $on 就可以了。 准备一个文件夹 bus，定义三个组件: bus.vue bus-child1.vue bus-child2.vue 我们要做的是让child1触发child2事件。 &lt;!-- bus.vue 引入 child1, child2· --> &lt;bus-child1 content=\"skill-bus-child1\">&lt;/bus-child1> &lt;bus-child2 content=\"skill-bus-child2\">&lt;/bus-child2> // bus-child1.vue export default &#123; // ... methods: &#123; handleClick () &#123; this.bus.$emit('on-change', this.selfContent) &#125; &#125; &#125; // bus-child2.vue export default &#123; methods: &#123; handleChange ($event) &#123; this.selfContent = $event &#125; &#125;, mounted () &#123; this.bus.$on('on-change', this.handleChange) &#125; &#125; bus.vue 源码 然而总线模式还是有带来一定的作用域问题，由于非父子组件的事件统一集中到空Vue实例，这导致了这些被空vue实例监听的自定义事件，在所有的组件是共享的，这种情况下，很容易产生副作用。 若再增加一个bus-child3.vue，它也监听了this.bus.$on(&#39;on-change&#39;, this.handleChange)。而其实我们并不想bus-child3.vue响应 bus-child1.vue事件。 说白了就是作用域太广，bus是全局作用域；又或者说没有命令空间，相同的事件名不能在两个组件定义。 其实这种解决方案之于$root.dat是换汤不换药的，都是把不同组件的数据&#x2F;事件集中到一个vue实例。 emitter (dispatch &#x2F; broadcast)如果两个组件，有相同的父组件，可以使用事件派发与广播机制处理非父子组件通讯。其实都会有相同的父组件的，再不济最顶层就是vue的根实例了，不过一般不需要到根实例。 派发&#x2F;广播机制很依赖组件层级关系。派发(dispatch):由本组件向上派发事件，供上层组件监听处理。广播(broadcast)：由本组件向下广播事件，供下层组件监听处理。 Element UI 框架源码的emitter.js就是基于派发广播机制处理非父子组件的通讯。源码的emitter.js把其机制封装成了一个独立的mixin，以便在各个组件方便使用。这里就以emitter.js为例子，简单讲解是如何实现的，还有如何使用这个mixin。 // 简化emitter.js, 只提取出结构 function broadcast (componentName, eventName, params) &#123; // ... &#125; // 标准mixins结构 export default &#123; methods: &#123; // 定义dispatch方法，需要三个参数 // @params componentName 派发给哪个上层组件 // @params eventName 派发的事件名 // @params params 事件携带参数 dispatch (componentName, eventName, params) &#123;&#125;, // 定义broadcast方法，需要三个参数 // @params broadcast 广播给哪个下层组件 // @params eventName 广播的事件名 // @params params 事件携带参数 broadcast (componentName, eventName, params) &#123;&#125; &#125; &#125; componentName 指的是定义组件时，组件的选项name 传送门 export default &#123; name: 'component-name' &#125; 跟总线模式一样，我们也要定义一个文件夹——emitter，三个组件 emitter.vue child1.vue child2.vue 同样让child1触发child2事件。 &lt;!-- emitter.vue 引入 child1 child2 --> &lt;emitter-child1 content=\"emitter-child1\">&lt;/emitter-child1> &lt;emitter-child2 content=\"emitter-child2\">&lt;/emitter-child2> 这里child1,child2是兄弟组件，他们共同拥有父组件emitter.vue。所以child1要触发child2事件，需要emitter.vue的帮助。 child1派发事件到emitter.vue emitter定义监听事件，广播到child2 child2定义监听，接收emitter的广播事件 // child1.vue 派发事件到 emitter.vue import Emitter from '@/mixins/Emitter' export default &#123; mixins: [ Emitter ], methods: &#123; handleClick () &#123; this.dispatch('skill-emitter', 'on-child1-change', this.selfContent) &#125; &#125; &#125; // emitter.vue 定义监听事件，广播到 child2.vue import Emitter from '@/mixins/emitter' export default &#123; mixins: [ Emitter ], created () &#123; // 代理child1派发的on-child1-change事件 // 该事件不在此组件处理 // 广播给child2的on-change事件处理 this.$on('on-child1-change', e => &#123; this.broadcast('skill-emitter-child2', 'on-change', e) &#125;) &#125; &#125; // child2.vue 定义监听，接收 emitter.vue 的广播事件 export default &#123; methods: &#123; handleChange ($event) &#123; this.selfContent = $event &#125; &#125;, created () &#123; this.$on('on-change', this.handleChange) &#125; &#125; emitter.vue 源码 派发&#x2F;广播机制对比总线模式，限制了事件必须是具体的某个组件的，使得事件的传递更加精确可控。 emitter.vue 是兄弟组件实例，如果是上下层的组件。不需要经过如emitter.vue的代理，直接在目标组件监听自定义事件。 不管是dispatch还是broadcast方法，都很依赖componentName，还有eventName，所以良好的命名规范是非常重要的，dispatch&#x2F;broadcast到指定的组件的xx事件。该指定的组件this.$on监听自定义事件就可以触发。 结语今天我们从组件通讯的解决方式出发，介绍到了多种组件通讯的解决方案。以前觉得组件通讯无非就是这几种。 prop &lt;&#x3D;&gt; emit vuex bus dispatch &#x2F; broadcast 好好的梳理出来才发现其实在很多场景我们都需要用到组件通讯。只是我们太过习以为常，反而有点忽略了也是其解决方案之一。 在实例开发中，我们也需要结合实际场景思考，是否以上的解决方案是否适用。 一般情况下，我是支持使用dispatch&#x2F;broadcast模式去处理大多数的非父子组件通讯的。可有时候要一个组件触发各自触发n个组件的事件，这种模式可能编写起来比较繁琐。这个时候可以考虑总线模式，又或者，为了一处比较特殊的处理，是否考虑要引入一个mixins。这些问题都是需要开发者是在实际开发的时候好好去估量利弊的，并没有一种万能的解决方案。（对我来讲，dispatch&#x2F;broadcast 就已经很万能了。） 还有这里想吐槽一下。 Flux 架构就像眼镜：您自会知道什么时候需要它 。–Dan Abramov (Redux 的作者) 说真的，直到现在我完全不能理解这句充满诗意的话，以及为什么偏偏是像眼镜而不是心灵的窗户？！","categories":[{"name":"vue","slug":"vue","permalink":"https://screw-hand.com/categories/vue/"}],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://screw-hand.com/tags/vue-skill/"}]},{"title":"vue技巧篇：自定义双向绑定","slug":"two-way-binding","date":"2020-01-20T09:57:01.000Z","updated":"2024-03-17T09:23:23.104Z","comments":true,"path":"/post/two-way-binding/","link":"","permalink":"https://screw-hand.com/post/two-way-binding/","excerpt":"前言双向绑定 是 vue 的一大特点之一，使用也非常方便。在需要双向绑定的表单控件元素使用指令 v-model即可。 官方文档教程 —— 表单输入绑定（传送门）官方文档api —— v-model 指令（传送门） 注意了：到目前为止，双向绑定只是针对表单控件元素，并没有说明其他DOM元素，或者是自定义组件。 那我们要如何实现在组件（或者说其他DOM元素）的双向绑定呢？ &lt;base-components v-model=\"fieldValue\">&lt;/base-components>","text":"前言双向绑定 是 vue 的一大特点之一，使用也非常方便。在需要双向绑定的表单控件元素使用指令 v-model即可。 官方文档教程 —— 表单输入绑定（传送门）官方文档api —— v-model 指令（传送门） 注意了：到目前为止，双向绑定只是针对表单控件元素，并没有说明其他DOM元素，或者是自定义组件。 那我们要如何实现在组件（或者说其他DOM元素）的双向绑定呢？ &lt;base-components v-model=\"fieldValue\">&lt;/base-components> v-model 浅析 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 节选几段官方文档的资料，不难察觉v-model 会占用一个 prop 属性和一个 $emit 事件。如果有冲突，也是可以更改的。 如果还是好奇 v-model的实现原理，我可以告诉你大概是这样。 双向绑定基于getter&#x2F;setter 结合观察者模式实现getter&#x2F;setter指Object.defineProperty遍历vue实例的data选项观察者模式是js的一种设计模型，可以实现发布订阅功能 组件使用双向绑定（基本类型版） 有了相应的资料，我们可以开工了。准备一个组件 base-input.vue export default &#123; name: 'base-input', props: &#123; value: &#123; type: String, default: '' &#125; &#125;, data () &#123; return &#123; fieldValue: this.value // 初始化赋值 &#125; &#125;, watch: &#123; value (newVal) &#123; this.fieldValue = newVal // 监听props（外部）更新，赋值给data（内部） &#125;, fieldValue () &#123; this.$emit('input', this.fieldValue) // data（内部）更新，抛出到外部 &#125; &#125; &#125; &lt;input type=\"text\" v-model=\"fieldValue\"> 有几个注意点要说明下： fieldValue 必须初始化赋值为 props 的 value 初始化页面时 watch 并不执行 内部更新，触发 fieldValue 监听函数 外部更新，触发 value监听函数 base-input 源码 传送门 示例 传送门 :value 与v-model因为之前被这两个搞混过，不明白之间的联系和区别，这里单独拿出来讲一下。 :value 是绑定一个prop value 给组件，实现外部数据传入内部， 单向绑定 v-model 是双向绑定，默认占用prop value 属性和一个 $emit input 事件;在:value 的基础上$emit input实现内部数据抛出外部，从而外部、内部数据达成同步且外内均可更改。 把 base-input v-model=&quot;inputValue&quot;&gt;&lt;/base-input&gt; 换成 :value=&quot;inputValue&quot;试试？ 我们也将在下一节更改指令默认使用的prop 属性 和$emit 事件 可其实这种方式只支持js的基本类型，像对象或者数组的引用类型，这样处理是不够的，所以我们需要对现有的双向绑定方式进行升级。 组件使用双向绑定（引用类型版）准备另一个组件：base-div.vue 把base-input.vue 的代码复制过来，组件名，类名什么的这些标识信息该改的就改一改。 然后可能有的朋友到这里会把 prop value 的 type 改成 Object，这只是第一步而已。 因为引用类型的特性，我们手动给内部变量赋值，会更改其引用地址，故相当于重新初始化了一个变量。这里会触发另一个watch函数，而另一个watch也具备给内部变量赋值的能力； 如果不特殊处理，这两个watch 函数触发其中一个，就会不断调用另一条，造曾死循环。所以我们需要判断当内外部变量相等的时候，就不赋值了。嗯，判断两个对象相等。 判断两个对象相等可能有点尴尬， 那我们把两个对象序列化为JSON 字符串就可以了。 JSON.stringify(obj1) === JSON.stringify(obj2); 技术点已经准备够了，我们足够实现用v-model绑定一个对象了。 export default &#123; props: &#123; value: &#123; type: [ Object, Array] &#125; &#125;, data () &#123; return &#123; fieldValue: this.value, fieldValueStringify: JSON.stringify(this.value) // 保存外部传入的变量快照，将在监听器中做比较使用 &#125; &#125;, watch: &#123; value: &#123; deep: true, // 深度监听 handler (newVal) &#123; const currentValue = JSON.stringify(newVal) // 外部传入的变量与内部变量比较 // 不相等，内部变量方可赋值为this.value // * 内部变量赋值，将会触发fieldValue监听函数 // 且此时应更新fieldValue 对象字符串快照 if (currentValue !== this.fieldValue) &#123; this.fieldValue = JSON.parse(currentValue) this.fieldValueStringify = currentValue &#125; &#125; &#125;, fieldValue: &#123; deep: true, // 为什么要使用深度监听呢？ handler (newVal) &#123; // 自己改变内部变量，或者因外部变量更新手动赋值内部变量 // 这个函数都会被触发 // 要实现的是内部与外部变量同步，所以快照才是保存外部变量 // 1.当外部变量改动，会先调用 watch value，此时内外部变量同步 // 这时不需要抛出事件，否则出现死循环 // 2.当内部变量改动，会先调用 watch fieldValue // 抛出事件，外部的v-model又会自动更新内部的value // 从而触发 watch value // （这里触发watch value了，可以回去看看1） // 如果你不会兜兜转，那我想你应该feel到了整个更新流程 // **如果被兜住了，先理解外部变量的改动，再理解内部变量的改动 const currentValue = JSON.stringify(newVal) if (currentValue !== this.fieldValueStringify) &#123; this.$emit('input', JSON.parse(currentValue)) &#125; &#125; &#125; &#125; &#125; base-div 源码 传送门 示例 传送门 接下来我们不使用 prop value $emit input了，我们使用 prop insert $emit output。 直接在base-div 改动吧，其实也不复杂。 export default &#123; model: &#123; prop: 'insert', event: 'output' &#125;, props: &#123; insert: &#123; type: [Object, Array] &#125; &#125;, data () &#123; return &#123; fieldValue: this.insert, fieldValueStringify: JSON.stringify(this.insert) // 保存外部传入的变量快照，将在监听器中做比较使用 &#125; &#125;, watch: &#123; insert: &#123; // ... &#125;, fieldValue: &#123; // ... this.$emit('output', JSON.parse(currentValue)) &#125; &#125; &#125; 然后在外部使用 @output 的时候，会发现外部更新不触发 output 事件。刚开始以为组件实现还是有问题，后面想想不对，外部更新没必要抛出事件。外部更新，可以在外部使用 watch 函数，这里确实不管内部组件的事情了。 &lt;base-div v-model=\"formValue\" @output=\"handleOutput\">&lt;/base-div> 最后今天我们重新了解了 v-model 只针对于表单控件数据的双向绑定，并且会默认占用一个属性和一个事事件。也通过v-model，我们得以在自己的组件实现双向绑定，基本类型和引用类型的处理机制也不太一样。 工作中也经常用到这种需要自定义双向绑定的场景，有时候写得次数太多，就想着能不能抽象出来复用。想想 mixins ， extend 都不太适合，因为会固定占用prop data 事件， 容易起冲突。目前觉得指令可以一试，不过还需要好好研究一下，希望下次的更新能定义一条全局指令——base-model。","categories":[{"name":"vue","slug":"vue","permalink":"https://screw-hand.com/categories/vue/"}],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://screw-hand.com/tags/vue-skill/"}]},{"title":"vue技巧篇：我的浏览器也是“控制台”","slug":"control-pane","date":"2020-01-17T05:39:38.000Z","updated":"2024-03-17T09:23:23.000Z","comments":true,"path":"/post/control-pane/","link":"","permalink":"https://screw-hand.com/post/control-pane/","excerpt":"前言写代码少不了，调试最简单方便的方法是控制台输出信息，如js的 control.log。可有时候我们要监听的变量是改动频繁，可能要多次使用control.log，控制台信息太多看得也容易乱。有一次查阅资料的时候，看到其他开发者使用pre标签直接在页面上打印变量，突然受到了一点感悟。 pre 和 $datahtml的pre标签并不常用，它可以保留原格式（空格和换行符），常用于表示源代码。有了pre我们很容易在页面上输出源码。此外，还需要vue的声明式渲染 —— ｛｛ x ｝｝ 或者是 v-text 指令。以及 vue 的 $data 实例属性，其实引用的是data对象属性的访问。 附：博客系统，不支持双括号，这里用 v-text代替，大部分情况下两者可以互换 说了那么多，其实只需要&lt;pre v-text=&quot;$data&quot;&gt;&lt;/pre&gt;,这一行就够了。好的，今天就到这里，大家再见。 …","text":"前言写代码少不了，调试最简单方便的方法是控制台输出信息，如js的 control.log。可有时候我们要监听的变量是改动频繁，可能要多次使用control.log，控制台信息太多看得也容易乱。有一次查阅资料的时候，看到其他开发者使用pre标签直接在页面上打印变量，突然受到了一点感悟。 pre 和 $datahtml的pre标签并不常用，它可以保留原格式（空格和换行符），常用于表示源代码。有了pre我们很容易在页面上输出源码。此外，还需要vue的声明式渲染 —— ｛｛ x ｝｝ 或者是 v-text 指令。以及 vue 的 $data 实例属性，其实引用的是data对象属性的访问。 附：博客系统，不支持双括号，这里用 v-text代替，大部分情况下两者可以互换 说了那么多，其实只需要&lt;pre v-text=&quot;$data&quot;&gt;&lt;/pre&gt;,这一行就够了。好的，今天就到这里，大家再见。 … 编写样式如果只是简单的方便调试，确实只需要上面一行代码就够了。只是本着折腾的命，觉得可以设计成一个组件，进行复用。就算设计成一个组件，实用性的不大，趣味性要多过实用性吧。 如果在实际开发中，直接单纯只写一行，调试使用的pre可能会被其他DOM元素的样式所铺盖。所以在编写组件前可以给这个pre写一点样式，先开头说的代码吧。 &lt;template> &lt;pre v-text=\"$data\">&lt;/pre> &lt;/template> &lt;script> import Package from '@/../package.json' export default &#123; name: 'views-skill-control-panel', data () &#123; return &#123; strong: '&lt;strong>I \\'m strong&lt;/strong>', debugger: true, arr: [1,2,3,4,5], package: Package &#125; &#125; &#125; &lt;/script> 可能比官网入门实例还要简单，唯一有疑问的可能也就是 import 一个 json 文件进来， 这在es6 Modules中是允许的，相关资料请自行查阅。 ok，先看html部分，再看css。 html中，把data的属性都渲染到DOM上，并且html实体不会被转义，（v-text的功劳）。数组、对象也全被展开，不像在浏览器控制台是默认闭合的，而且key值也被加上双引号，这是JSON的格式。 内容上看非常友好，样式因为没写，非常朴素，但我们也不追求美感，能看就行，这里有几个因素影响了观看。 内容过长，高度容易溢出 默认定位，容易被其他元素遮挡 透明背景，深色背景观看费劲 字体样式会被通用样式影响 其实以上问题都是其他DOM元素影响pre的阅读观看，我们要固定，或者说通配一下pre的样式。让其在不同色彩表现、不同布局的页面降低其他DOM元素对自身的影响。 &lt;!-- 模拟pre真实使用场景 --> &lt;pre v-text=\"$data\" class=\"pre-panel\">&lt;/pre> .pre-panel &#123; position: absolute; z-index: 999999; left: 20px; top: 20px; bottom: 20px; width: 380px; overflow: auto; background: rgba(0, 0, 0, .7); /* 建议半透明背景 */ color: #34ecff; /* 亮色的颜色即可 */ font-size: 16px; font-weight: normal; line-height: 20px; text-indent: 0; &#125; 以上css样式都是在多次实践中一行行增加，现已能适应大多数页面。 模拟pre真实使用场景，完整代码：传送门 即使在色彩强烈，内容纷乱的布局上，pre-panel仍然不影响阅读。 组件设计这个组件也非常简单，还是把一行代码还有样式抽象成一个组件，就基本完成了。不过考虑到扩展性，我们也可以考虑下给组件一些常用的配置选项。 第一步我们就是新建一个 control-panel.vue 文件，然后把刚才写的代码先复制过去。接下来复用就会发现 v-text=&quot;$data&quot; 使得每次复用绑定的都是自身组件的变量。我们这里应该使用插槽slot，然而每次插槽每次都要复用都要传值，我们更喜欢默认显示$data。然后再给指定插槽内容；当然这个 $data 是 control-panel 的父组件（引用control-panel的那个组件）而不是自己。 &lt;template> &lt;pre class=\"control-panel\"> &lt;slot> &#123;&#123; defaultProps &#125;&#125; &lt;/slot> &lt;/pre> &lt;/template> export default &#123; computed: &#123; defaultProps () &#123; const parent = this.$parent if (parent &amp;&amp; parent.$data) &#123; return parent.$data &#125; else &#123; return this.$data &#125; &#125; &#125; &#125; 这是最小化的可配置使用组件，然后这样还不够。虽然 control-panel 不会被其他组件遮住了，可是他遮住了其他组件。所以在某些情况，我们希望它“挪一挪”自己的位置，增加几个props即可解决这个问题。 export default &#123; props: &#123; width: &#123; type: [String, Number], default: '380px' &#125;, position: &#123; type: String, validator: (val) => ['left', 'right'].indexOf(val) !== -1, default: 'left' &#125; &#125;, computed: &#123; currentWidth () &#123; if (typeof this.width === 'string') &#123; return this.width &#125; else &#123; return `$&#123;this.width&#125;px` &#125; &#125; &#125; &#125; /* 记得删除.control-panel的 left 属性！！ */ .position-left &#123; left: 20px; &#125; .position-right &#123; right: 20px; &#125; &lt;template> &lt;pre class=\"control-panel\" :style=\"&#123; width: currentWidth &#125;\" :class=\"[ &#123; 'position-left': position === 'left' &#125;, &#123; 'position-right': position === 'right' &#125; ]\">&lt;slot>&#123;&#123; defaultProps &#125;&#125;&lt;/slot> &lt;!-- 这里不换行是为了消除首行缩进 --> &lt;/pre> &lt;/template> props只定义了3个，也有插槽，可以自定义，使用起来也不繁琐，方便了很多，不是吗？ 组件源码：传送门 复用-1：传送门 复用-2：传送门 当然还可以再进行扩展，只是没什么必要，如：随机color，交互设置样式和插槽内容；最好可以跟程序窗口一样可以最小化最大化关闭拖曳改变宽高.. 彩蛋设计一个组件，还要在实际项目中使用，可能因为各种现实因素影响，如果不喜欢组件的方式。（不想写，或者是嫌弃麻烦的）这里可以提供一个代码片段，需要的使用的直接复制粘贴即可。 &lt;pre style=\"position: fixed; top: 20px; left: 20px; bottom: 20px; width: 200px; overflow: auto; z-index: 9999; font-size: 16px; line-height: 20px; color: skyblue; background: rgba(0, 0, 0, .7)\"> &#123;&#123; formData &#125;&#125; &lt;/pre> 什么？不想每次都复制一遍？想编辑器代码提示的功能一样打几个单词就帮你打一整段？好伐，我也是一个嫌弃麻烦的人，如果你跟我一样是用vs code 的话，那我们可以用 vs code 增加用户自定义的代码提示。 vs code 菜单： 文件 &#x3D;&gt; 首选项 &#x3D;&gt; 用户代码片段 &#x3D;&gt; vue-html.json vue-html.json中增加这一段 \"Print to pre dom\": &#123; \"prefix\": \"vuepre\", \"body\": [ \"&lt;pre style=\\\"position: fixed; top: 20px; left: 20px; bottom: 20px; width: 300px; overflow: auto; z-index: 9999; font-size: 16px; line-height: 20px; color: skyblue; background: rgba(0, 0, 0, .7)\\\">\", \" &#123;&#123; $$data$2 &#125;&#125;\", \"&lt;/pre>\" ] &#125; 这样在*.vue的文件格式中，vs code 就支持对vuepre的代码提示了。 也直接直接拿我的 vue-html.json（传送门），使用任何文本编辑器打开，另存为：%APPData%\\Code\\User\\snippets\\vue-html.json 最后此本到这里就结束了，定义了一个可以监测变量的组件，相当于把控制台搬运到了网页，只是这个控制台是简化版的。 只是很多开发者都很讨厌调试，因为只有自己的代码出现问题才会去调试。其实调试本来就是一件苦中作乐的事情，平时写的代码，都是为了满足各种需求，有时候写得并不自由。那么，我们在调试的时候，为何不使用一种更有趣味的方式去调试呢？起码这个时候自由度很高很高..","categories":[{"name":"vue","slug":"vue","permalink":"https://screw-hand.com/categories/vue/"}],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://screw-hand.com/tags/vue-skill/"},{"name":"debugger","slug":"debugger","permalink":"https://screw-hand.com/tags/debugger/"}]},{"title":"项目部署","slug":"deploy","date":"2020-01-16T16:30:34.000Z","updated":"2024-03-17T09:23:23.008Z","comments":true,"path":"/post/deploy/","link":"","permalink":"https://screw-hand.com/post/deploy/","excerpt":"工作中实操过的项目部署记录，使用的是Ubuntu系统，nignx 和 C# 的运行环境均已安装。 前期配置文件准备# 以acs.HOST.cn举例 （HOST）为主域名 # 项目路径 /home/wwwroot/acs.xxx.cn # 从服务器下载文件配置文件（需要本机使用pscp或其他支持ftp协议的程序） pscp USERNAME@IP:/home/wwwroot/acs.HOST.cn/appsettings.json E:\\PATH # nginx 配置acs 所有项目(HOSTboss.conf) usr/local/nginx/conf/HOSTboss.conf # nginx 配置路径 usr/local/nginx/conf/nginx.conf # 守护进程 /etc/systemd/system/apps.acs.serive","text":"工作中实操过的项目部署记录，使用的是Ubuntu系统，nignx 和 C# 的运行环境均已安装。 前期配置文件准备# 以acs.HOST.cn举例 （HOST）为主域名 # 项目路径 /home/wwwroot/acs.xxx.cn # 从服务器下载文件配置文件（需要本机使用pscp或其他支持ftp协议的程序） pscp USERNAME@IP:/home/wwwroot/acs.HOST.cn/appsettings.json E:\\PATH # nginx 配置acs 所有项目(HOSTboss.conf) usr/local/nginx/conf/HOSTboss.conf # nginx 配置路径 usr/local/nginx/conf/nginx.conf # 守护进程 /etc/systemd/system/apps.acs.serive 配置nginx# 创建项目目录 sudo mkdir /home/wwwroot/acs.HOST.cn # 设置文件夹权限为完全访问 sudo chmod 777 acs.HOST.cn # 切换到nginx目录 cd /usr/local/nginx cd ./conf # 上传项目配置 # C:\\Users\\Admin\\Downloads\\pscp.exe .\\pscp.exe E:\\PATH\\HOSTboss.conf USERNAME@acs.HOST.cn:/home/wwwroot/acs.HOST.cn # 移动文件 sudo mv HOSTboss.conf /usr/local/nginx/conf # 检查include sudo vim /usr/local/nginx/conf/nginx.conf # 检查证书 HOST.cn.key HOST.cn.pem ls /usr/local/nginx/conf/cert # 测试 重载nginx cd /usr/local/nginx cd ./sbin sudo ./nginx -t # 测试 sudo ./nginx -s reload # 重载 项目部署、守护进程# 上传已打包的项目到服务器 .\\pscp.exe E:\\PATH\\acs.HOST.cn\\FILENAME.zip USERNAME@acs.HOST.cn:/home/wwwroot/acs.HOST.cn # 解压 cd /home/wwwroot/acs.HOST.cn sudo unzip -o FILENAME.zip # 检查证书 HOST.pfx ls /home/wwwroot/acs.HOST.cn/ # 移动守护进程配置文件到指定目录 sudo mv ./apps.acs.service /etc/systemd/system # 定义守护进程 sudo systemctl enable apps.acs.service # 开启进程 sudo systemctl start apps.acs.service # 查看状态 sudo systemctl status apps.acs.service 备注web服务器只需部署nginx sso boss mgt 部署成功，对外开放三个地址 https://sso.HOST.cn 单点登录 https://boss.HOST.cn 门户网站 https://mgt.HOST.cn 一体化管理中心","categories":[],"tags":[]},{"title":"vue的一些技巧","slug":"vue-skill","date":"2019-12-20T14:49:04.000Z","updated":"2024-03-17T09:23:23.108Z","comments":true,"path":"/post/vue-skill/","link":"","permalink":"https://screw-hand.com/post/vue-skill/","excerpt":"v-if 获取 refs 问题先简单介绍下这两个指令： v-if 条件渲染 ref 返回组件实例或DOM元素 有时候我们需要在条件渲染的DOM节点上返回一个DOM对象或组件实例，可this.$refs.child 返回的是undefined。通过查阅文档得知: v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条块。$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。 如此可得： v-if 条件渲染： 惰性渲染，DOM、事件、组件会被销毁重建 ref 返回组件实例或DOM元素，非相应式","text":"v-if 获取 refs 问题先简单介绍下这两个指令： v-if 条件渲染 ref 返回组件实例或DOM元素 有时候我们需要在条件渲染的DOM节点上返回一个DOM对象或组件实例，可this.$refs.child 返回的是undefined。通过查阅文档得知: v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条块。$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。 如此可得： v-if 条件渲染： 惰性渲染，DOM、事件、组件会被销毁重建 ref 返回组件实例或DOM元素，非相应式 那么可推论得知v-if和ref的实现有冲突，v-show也是条件渲染，而它只是单纯切换元素css display属性值隐藏。**如此可以使用v-show替代v-if**。 总结：工作中常用的是v-if，可v-show也有v-if替代不了的时候，比如用于ref的DOM或组件；而v-if又可使用v-else、v-else-if，这两个指令也比较特殊，必须和v-if相邻，阅读代码时逻辑性更强。 $event —— 隐藏的函数参数vue的官方api文档，里详细地介绍了实例属性&#x2F;方法，这些属性和方法都以美元符号$为前缀， $event并没有介绍；但在教程中， $event的定义是获取原生dom事件，实践中有时候其值并非是原生dom对象，而$event 又是可以隐性调用的，这使得$event的机制不那么直观。 基本使用使用v-on或@指令可以为dom元素绑定事件,函数没有参数时，$event被自动当作实参传入;函数带有参数时，最后一个参数必须显式传入$event 请自行准备一个组件：dollar-event.vue /* dollar-event.vue */ // eg: 无参数 &lt;button @click=\"handleClick\">$event empty param&lt;/button> &lt;script> handleClick ($event) &#123; console.log('dom事件：本组件事件') console.log($event) // 原生dom对象 &#125; &lt;/script> // eg：带有参数 &lt;!-- 调换$event位置，爹妈不疼哦，不信你试试？ --> &lt;button @click=\"handleParamClick('click', $event)\">$event with param&lt;/button> &lt;script> handleParamClick (value, $event) &#123; console.log(&#123; value, // 'click' $event // 原生dom对象 &#125;) &#125; &lt;/script> 非常简单，就是有无参数的区别，可自定义事件($emit)机制就有两个含义了。 自定义事件($emit)$emit实例方法可以触发父组件的自定义事件，同时还可以传递一个参数给自定义事件接受；这个参数也可以是子组件的$event 请再准备一个组件：emit-event.vue /* emit-event.vue */ &lt;button class=\"skill-emit-event\" @click=\"handleEmit\"> &lt;slot>emit-event&lt;/slot> &lt;/button> &lt;script> handleEmit ($event) &#123; // 这里的$event同\"基本使用\"的第一段实例一样都是原生dom对象 this.$emit('dispatch', &#123; emitParams: $event, emitValue: 'dispatch emit-event' &#125;) &#125; &lt;/script> /* dollar-event.vue */ &lt;emit-event @dispatch=\"emitClick\">emit click&lt;/emit-event> &lt;script> import emitEvent from './emit-event' emitClick (emitEvent, $event) &#123; console.log(&#123; emitEvent, // &#123; emitParams: '子组件的$event', emitValue: 'dispatch emit-event' &#125; $event // emitEvent才是形参$event, 因此自己没有$event了，这里是undefined &#125;) console.log(emitEvent.emitParams.target) // &lt;button class=\"skill-emit-event\"> &#125; &lt;/script> 父组件的自定义事件有参数时也可结合$event一起使用，机制跟“基本使用”是一样的。 /* dollar-event.vue */ &lt;emit-event @dispatch=\"emitParamClick('val', $event)\">emit param click&lt;/emit-event> &lt;script> emitParamClick (val, $event) &#123; console.log(&#123; val, // 'val' $event // &#123; emitParams: '子组件的$event', emitValue: 'dispatch emit-event' &#125; &#125;) &#125; &lt;/script> 示例代码：dollar-event 总结： 基本使用时函数无其他实参，可以不用传$event实参，有其他实参的时候，$event必须作为最后一个参数传入 自定义事件时使用，$event作为$emit的实参，若$emit不带参数，$event的值为undefined 静态资源vue的静态资源分两种方式处理，区别就是经不经过webpack处理，或者说——是否为webpack模块: webpack模块：js中import进来的，或用相对路径在template/css引入的 非webpack模块：public目录下，或绝对路径引用的，将被直接拷贝 官方推荐使用资源作为模块引入，理由如下： 脚本和样式表会被压缩且打包在一起，从而避免额外的网络请求。 文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误。 最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本。 处理静态资源 CSS引用静态资源","categories":[{"name":"vue","slug":"vue","permalink":"https://screw-hand.com/categories/vue/"}],"tags":[{"name":"vue-skill","slug":"vue-skill","permalink":"https://screw-hand.com/tags/vue-skill/"}]},{"title":"原型链是如何贯穿js的","slug":"prototype","date":"2019-04-28T06:32:00.000Z","updated":"2024-03-17T09:23:23.084Z","comments":true,"path":"/post/prototype/","link":"","permalink":"https://screw-hand.com/post/prototype/","excerpt":"原型链是js的大动脉。 导读js的原型链难以避免要牵扯到面向对象，这里我们先简单说说原型还有原型链。之后我们说到面向对象的演变过程，会再次涉及到原型链，还有更多的东西。相信看完的读者会对JavaScript会有更深的认识。 原型对象本小节意在介绍js中几位朋友，读者只需要记住有它们的存在就行了，毕竟这几位朋友性格有点隐匿。 首先，我们要明白，声明一个对象，哪怕是空属性，js也生成一些内置的属性和方法。 /* 两种方法声明对象 */ // 对象直接量 var obj_1 = &#123;&#125;; // new关键字声明对象 var obj_2 = new Object(); // 在Object的原型对象添加属性 Object.prototype.attr = 'myarr' console.log(obj_1); // &#123;&#125; console.log(obj_2); // &#123;&#125; // js中的恒等符号对函数来说只比较引用 // obj_1.valuOf函数来源于Object.valueOf // 更准确来说是Object.protoype.valueOf console.log(obj_1.valueOf === Object.valueOf); // true // obj_1并未声明attr属性，通过Object.prototype继承得到attr属性 console.log(obj_1.attr); // myarr","text":"原型链是js的大动脉。 导读js的原型链难以避免要牵扯到面向对象，这里我们先简单说说原型还有原型链。之后我们说到面向对象的演变过程，会再次涉及到原型链，还有更多的东西。相信看完的读者会对JavaScript会有更深的认识。 原型对象本小节意在介绍js中几位朋友，读者只需要记住有它们的存在就行了，毕竟这几位朋友性格有点隐匿。 首先，我们要明白，声明一个对象，哪怕是空属性，js也生成一些内置的属性和方法。 /* 两种方法声明对象 */ // 对象直接量 var obj_1 = &#123;&#125;; // new关键字声明对象 var obj_2 = new Object(); // 在Object的原型对象添加属性 Object.prototype.attr = 'myarr' console.log(obj_1); // &#123;&#125; console.log(obj_2); // &#123;&#125; // js中的恒等符号对函数来说只比较引用 // obj_1.valuOf函数来源于Object.valueOf // 更准确来说是Object.protoype.valueOf console.log(obj_1.valueOf === Object.valueOf); // true // obj_1并未声明attr属性，通过Object.prototype继承得到attr属性 console.log(obj_1.attr); // myarr *firefox控制台中空对象仍然有`prototype`属性* 误区：每个浏览器的控制台输出都不太一样，Chrome和Edge并不显示prototype属性，因为我们并没有给obj_1的prototype属性定义任何属性和方法。 由于历代浏览器的更新和ECMAScript的修正，有时难以体现prototype和__proto__的存在，但我们的js代码能体现出它们的确是真实存在的。 prototype在这里称之为obj_1的原型对象，通过对象直接量和new关键字声明的对象都具有原型对象，继承自Object.prototype；几乎每个对象都有其原型对象，null是特例。 双对象实现原型继承需要原型对象是为了实现继承，但有了原型对象我们还无法把obj_1与Object.prototype链接起来。我们还需要另一个对象：__proto__，该属性能指向构造函数的原形属性constructor。一些老版本浏览器不识别，有些无法识别其内部信息，但不影响程序的正常运行。 *`obj_1`的`__proto__`对象, 该属性下又有`__proto__`和`constructor`属性* obj_1.__proto__ === Object.prototype // true obj_1.__proto__.constructor === Object // true 这里有三个概念先行抛出 继承：继承使子类（超类）可拥有父类的属性和方法，子类也可添加属性和方法 父类：提供属性和方法被子类继承 子类：被父类继承的对象，可调用父类的属性和方法，也能定义属性和方法（父类无法调用） 通过Object.prototype.attr与obj_1.attr，我们可以看出 obj_1 (子类) 继承了 Object (父类)的原型对象的attr属性。正是因为obj_1的__proto__指向Object.prototype，obj_1继承了父类原型对象，使之拥有了attr属性。而子类的__proto__.constructor直接指向父类。 原型继承：每声明一个对象，其本身拥有用两个对象：原型对象(prototype)，与__proto__对象，原型对象即可供自身使用，子类继承后也可调用；自身的__proto__对象指向父类的原型对象，其constructor属性指向父类的构造函数。通过原型对象的方法实现继承，叫原型继承。 双对象与原型链综合以上，我们知道了使用原型对象prototype和__proto__对象可以实现继承的功能。那么我们是不是可以一直继承下去呢？ function People(name) &#123; this.name = name; &#125; function Engineer(type) &#123; this.type = type; &#125; Engineer.prototype = new People('Chris Chen'); // Engineer (子类)继承 People (父类) function Programmer(skill) &#123; this.skill = skill; this.showMsg = function () &#123; return 'Hi, my name is ' + this.name + ', I am a ' + this.type + ' engineer, I can write ' + this.skill + ' code!'; &#125; &#125; Programmer.prototype = new Engineer('front-end'); // Programmer (子类) 继承 Engineer (父类) var me = new Programmer('js'); console.log(me); // Object &#123; skill: \"js\", showMsg: showMsg() &#125; console.log(me.showMsg()); // Hi, my name is Chris Chen, I am a front-end engineer, I can write js code! 代码看完，我们从子类开始解释，也就是从下往上的顺序： me是Programmer的实例化对象 Programmer的原型指向Engineer的实例对象 Engineer的原型指向People的实例对象 我们再来一张图说明其关系 这个.. 一盘煎蛋？？ 好伐，煎蛋就煎蛋，来，我们继续。 请注意重点：**Programmer并无定义type, name属性，Programmer的showMsg中能显示this.name this.type分别来源于Engineer和Programmer的原型对象。**很巧妙的一种属性搜索机制，自身的构造函数没有该属性，就从自身的原型对象中找，如果父类的原型对象没有，那么继续往父类的父类原型对象找，找到了就赋值；或直到没有父类，返回undefined；属性如此，方法也是同样的赋值机制。 说到底属性搜索机制就是原型链的一种具体体现，我们再上一张图。 所以原型链的关键字是继承和原型对象！！ 原型链：使用prototype和_proto_两个对象实现继承，由于是基于原型对象实现调用链，又称之为原型链。 关于原型链的第一步介绍就到这里，接下来我们从头开始，说说面向对象。 面向对象首先我们先来概述面向过程编程（opp）与面向对象（oop）。这是JS的两种编程范式，也可以理解为编程思想。顾名思义，两者的重心不同。下面我们使用两种方法创建dom并挂载于页面。 /* 面向过程 */ // 1. 定义dom var dom = document.createElement('div'); // 2. 设置dom属性 dom.innerHTML = '面向过程'; dom.id = 'opp'; dom.style = 'color: skyblue'; // 3. 挂载dmo var container = document.getElementById('container'); container.appendChild(dom); /* 面向对象 */ // 1. 定义构造函数 function CreateElement(tagName, id, innerText, style) &#123; var dom = document.createElement(tagName); dom.innerHTML = innerText; dom.id = id; dom.style = style; this.dom = dom; &#125; // 2. 定义原型对象上的方法 CreateElement.prototype = &#123; render: function (dom) &#123; var container = document.getElementById(dom); container.appendChild(this.dom); &#125; &#125; // 实例化对象 var innerBox = new CreateElement('div', 'oop', '面向对象', 'color: pink;'); // 调用原型方法 innerBox.render('container'); 面向过程比较流水线，更注重程序的实现过程，面向对象的程序由一个又一个的单位————对象组成，不关心对象的内部属性和方法，只需实例化，调用方法即可使用。 或许上面的例子，还不是很有力得体现出两者的区别，那么如果现在，需要挂载多个元素呢？ /* 面向过程 */ // var dom_1 = document.createElement('div'); // dom_1.innerHTML = '面向过程_1'; // dom_1.id = 'opp-1'; // dom_1.style = 'color: skyblue'; // var dom_2 = document.createElement('div'); // dom_2.innerHTML = '面向过程_2'; // dom_2.id = 'opp-2'; // dom_2.style = 'color: skyblue;'; // var container = document.getElementById('container'); // container.appendChild(dom_1); // container.appendChild(dom_2); /* 这种方法傻的可爱，我们包装成函数吧 */ function createElement(tagName, id, innerText, style) &#123; var dom = document.createElement(tagName); dom.innerHTML = innerText; dom.id = id; dom.style = style; return dom; &#125; var container = document.getElementById('container'); var box_1 = createElement('div', 'oop-1', '面向过程_1', 'color: skyblue;'); var box_2 = createElement('div', 'oop-2', '面向过程_2', 'color: skyblue;'); container.appendChild(box_1); container.appendChild(box_2); /* 面向对象 */ function CreateElement(tagName, id, innerText, style) &#123; var dom = document.createElement(tagName); dom.innerHTML = innerText; dom.id = id; dom.style = style; this.dom = dom; &#125; CreateElement.prototype = &#123; render: function (dom) &#123; var container = document.getElementById(dom); container.appendChild(this.dom); &#125; &#125; var innerBox_1 = new CreateElement('div', 'oop-1', '面向对象_1', 'color: pink;'); innerBox_1.render('container'); // 这里只需再实例化一个对象调用render方法即可 var innerBox_2 = new CreateElement('div', 'oop-2', '面向对象_2', 'color: pink;'); innerBox_2.render('container'); 重复调用同样的方法，面向过程如果不包装一个函数，显得代码很冗余且愚蠢，而面向对象只需再次实例化即可。这里也提醒我们平时写代码的时候要考虑复用性。 好的，那我们现在需要给dom元素添加一些交互功能，又要怎么做？ /* 面向过程 */ function createElement(tagName, id, innerText, style, event, fn) &#123; var dom = document.createElement(tagName); dom.innerHTML = innerText; dom.id = id; dom.style = style; // 直接修改内部函数 dom.addEventListener(event, fn); return dom; &#125; var container = document.getElementById('container'); var box_1 = createElement('div', 'oop-1', '面向过程_1', 'color: skyblue;', 'click', function (e) &#123; alert(e.target.innerHTML); &#125;); // 过于死板，就算没有传参dom.addEventListener也会调用两次 var box_2 = createElement('div', 'oop-2', '面向过程_2', 'color: skyblue;'); container.appendChild(box_1); container.appendChild(box_2); /* 面向对象 */ function CreateElement(tagName, id, innerText, style) &#123; var dom = document.createElement(tagName); dom.innerHTML = innerText; dom.id = id; dom.style = style; this.dom = dom; &#125; CreateElement.prototype = &#123; render: function (dom) &#123; var container = document.getElementById(dom); container.appendChild(this.dom); &#125;, // 在原型对象上添加方法 addMethod: function (event, fn) &#123; this.dom.addEventListener(event, fn); &#125; &#125; var innerBox_1 = new CreateElement('div', 'oop-1', '面向对象_1', 'color: pink;', 'click'); innerBox_1.render('container'); var innerBox_2 = new CreateElement('div', 'oop-2', '面向对象_2', 'color: pink;', 'click'); innerBox_2.render('container'); // 根据场景需求决定是否调用addMethod方法 innerBox_2.addMethod('click', function (e) &#123; alert(e.target.innerHTML); &#125;) 从这里可以我们看出两者的扩展方法截然不同，面向过程模式需要直接在函数中修改，而面向对像在原型对象上直接追加方法。 面向对象比面向过程有更高的复用性和扩展性。 PS：面向过程也并非一无是处，比面向对象更直观化，也更理解。若不需要考虑太多的因素，使用面向过程开发反而效率会更快。 创建对象把大象关进冰箱需要几步在下并不清楚。不过要想进行面向对象开发，第一步是先创建一个对象，js中有6种方法可创建对象： new 操作符 字面量 工厂模式 构造函数 原型模式 混合模式（构造+原型） 工厂模式前两种方法在开头已使用，这里不再复述。如果要创建多个相同的对象，使用前两种方法，会产生大量重复的代码，而工厂模式解决了这个问题.. function factoryMode(name, age) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.say = function () &#123; return this.name + ' has ' + this.age + ' years old!'; &#125; return obj; &#125; var guest = factoryMode('Gentleman', 25); var Chris = factoryMode('Chris', 20); console.log(guest.say()) // Gentleman has 25 years old! console.log(Chris.say()) // Chris has 20 years old! console.log(guest instanceof Object); // true console.log(Chris instanceof Object); // ture ... 有点赞哦，这样重复实例化多个对象也不怕了，对象识别问题仍然没解决 PS:new Object()已决定了工厂模式的实例是由Object实例化而来的，其对象类型是Object，Date Array有对应的对象类型，这里读者可以试试new Array instanceof Array等原生数据类型。 工厂模式是面向对象中常见的一种设计模式，是一个可以重复实例化多个对象的函数，但识别对象无能为力。 构造函数我们可以把工厂模式修改一下，就可以写出一个构造函数.. function ConstructorMode(name, age) &#123; this.name = name; this.age = age; this.say = function () &#123; return this.name + ' has ' + this.age + ' years old!'; &#125; &#125; var guest = new ConstructorMode('Gentleman', 25); var Chris = new ConstructorMode('Chris', 20); console.log(guest.say()) // Gentleman has 25 years old! console.log(Chris.say()) // Chris has 20 years old! console.log(guest instanceof Object); // true console.log(guest instanceof ConstructorMode); // true console.log(ConstructorMode instanceof Object); // true 有几个地方不太一样： 没有显示创建对象 属性&#x2F;方法赋值给this 使用new关键字调用 无return 可以看出实现了跟工厂模式一样的功能，那么什么是构造函数呢？ 构造函数也是一个函数，跟工厂模式一样可重复实例化对象。为了跟普通函数区分，函数名首字母一般是大写的。 使用该函数时需要使用new关键字实例化；不使用new实例化，该构造函数表现如同普通的函数。 虽然没有显示创建对象，但在new实例化时，后台执行了new Object() 使用this是因为，构造函数的作用域指向实例化对象，即：两次实例化，ConstructorMode中的this分别指向Guest, Chris。 通过上面的instanceof判断，我们能识别出guest是由ConstructoreMode实例化的，与此同时 guest 也是 Object 的实例对象。构造函数也有其弊端，声明在构造函数内的属性叫“构造属性”，问题就在于：构造属性若是引用类型（以函数为例），实例化后的函数执行的动作虽然是相同的，但引用地址不同，我们并不需要两份同样的函数。 console.log(Chris.say == guest.say); // false 构造函数模式：构造函数是一个需要实例化调用的函数，内部作用域指向实例对象，无须return。构造函数模式，也可实例化大量重复对象，也可识别实例化后的对象是由哪个构造函数实例化而来。其缺点是：若在构造属性中声明函数，实例化后的各个对象引用地址保持独立。 原型模式原型模式靠原型对象发挥作用，原型对象开头已有介绍。 function PrototypeMdoe() &#123; &#125; // 直接在原型对象声明，直面量形式 PrototypeMdoe.prototype.mode = 'prototype'; PrototypeMdoe.prototype.do = function (name) &#123; return 'we do the something same, ' + name + '.'; &#125; var guest = new PrototypeMdoe(); var Chris = new PrototypeMdoe(); console.log(guest.do('guest')) // we do the something same, guest. console.log(Chris.do('Chris')) // we do the something same, Chris. console.log(guest.do === Chris.do) // true，相同的引用指针 console.log(guest.do('guest') === Chris.do('Chirs')) // false， 返回值不相等 console.log(guest.prototype === Chris.prototype) // 指向相同的原型对象 实例化对象do方法引用指针是相同的，所以如果是需要给所有实例化对象共享的方法，可在原型上直接声明。guest和Chris都由同一个构造函数的实例化，原型对象的指针地址相同。 也可以使用对象字面量的方法，两者有点的区别：对象字面量声明的原型constructor会指向Object，我们也可以手动设置。 function PrototypeMdoe() &#123; &#125; // 对象字面量，原型赋值为对象 PrototypeMdoe.prototype = &#123; // 手动设置构造函数指针 // constructor: PrototypeMdoe, run: function () &#123; return 'I;m running!' &#125; &#125; var proto = new PrototypeMdoe() // 打开constructor的注释对比运行结果 console.log( proto.constructor === PrototypeMdoe, proto.constructor === Object ) 原型模式：共享是原型对象的特点，所有声明在原型上的属性和方法都会被所有实例化对象继承，且指向同一个引用地址。 原型属性是基本类型的数据，共享很方便；如果是引用类型的数据，共享将带来麻烦。由于引用地址相同，更改其中一个实例的原型属性，其他实例的原型也随之改变。 function PrototypeMdoe() &#123; &#125; PrototypeMdoe.prototype.arr = [1, 2, 3, 4, 5]; var proto_1 = new PrototypeMdoe(); var proto_2 = new PrototypeMdoe(); console.log(proto_1.arr) // [1,2,3,4,5] proto_1.arr.splice(1, 2) // [2,3,4] console.log(proto_2.arr) // [1,5] Object.definedPeroperty：ES5语法，可定义新属性或修改现有属性并返回改对象；第三个参数为属性描述符，能精确添加或修改对象的属性：枚举性、属性值、可写性、存取设置。 var Obj = &#123; attr: 'obj' &#125; Obj.prototype = &#123; run: function (name) &#123; return name + ' run!'; &#125; &#125; // 使用Object.definedPeroperty设置constructor的特性 Object.defineProperty(Obj.prototype, 'constructor', &#123; configurable: true, // 设置为ture下面的设置才能生效 // enumerable: false, // 枚举性 // writable: false, // 可写性 // get: undefined, // 取值器 // set: undefined, // 设置器 value: Obj // 属性值 &#125;) isPrototypeOf函数可以判断原型对象是否为某个实例的原型对象。 console.log( PrototypeMdoe.prototype.isPrototypeOf(proto_1), // true Array.prototype.isPrototypeOf(proto_1) // false ) 混合模式混合模式是组合构造函数和原型模式使用，这是最常用的一种设计模式了。 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。所以每个实例都会有自己的一份实例属性的副本，但同时共享着对方法的引用。最大限度的节省了内存。同时支持向构造函数传递参数。 function CreateObject (name, age) &#123; this.name = name; this.age = age; &#125; CreateObject.prototype.say = function () &#123; return this.name + ' has ' + this.age + ' years old!'; &#125; var guest = new CreateObject('Gentleman', 25); var Chris = new CreateObject('Chris', 20); console.log(guest.say()) // Gentleman has 25 years old! console.log(Chris.say()) // Chris has 20 years old! hasOwnProperty可检测一个属性是否为实例属性。而in可判断属性是否存在本对象中，包括实例属性或者原型属性。 console.log(guest.hasOwnProperty('name')) // true console.log(guest.hasOwnProperty('say')) // false console.log('name' in guest) // true console.log('say' in guest) // true // 判断是否为原型属性 function isProperty(object, property) &#123; debugger return !object.hasOwnProperty(property) &amp;&amp; property in object; &#125; console.log(isProperty(guest, 'name')) console.log(isProperty(guest, 'say')) 创建对象的六种方法就到这里了，另外还有动态原型、寄生构造、稳妥构造函数。 这三种模式都是基于混合模式的改良，感兴趣的可以随便看看：点我查看 **动态原型** 原型模式中，不管我们是否调用原型的方法，都会初始化原型中的方法，并且声明一个构造函数时，构造函数和原型对象是分开声明的，略显怪异。我们可以使用动态原型模式，把构造函数和原型对象封装到一起。 function CreateObject (name,age) &#123; this.name = name; this.age = age; // 动态创建原型属性，仅在第一次调用时初始化 if (typeof this.say !== 'function') &#123; CreateObject.prototype.say = function () &#123; return this.name + ' has ' + this.age + ' years old!'; &#125; &#125; &#125; var guest = new CreateObject('Gentleman', 25); var Chris = new CreateObject('Chris', 20); console.log(guest) console.log(guest.say()) // Gentleman has 25 years old! console.log(Chris.say()) // Chris has 20 years old! 寄生构造 稳妥构造函数 #other-create { border: 5px solid #aaa; } ;(function() { var showOtherCreate = true; var creatObject = document.getElementById('create-object'); creatObject.addEventListener('click', function() { var otherCreate = document.getElementById('other-create'); if (showOtherCreate) { otherCreate.style.display = 'block'; creatObject.innerText = '不想看了'; } else { otherCreate.style.display = 'none'; creatObject.innerText = '点我查看'; } showOtherCreate = !showOtherCreate; }) })(); 动态原型寄生构造未完待续","categories":[],"tags":[]},{"title":"es6主要特性小结","slug":"es6-main","date":"2019-04-11T06:58:51.000Z","updated":"2024-03-17T09:23:23.008Z","comments":true,"path":"/post/es6-main/","link":"","permalink":"https://screw-hand.com/post/es6-main/","excerpt":"ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。 let：let实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块（花括号）内有效；与var的区别是，var用来做循环的计数变量，会泄露成全局变量，在外部调用的值是循环完成后的值。 const：声明变量，但声明的是常量，一旦声明，常量的值不能改变。","text":"ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。 let：let实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块（花括号）内有效；与var的区别是，var用来做循环的计数变量，会泄露成全局变量，在外部调用的值是循环完成后的值。 const：声明变量，但声明的是常量，一旦声明，常量的值不能改变。 class：定义一个类，可定义构造方法在其中，构造方式this关键字指向实例。constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 extends：class之间可用extends关键字实现继承 super：指代父类的实例（即父类的this对象）。子类必须在constructor中调用·方法，否则新建实例就会报错，因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 arrow function：箭头函数 (i)=&gt; i+1;箭头函数体内的this对象指向定义时所在的对象（箭头函数内无自己的this，其this继承外面的作用域） template string：用反引号（ &#96; ）来标识起始，用$&#123;&#125;来引用变量，所有的空格和缩进都会被保留在输出之中 destructuring：从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 // 解构 let cat = 'ken' let dog = 'lili' let zoo = &#123;cat, dog&#125; console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125; // 赋值 let dog = &#123;type: 'animal', many: 2&#125; let &#123; type, many&#125; = dog console.log(type, many) //animal 2 default：变量未赋值时给该变量一个默认值 function animal(type = 'cat') &#123; console.log(type) &#125; animal() //cat rest：过滤变量 function animals(once, ...types)&#123; console.log(types) &#125; animals('cat', 'dog', 'fish') //[ \"dog\", \"fish\"] import export：es6的模块化机制， import用于导入模块，可以选择性导入模块中的一部戏属性&#x2F;方法，也可给导入的模块重命名；export用于导出模块，也多次导出，任何数据类型都可导出（变量、函数、类等..）。 基本使用 //index.js import animal from './content' console.log(animal) // A cat //content.js export default 'A cat' 多次导出，导入模块时使用 as 重命名 type 为 animalType //content.js export default 'A cat' export function say()&#123; return 'Hello!' &#125; export const type = 'dog'; //index.js import animal, &#123; say, type as animalType &#125; from './content' let says = say() console.log(`The $&#123;animalType&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"https://screw-hand.com/tags/es6/"}]},{"title":"web安全基础","slug":"web-safe","date":"2019-04-08T14:02:34.000Z","updated":"2024-03-17T09:23:23.108Z","comments":true,"path":"/post/web-safe/","link":"","permalink":"https://screw-hand.com/post/web-safe/","excerpt":"SQL注入通过把SQL命令插入到web表单提交或者页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 防范SQL注入1.校验用户输入的参数，限制其长度或转义单引号或双连字符2.使用参数化SQL或直接使用存储过程进行数据查询存取3.每个应用使用单独的权限有限的数据库连接，不使用管理器权限连接数据库4.机密信息不明文存放，加密或hash掉密码和敏感信息 XSS跨站脚本攻击(Cross Site Scripting)，缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。","text":"SQL注入通过把SQL命令插入到web表单提交或者页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 防范SQL注入1.校验用户输入的参数，限制其长度或转义单引号或双连字符2.使用参数化SQL或直接使用存储过程进行数据查询存取3.每个应用使用单独的权限有限的数据库连接，不使用管理器权限连接数据库4.机密信息不明文存放，加密或hash掉密码和敏感信息 XSS跨站脚本攻击(Cross Site Scripting)，缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 原理攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。诱使受害者打开受到攻击的服务器URL。受害者在Web浏览器中打开URL，恶意脚本执行。 攻击方式 反射型：发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS随响应内容一起返回给浏览器，最后浏览器解析执行XSS代码，这个过程就像一次发射，所以叫反射型XSS。 存储型：存储型XSS和反射型的XSS差别就在于，存储型的XSS提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。 防御措施 编码：对用户输入的HTML实体进行编码 过滤：移除用户上的DOM属性，如onerror等，移除用户上传的style、script、iframe节点 校正：避免直接对HTML实体编码，使用DOM Prase转换，校对不配对的DOM标签 cookie：避免直接在cookie 中泄露用户隐私，例如email、密码等等。 通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。 CSRFCSRF跨站点请求伪造(Cross—Site Request Forgery) 跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 完成一次CSRF攻击，受害者必须依次完成以下两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 看到这里，你也许会问：“如果我不满足以上两个条件中的一个，我就不会受到CSRF攻击”。是滴，确实如此，但是你不能保证以下情况不会发生： 你不能保证你登录了一个网站之后，不再打开一个tab页面并访问其它的网站（黄网）。 你不能保证你关闭浏览器之后，你本地的Cookie立刻过期，你上次的会话已经结束。 上述中所谓的攻击网站，可能就是一个钓鱼网站或者黄色网站。 防御CSRF攻击： 通过 referer、token 或者 验证码 来检测用户提交。 尽量不要在页面的链接中暴露用户隐私信息。 对于用户修改删除等操作最好都使用post 操作 。 避免全站通用的cookie，严格设置cookie的域。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://screw-hand.com/tags/web/"}]},{"title":"浏览器结构","slug":"browser","date":"2019-03-28T18:02:01.000Z","updated":"2024-03-17T09:23:22.984Z","comments":true,"path":"/post/browser/","link":"","permalink":"https://screw-hand.com/post/browser/","excerpt":"简单来说浏览器可以分为两个部分，shell+内核，其中shell的种类比较多，内核的种类则比较少。 Shell是指浏览器外壳：菜单、工具栏等；主要提供给用户操作，参数设置等，调用内核实现各种功能。 内核是浏览器的核心，基于标记语言显示内容的程序或模块。可分两部分，渲染引擎和JS引擎，负责渲染网页内容，计算网页的显示方式，不同内核的渲染效果不同。JS引擎则执行javascript实现网页的动态效果。","text":"简单来说浏览器可以分为两个部分，shell+内核，其中shell的种类比较多，内核的种类则比较少。 Shell是指浏览器外壳：菜单、工具栏等；主要提供给用户操作，参数设置等，调用内核实现各种功能。 内核是浏览器的核心，基于标记语言显示内容的程序或模块。可分两部分，渲染引擎和JS引擎，负责渲染网页内容，计算网页的显示方式，不同内核的渲染效果不同。JS引擎则执行javascript实现网页的动态效果。 组件浏览器一般由以下组件构成：1.用户界面：包括地址栏、前进&#x2F;后退按钮、书签菜单等。2.浏览器引擎：在用户界面和呈现引擎之间传送指令。3.呈现引擎：负责显示请求的内容，解析html和css内容，显示在屏幕上、4.网络：用于网络调用，比如HTTP请求，其接口与平台无关，并为所有平台提供底层实现。5.用户界面后端：绘制基本的窗口小部件，比如组合框和窗口。 其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。6.JavaScript解析器：解析执行JavaScript代码。7.数据存储：持久层。实现了Cookie，web Stroage、indexDB的功能支持。 Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://screw-hand.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"跨域","slug":"cross-domain","date":"2019-03-28T18:00:33.000Z","updated":"2024-03-17T09:23:23.000Z","comments":true,"path":"/post/cross-domain/","link":"","permalink":"https://screw-hand.com/post/cross-domain/","excerpt":"同源策略源：源由协议，域名和端口号组成，若url地址的协议、域名和端口号均相同则属于同源。 同源策略：浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对象自资源。其阻止的是数据的接受而不是请求的发送 不受同源策略限制：页面中的链接，重定向以及表单提交；可以引入跨域资源，但js不能读写加载内容。 如嵌入到页面中的&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;等。 跨域：受同源策略的限制，不同源的脚本不能操作其他源下面的对象，想操作另一个源下面的对象就是跨域。","text":"同源策略源：源由协议，域名和端口号组成，若url地址的协议、域名和端口号均相同则属于同源。 同源策略：浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对象自资源。其阻止的是数据的接受而不是请求的发送 不受同源策略限制：页面中的链接，重定向以及表单提交；可以引入跨域资源，但js不能读写加载内容。 如嵌入到页面中的&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;等。 跨域：受同源策略的限制，不同源的脚本不能操作其他源下面的对象，想操作另一个源下面的对象就是跨域。 实现方式： document.domain JSONP CORS window.name postMessage H5 需要跨域的场景： 上传图片、文件 富文本编辑器 页面请求第三方接口 降域 document.domain 将两个不同源的域名document.domain设置为同一个即可；存在安全性问题，一个网站被攻击，另一个也有安全漏洞，只适用于cookie和iframe窗口。 跨域资源共享 CORS 设置服务器响应头 Access-Control-Allow-Origin 指定允许跨域的源，实现浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 JSON with Padding JSONP 动态插入script标签，通过script标签引入一个js文件， 在服务端输出JSON数据，客户端执行回调函数，从而解决了跨域的数据请求。 jsonp+padding–将json填充到一个盒子里，（使用回调函数获取json数据）；兼容性好，简单易用，支持浏览器与服务器双向通信。当然也有一些缺点：权限漏洞，只能发送GET请求，需要防止XSS。 window.name 一个窗口的声明周期内，窗口载入的所有页面都是共享一个name属性的，每个页面都对window.name有读写权限，其属性持久存在，不因新页面载入而进行充值。 在原页面中使用一个隐藏的iframe充当中间人角色，由iframe去获取数据，src设为目标页面，再把src设置跟原页面同一个域，否则受到同源策略的限制。原页面再去得到iframe获取到的数据，iframe的window.name。 postMessage H5提供的一个API","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://screw-hand.com/tags/web/"}]},{"title":"从HTTP到互联网协议，浏览器与服务器之间不得不说的故事","slug":"http","date":"2019-03-28T09:19:26.000Z","updated":"2024-03-17T09:23:23.044Z","comments":true,"path":"/post/http/","link":"","permalink":"https://screw-hand.com/post/http/","excerpt":"浏览器与服务器之间美好约定 过桥米线的传说相传，清朝时滇南蒙自市城外有一湖心小岛，一个秀才到岛上读书，秀才贤慧勤劳的娘子常常弄了他爱吃的米线送去给他当饭，但等出门到了岛上时，米线已不热了。后来一次偶然送鸡汤的时候，秀才娘子发现鸡汤上覆盖着厚厚的那层鸡油有如锅盖一样，可以让汤保持温度，如果把佐料和米线等吃时再放，还能更加爽口。于是她先把肥鸡、筒子骨等熟好清汤，上覆厚厚鸡油;米线在家烫好，而不少配料切得薄薄的到岛上后用滚油烫熟，之后加入米线，鲜香滑爽。此法一经传开，人们纷纷仿效，因为到岛上要过一座桥，也为纪念这位贤妻，后世就把它叫做”过桥米线”。","text":"浏览器与服务器之间美好约定 过桥米线的传说相传，清朝时滇南蒙自市城外有一湖心小岛，一个秀才到岛上读书，秀才贤慧勤劳的娘子常常弄了他爱吃的米线送去给他当饭，但等出门到了岛上时，米线已不热了。后来一次偶然送鸡汤的时候，秀才娘子发现鸡汤上覆盖着厚厚的那层鸡油有如锅盖一样，可以让汤保持温度，如果把佐料和米线等吃时再放，还能更加爽口。于是她先把肥鸡、筒子骨等熟好清汤，上覆厚厚鸡油;米线在家烫好，而不少配料切得薄薄的到岛上后用滚油烫熟，之后加入米线，鲜香滑爽。此法一经传开，人们纷纷仿效，因为到岛上要过一座桥，也为纪念这位贤妻，后世就把它叫做”过桥米线”。 好的，故事就这里。 HTTP..协议？首先我们先来简单了解下什么是HTTP协议。 浏览器，大家都不陌生。地址栏输入一个网址，对应的网页就会跳出来，那么，这个网页是怎么来的呢？是浏览器自己弄出来的吗？显然不是，网站的所有资源都源于服务器；浏览器只是拿到服务器的资源，“翻译”一下给呈现给用户。那么，浏览器是通过什么方式告诉服务器我需要这个网页，而服务器又怎么知道浏览器需要的是哪个页面？浏览器与服务器的交互有很多种，最常见的一种是HTTP请求，即—–HTTP协议。 HTTP协议约定了两者之间的沟通方式，才不会牛头马嘴。协议由请求（requset）与响应（reponse）触发。 HTTP是因特网上一种常见的数据传输协议 服务器：说起来你可能不信，是它先动手的！ 事务，URL，报文接下来我们来了解下HTTP协议的体现过程。 浏览器的地址栏输入网址，将会发送一个HTTP请求；服务器收到浏览器的请求，响应数据给浏览器；浏览器解析资源渲染到界面。这种通信方式使用HTTP报文的格式化数据块进行。至此，一条完整的请求和响应命令，整个过程称之为HTTP事务。 浏览器凭借着URL，准确地请求资源，服务器响应并传输回数据。每个web服务器资源都有一个名字——统一资源标识符（url）。有了这个名字，浏览器才能找到对应的资源，url有特定的标准格式。一个url分为3个部分：协议代码，装由所需文件的计算机地址和主机资源的具体位置。scheme://host[:post]/path/filename scheme - 协议名称 host - IP地址或计算机名称 post - 服务器端口 path - 文件路径 filename - 文件名 例：http://www.4399.com/ PS：我们说的“网址”、“域名”都属于url的范畴。 以HTTP的角度讲，浏览器（Browser）是客户端（Client），服务器（Server）是服务端（Server）；也就是说浏览器和服务器模式是B&#x2F;S结构，即：Browser&#x2F;Server(浏览器&#x2F;服务器)结构。 客户端发送请求报文，服务器回复响应报文；请求报文和响应报文的格式都由以下三个部分组成 起始行：由方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔 首部字段：由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔，关于请求&#x2F;响应的信息 主体：要发送给服务器的请求数据，或是服务器回复的响应数据 一个简单的HTTP实例 图源于《HTTP权威指南》 详解请求报文和响应报文请求报文和响应报文的差异不大，可以对比了解。 请求报文 响应报文 说明 起始行 请求行：请求url、HTTP版本、请求方法 响应行：HTTP版本，状态码， 状态码短语 用空格分隔 首部字段 请求头：数量不定，关于客户端的请求信息 请求行：关于服务器的响应信息 特定的分类用于请求头或用于响应头 主体 请求主体：一般是POST方法的请求数据 响应主体：HTTP响应请求的真正数据 HTTP所传输的内容 方法与状态码即使是同一个url，如果使用了其他的请求方法，服务器没有为url设置相对应的响应方法，那浏览器也不会拿到正确的资源，可能会出现的是几个数字（状态吗）和一句短语（原因短语）； https://screw-hand.com/_ 404代表了什么？ 因此最后小节我们有必要学习HTTP的请求方法和状态码。 根据HTTP标准，HTTP请求定义了多种请求方法，在不同场景下执行不同的动作，常见的有…GET：向服务器请求资源（最常用的HTTP方法）POST：输入数据（一般用于用户登录，付款等）PUT：写入文档（更新数据，发表文章，评论等）DELETE：删除请求资源（删除资源，但服务器不一定会删除） 为了便于理解，我们拿两个使用频率最高的方法比较一下。 GET与POST的区别 便利：浏览器后退对GET请求无影响，浏览器主动缓存GET请求，而POST不缓存且后退历史再次提交请求 参数：GET请求参数记录在原url后且有长度限制，而POST中的参数记录在请求主体中 安全：GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息 编码：GET请求只能进行url编码，而POST支持多种编码方式 状态码：三位数字组成，第一个数字定义了响应的类别，且有五种可能取值 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 短语：对状态码的描述，帮助用户理解状态码原因 以下是常见的响应状态码和短语 200 OK &#x2F;&#x2F;客户端请求成功 304 Not Modified &#x2F;&#x2F;请求资源的缓存可以使用，响应缓存的文件 400 Bad Request &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解 401 Unauthorized &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务 404 Not Found &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL 500 Internal Server Error &#x2F;&#x2F;服务器发生不可预期的错误 503 Server Unavailable &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常 以该url - https://screw-hand.com/_ 为例，这个地址是没有任何资源的，故服务器返回了404提示我们Not Found，原因可能是：之前的资源被删除了，所以这里没有资源了亦或者根本就没有资源。这里我们只是单纯网址最后打多了一个_而已。 唧唧歪歪了那么多，我们再结合开头的故事小结一下。 《过桥米线》中，娘子送米线给丈夫，丈夫食用完娘子回家；类似浏览器与服务器之间使用请求和响应完成一个HTTP事务 米线是娘子送给丈夫的午餐；而则浏览器使用HTTP报文这种格式发送数据供服务器响应，报文只是格式，为的是发送数据 娘子曾尝试赶马车送餐，不过米线还是凉了；正如HTTP有多种请求方法，合理使用请求方法服务器方可正确响应资源 恭喜读者了解了HTTP协议的一些基本概念，想深入探索的的朋友请往下看… HTTP背后的组织很高兴读者继续下划，那么现在我们已经认识了HTTP这位朋友，（从读者学会网上冲浪的那一刻，它就一直在你身边），接下来我们来认识一下这位朋友所在的组织互联网协议。 《名侦探柯南》中的琴酒，黑衣组织（酒厂）的高级成员，可以得到“那位先生”的直接命令。 HTTP也并非单枪作战，背后也犹如琴酒背后的酒厂，那么我们来介绍下“酒厂”。 互联网协议，五层模型什么是互联网？ 互联网（英语：Internet），是21世纪之始网络与网络之间所串连成的庞大网络，这些网络以一组标准的网络TCP&#x2F;IP协议族相连，连接全世界几十亿个设备，形成逻辑上的单一巨大国际网络。 ——wiki百科 ……这，也太概念化了吧？？ 简单一句话：世界上所有的网络组成起来就是互联网。 PS：互联网、因特网、万维网的概念之后再讨论，本篇文章的重要在于HTTP。 五层模型所有的网络环境组成了互联网，所以互联网很庞大，从模型上有3种分层方式： OSI分层 （7层） TCP&#x2F;IP分层（4层） 五层协议 （5层） 就像“酒厂”一样，一个优秀的暗杀组织，肯定结构清晰，分工明确；伏特加跟着琴酒清除卧底，然后其他人不是卧底就是渣渣，是的，结构清晰，谁是大反派谁是卧底谁是渣一下子就看出来了；分工明确，琴酒一个人为组织拼死拼活，伏特加给琴酒开车，其他人，其他人.. 不知道琴酒先生会怎么想？ 琴酒：酒厂都是假酒，这活没法干了!(摔酒瓶) 这里我们主要说说五层模型。 五层模型将互联网分成了5个层，每一个层都定应了很多协议，所有的协议都是互联网协议。 应用层(Application Layer): 规定应用程序的数据格式。 应用程序协议传输层(Transport Layer): 建立”端口到端口”的通信 UDP协议 TCP协议网络层(Network Layer)： 建立”主机到主机”的通信 IP协议 ARP协议链接层(Link Layer)：在“实体层”上方，确定了0和1的分组方式 以太网协议实体层(Physical layer)：把电脑连接起来的物理手段。负责传送0和1的电信号 顺序从下到上看，越下面的层，越靠近硬件；越上面的层，越靠近用户。 HTTP连接方式HTTP属于应用层的一种互联网协议，基于TCP&#x2F;IP协议，是两者的一种具体运用。五层模型中的应用层除了HTTP还有其他的协议。 http：超文本传输协议 https：安全超文本传输协议 IP：TCP&#x2F;IP协议 ftp：文件传输协议 SMTP：邮件传输协议 HTTP协议位于TCP&#x2F;IP上层，HTTP使用TCP&#x2F;IP传输报文数据。 看到这里，应该理解了浏览器发送HTTP请求，是通过TCP&#x2F;IP的方式与服务器链接的。 如何建立TCP连接？ 三次握手：建立一个TCP连接时，需要客户端和服务器总共发送3个包 首先，请求新的TCP 连接，客户端向服务器发送一个小的 TCP 分组这个分组中，包含的SYN标记说明这是一个连接请求。（a ）。 接着，如果服务器接受了连接，会向客户端回送一个 TCP 分组，这个分组中的 SYN 和 ACK 标记都被置位，说明连接请求已被接受（b ）。 最后，客户端向服务器回送一条确认信息，通知它连接已成功建立 （c ）。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据；三次握手为了是连接服务器指定端口，建立TCP连接，并同步连接交换TCP信息。 断开TCP连接客户端需要和服务器发送四个包，最终确认断开。因此称为四次挥手，这里并不详细说明具体过程。 关于“酒厂”的介绍就到这里，读者到这里能对互联网有一个大概的了解就行了，我们继续探索HTTP。 回到http保时捷356-A是琴酒的爱车，黑色风格是他的穿衣风格，不记住死人的名字，每次只执行一次任务，但使命必达（柯南是个例外），必要时穷追不舍。 “不好意思啊伏特加，已经杀掉的人的脸和名字，我是从来不去记的。” HTTP在某方面也跟琴酒有点类似，每次连接只能处理一个请求（但可以使用持久连接），不关心处理了多少条事务，可以传输多种类型数据：文本，图片，网页，音频等.. PS：事务结束连接后，TCP可使连接保持打开状态，这种技术叫持久性连接 正式给HTTP一个简介： 超文本传输协议 (Hyper Text Transport Protocol, HTTP)最为广泛的一种网络传输协议 基于TCP&#x2F;IP通信协议来传递数据 连接所有的WWW文件都必须遵守这个标准 无连接：限制每次连接只处理一个请求 任何类型的数据都可以通过HTTP发送 无状态协议：对于事务处理没有记忆能力 HTTPS虽说浏览器发送请求给服务器，但HTTP传输数据并不是直达目的服务器的。且HTTP是使用明文（不加密）传输数据的。这意味者请求在发送过程中，可能数据会被抓到导致泄露纂改，或经过某个网关&#x2F;代理被拦截下来自己的身份被冒充，因此HTTP并不安全，为了确保请求能准确加密送达服务器，HTTPS出现了。 还记得之前一笔带过的TCP&#x2F;IP分层（4层）吗？ 如何加密？ HTTPS在安全的传输层上发送HTTP，在这里先加密后发送报文给TCP。同样遵循一层有一个或多个协议，安全层通过SSL或TLS协议实现（SSL采用公开密钥加密），安全层使得即使请求被第三方获取，也无法识别数据内容。 这里涉及到密码学的一些基本知识 SSL的加密方式是公开密钥加密 密钥是一套对明文进行编码&#x2F;转码的算法 公开密钥即公开编码密钥 每个人拥有不同的解码密钥 非对称加密的编码和解码密钥不同 密码学上，没有绝对安全的密码，如果暴力破解，是可以破解出来的，只是时间长短问题，有些密码可能需要好几百年才能破解，详情了解MD5加密。 “锄头凿得好，没有挖不到的墙角。” 签名与证书 服务器远在他乡，有时候网页打不开都得先看下wifi信号是不是不好，再检测下站点的服务器是不是问题；那正常情况下，又有谁能保证请求一定送达服务器？ 我们可以考虑给HTTP的报文签名，以备注报文的编写作者。同时，我们需要一个公正的、值得信赖的组织，保证这个连接是安全的。 数字签名技术使用加密系统给报文签名，说明是谁编写的报文，同时也能证明报文没有被篡改过，这可以保证报文的准确传输。 服务器证书，SSL数字证书的一种形式，是因特网上的“ID卡”，由官方的“证书颁发机构”签发。记录了服务器名称，过期时间，证书发布者和发布者的数字签名等。 SSL不检测站点服务器的证书，现代浏览器会自行检查，若没有证书，浏览器会警告用户连接并不安全。 浏览器检测证书 一个未正确配置SSL的网址，打开看看自己的浏览器有没有对SSL检测？https://self-signed.badssl.com/ 相信比我更敏慧的你早已发现：”S”代表safe(安全)，safe是SSL&#x2F;TLS。 基本概念已经知晓，是时候来一波SSL连接了。 SSL握手 SSL握手发生在HTTP传输加密报文前，它们会完成以下工作： 交换协议版本号 选择一个两端都了解的密码（公钥） 对两端身份进行认证 生成临时密钥，加密通道 由于多了一次SSL握手过程，相同的网络环境下，HTTPS比HTTP要费时。 兼容HTTP 如果自己的网站从HTTP升级到了HTTPS，那么需要考虑用户可能会按照之前的习惯http://screw-hand.com/，而不是输入https://screw-hand.com/，这导致用户并不能使用该网站的HTTPS协议。所幸，http和https使用的默认端口(port)不同。http的默认端口是80或者8080，https默认端口是443。我们可以在http的默认端口设置代理使之跳转到https的443。 http://screw-hand.com/ &#x3D; http://screw-hand.com:80/ https://screw-hand.com/ &#x3D; http://screw-hand.com:443/ 以上四个超链接都可正确打开此博客主页。 PS：上文提及的URL格式中port参数出现了 对比HTTP 按照惯例，接下来是小结的时间。 HTTPS：超文本安全传输协议(Hypertext Transfer Protocol Secure) 以安全为目标的HTTP通道，简单讲是HTTP的安全版 在HTTP下加入SSL层，提供加密传输和身份验证功能 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443 HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50% HTTPS是现行架构下最安全的解决方案，并非绝对安全 不止浏览器再次把话题的范围放大。HTTP也并不是浏览器特有使用的协议，更运行上在其他的客户端(Client)上，如印象笔记，微信，音乐播放器等，甚至自己写的一个网络爬虫程序，也是HTTP客户端。只要可以发送HTTP报文的，都是HTTP的客户端。浏览器是最经典的HTTP客户端，且浏览器支持HTTP协议的同时，更支持ftp， file协议。 C&#x2F;S结构：客户机&#x2F;服务器模式，是基于企业内部网络的应用系统。由于Web浏览器的兴起，B&#x2F;S模式逐步取代了C&#x2F;S模式，被更广泛地应用。 B&#x2F;S结构基于C&#x2F;S结构，是其本身的一种改良。 web控件而客户端到服务器之间并不是直连的。也就是说，报文在传输的过程，需要经过好几个结构组件，如代理、缓存、网关、隧道、Agent代理。举个例子，我们浏览一个美国的网站，如果网站配置了CDN，而在国内正好有某个节点有缓存；且缓存未过期。这时候我们的请求被国内的节点处理，返回的结果是其缓存，从物理角度看，这远比直接跑到美国拿数据要快得过。 尾声这是在下写的第一篇博文，本意是简单写写HTTP协议的。网上冲浪离不开这位老朋友，因此我觉得第一篇博文以HTTP为话题多少有点起点性的意义。技术型的文章如果太多术语，逼格是高了，但是会隐晦难懂。因此在保证文章质量的前提下，插入了两个小故事，使得趣味性高一点。更深层的技术也没怎么提及，所以这篇文章的定位是科普文章。 未完待续那么，关于HTTP就到此为止了吗？不不不，HTTP的话题太过庞大，文章简述了一些比较主要的知识点而已，更衍生出了很多相关的话题。 互联网、因特网、万维网是什么？ 浏览器访问网页的详细过程？ 五层模型中的其他协议 web控件的功能？ https与web安全 如何设置缓存 用户认证机制 在这之前也有很多优秀的前辈的写过相关的文章，这些话题以后再慢慢提及。还有HTTP的历史需要读者自行探索，这里介绍两本书：《HTTP权威指南》、 《图解HTTP》。 相信看完整篇文章，读者再去看书也会有更深层次的收获。 结语《过桥米线》中，妻子送米线表达对夫君的爱意和仕途的支持；浏览器与服务器之间使用HTTP协议交互；所以我想：HTTP协议应该是浏览器和服务器之间的美好约定吧。 琴酒纵使能力再强，也属于“酒厂”组织的其中一个成员；HTTP固然如此，名气再大，也希望读者不要忘记在背后支持它的互联网协议。 最后，希望朋友吃米粉的时候能想起HTTP；喝酒的时候能想起互联网协议；喝酒吃米粉的时候能想到我。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://screw-hand.com/tags/web/"}]},{"title":"前端常见缓存机制","slug":"web-cache","date":"2019-03-28T09:11:11.000Z","updated":"2024-03-17T09:23:23.108Z","comments":true,"path":"/post/web-cache/","link":"","permalink":"https://screw-hand.com/post/web-cache/","excerpt":"缓存是捷径，使http抄近道 cookieCookie 是服务器保存在浏览器的一小段文本信息。浏览器每次向服务器发出请求，就会自动附上这段信息，是前端的一种常见而又传统的缓存机制。 作用 用于保存页面信息：如自动登录，记住用户名 以域名为单位，数量大小有4k-10k，有过期时间 js中通过doucment.cookie调用 cookie的传递从服务器端，发送cookie给客户端，是对应的Set-Cookie头信息。包括了对应的cookie的名称，值，以及各个属性。从客户端发送cookie给服务器，对应Cookie头信息，不发送cookie的各个属性，只发送对应的名称和值。","text":"缓存是捷径，使http抄近道 cookieCookie 是服务器保存在浏览器的一小段文本信息。浏览器每次向服务器发出请求，就会自动附上这段信息，是前端的一种常见而又传统的缓存机制。 作用 用于保存页面信息：如自动登录，记住用户名 以域名为单位，数量大小有4k-10k，有过期时间 js中通过doucment.cookie调用 cookie的传递从服务器端，发送cookie给客户端，是对应的Set-Cookie头信息。包括了对应的cookie的名称，值，以及各个属性。从客户端发送cookie给服务器，对应Cookie头信息，不发送cookie的各个属性，只发送对应的名称和值。 使用方式 设置：doucument.cookie=&quot;name=value;max-age=seconds;Path=path;HttpOnly;&quot;等；一次设置一个值，同名参数会进行覆盖 指定过期时间的cookie会存储在本地，没有指定时为session Cookie，会话结束后cookie删除，设置domain和paath可指定cookie的作用域。httponly指定cookie必须用http或https传输，该属性可限制js访问操作此cookie。secure可指定cookie只能使用https传输。 读取：document.cookie会返回cookie的名和值，其他参数不会返回，如：a&#x3D;1;b&#x3D;2; 每个cookie的名值通过分号分割。 删除：将max-age设置为-1 cookie优点可配置性和可扩展性 可以在客户端上保存用户数据，起到简单的缓存和用户身份识别等作用 保存用户的偏好，比如网页的字体大小、背景色等等。 记录用户的行为 cookie的缺陷数据数量：每个cookie的大小限制在4k，不同的浏览器对同一个域下的cookie的数量有限制，IE6 20，IE7+ 50，Firefox 50，Safari ∞，Chrome 53。数量超出时， IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。保险起见cookie的数量应控制在20个，单个cookie大小应小于4KB。 安全性问题：HTTP请求中的cookie是明文传递（HTTPS不是），故敏感信息不能使用cookie存储，如用户密码等。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 网络负担：cookie会被附加在每个HTTP请求中，在请求和响应时都会被传输，所以增加了流量的损失。 seesion存储会话机制，保存在服务器上。客户端访问服务器时，服务器把客户端信息以某种形式记录在服务器上。再次访问时只需要从该Session中查找该客户的状态就可以了。 标识用户身份： 用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId，cookie把SessiondId自动带到服务器。 session创建：当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了sessionId，如果已包含则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（检索不到，会新建一个）。如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId，sessionId的值是一个既不会重复，又不容易被找到规律以仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。 禁用cookie：如果客户端禁用了cookie，通常有两种方法实现session而不依赖cookie。1）URL重写，就是把sessionId直接附加在URL路径的后面。2）表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器 Session共享：对于多网站(同一父域不同子域)单服务器，我们需要解决的就是来自不同网站之间SessionId的共享。由于域名不同(aaa.test.com和bbb.test.com)，而SessionId又分别储存在各自的cookie中，因此服务器会认为对于两个子站的访问,是来自不同的会话。解决的方法是通过修改cookies的域名为父域名达到cookie共享的目的,从而实现SessionId的共享。带来的弊端就是，子站间的cookie信息也同时被共享了。 cookie与session的区别1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。 web Storageweb 本地存储对浏览器来说，使用 Web Storage 存储键值对比存储 Cookie 方式更直观，而且容量更大，它包含两种：localStorage 和 sessionStorage sessionStorage（临时存储） ：为每一个数据源维持一个存储区域，在浏览器打开期间存在，包括页面重新加载localStorage（长期存储） ： 一直存储在本地，数据存储是永久的，除非用户或程序对其进行删除操作；localStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 sessionStorage 和 localStorage 的用法基本一致，引用类型的值要转换成JSON 特点：域内安全、永久保存。即客户端或浏览器中来自同一域名的所有页面都可访问localStorage数据且数据除了删除否则永久保存，但客户端或浏览器之间的数据相互独立。数据不会随着Http请求发送到后台服务器；存储数据的大小至少4MB。 存储方式：以键值对(Key-Value)的方式存储字符串。主要应用：购物车、客户登录、游戏存档。。。可储存的数据类型：数组，图片，json，样式，脚本。。。（只要是能序列化成字符串的内容都可以存储） JS APIlocalStorage.setItem(键名，键值) 在本地客户端存储一个字符串类型的数据localStorage.getItem(键名) 读取已存储在本地的数据localStorage.removeItem(键名) 移除已存储在本地的数据localStorage.clear() 移除本地存储所有数据 sessionStorage中的四个函数与以上localStorage类的函数用法基本一致 cookie与web Storage的区别1、cookie数据始终在同源的http请求中携带2、cookie可设置路径，限制其作用域3、存储大小，cookie不能超过4k，web Storage可达5M4、cookie有数据有效期，web Storage无5、作用域不同，sessionStroage不在不同浏览器窗口共享， localStorage与cookie在所有同源窗口共享 cookie与webStorage的使用方法1、兼容性：IE9+支持web Storage，cookie作为远古时期产物，无兼容性问题2、交互性：web Storage不与服务器交互，需要与服务器交互时使用cookie3、数据大小：cookie不能超过4k，web Storage可达5M","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://screw-hand.com/tags/web/"}]},{"title":"嗜夜","slug":"killing-night","date":"2019-03-27T13:32:10.000Z","updated":"2024-03-17T09:23:23.076Z","comments":true,"path":"/post/killing-night/","link":"","permalink":"https://screw-hand.com/post/killing-night/","excerpt":"","text":"夜晚的钟声慢慢敲起。原始丛林狼群双眸诡异的光芒。无处安放的灵魂也回归平静。 教徒合诵古老冗长的咒语。祭坛的封印一步步被封开。古墓冰尸发出阵阵哀嚎。锁链断裂，癫狂抑制不住。屠杀活动的序幕早已开始。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://screw-hand.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"用信鸽来解释 HTTPS","slug":"https","date":"2019-03-02T16:00:00.000Z","updated":"2024-03-17T09:23:23.056Z","comments":true,"path":"/post/https/","link":"","permalink":"https://screw-hand.com/post/https/","excerpt":"2019&#x2F;01&#x2F;09 | 分类： 基础技术 | 2 条评论 | 标签： https 译文出处： oschina | 原文出处：freecodecamp 密码学是一门难以理解的学科，因为它充满了数学定理。但是除非你要实际开发出一套加密算法系统，否则你是没必要强制理解那些深奥的数学定理的。 如果你阅读本文的目的是想设计下一套 HTTPS 协议，那我只能抱歉的说本文的知识还远远不够；如果不是的话，那么就煮杯咖啡，轻松愉悦的阅读本文吧。 爱丽丝、鲍伯和 … 信鸽？你在互联网上从事的任何活动（阅读这篇文章、在亚马逊上购物、上传图片等）归结到底都是从某台服务器上发送和接收信息。 这个说起来可能有点抽象，不如让我们假设这些消息都是由信鸽来传递的。我知道这个假设有些太过随意，但相信我 HTTPS 就是这样工作的，尽管它的速度快的多。 我们先不谈服务器、客户端或者黑客攻击，先来聊一下爱丽丝、鲍伯和马洛里。如果这已不是你第一次接触密码学理论，你应该会认识这些名字，因为他们经常在各种密码学文献中被提及。 一个简单的通信方式如果爱丽丝想给鲍伯发个消息，她会把消息绑在信鸽的腿上寄给鲍伯。然后鲍伯收到了消息，并阅读了它。这一切都是美好的。 但如果马洛里拦截了爱丽丝飞翔中的信鸽并且修改消息内容呢？鲍伯将无法知道爱丽丝发来的消息已经在传输过程中被修改了。 这就是 HTTP 的工作方式，很可怕吧？我绝不会通过 HTTP 发送我的银行凭证，希望你也不会。","text":"2019&#x2F;01&#x2F;09 | 分类： 基础技术 | 2 条评论 | 标签： https 译文出处： oschina | 原文出处：freecodecamp 密码学是一门难以理解的学科，因为它充满了数学定理。但是除非你要实际开发出一套加密算法系统，否则你是没必要强制理解那些深奥的数学定理的。 如果你阅读本文的目的是想设计下一套 HTTPS 协议，那我只能抱歉的说本文的知识还远远不够；如果不是的话，那么就煮杯咖啡，轻松愉悦的阅读本文吧。 爱丽丝、鲍伯和 … 信鸽？你在互联网上从事的任何活动（阅读这篇文章、在亚马逊上购物、上传图片等）归结到底都是从某台服务器上发送和接收信息。 这个说起来可能有点抽象，不如让我们假设这些消息都是由信鸽来传递的。我知道这个假设有些太过随意，但相信我 HTTPS 就是这样工作的，尽管它的速度快的多。 我们先不谈服务器、客户端或者黑客攻击，先来聊一下爱丽丝、鲍伯和马洛里。如果这已不是你第一次接触密码学理论，你应该会认识这些名字，因为他们经常在各种密码学文献中被提及。 一个简单的通信方式如果爱丽丝想给鲍伯发个消息，她会把消息绑在信鸽的腿上寄给鲍伯。然后鲍伯收到了消息，并阅读了它。这一切都是美好的。 但如果马洛里拦截了爱丽丝飞翔中的信鸽并且修改消息内容呢？鲍伯将无法知道爱丽丝发来的消息已经在传输过程中被修改了。 这就是 HTTP 的工作方式，很可怕吧？我绝不会通过 HTTP 发送我的银行凭证，希望你也不会。 隐蔽的密码那么如果爱丽丝和鲍勃都非常的机智。他们一致认同使用一种隐蔽的密码来书写他们的信息。他们会将信息中的每个字母按照字母表中的顺序前移三位。比如，D→A，E→B，F→C。如此一来，原文为 “secret message” 的信息就变成了 “pbzobq jbppxdb” 。 那现在如果马洛里再截获了信鸽，她既不能做出有意义的修改同时也不会知道信息的内容，因为她不知道隐蔽的密码到底是什么。然而鲍勃却可以很容易反转密码，依靠 A → D, B → E, C → F 之类的规则破译信息的内容。加密后的信息 “pbzobq jbppxdb” 会被破解还原为 “secret message” 。 搞定！ 这就是对称密匙加密，因为如果你知道如何加密一段信息那么你同样可以解密这段信息。 上述的密码通常被称为凯撒码。在现实生活中，我们会使用更为奇特和复杂的密码，但原理相同。 我们如何决定密匙？如果除了发信者和收信者之外没有人知道使用的是什么密匙，对称密匙加密是非常安全的。在凯撒加密中，密匙就是每个字母变到加密字母需要移动多少位的偏移量。我之前的距离中，使用的偏移量是 3 ，但是也可以用 4 或者 12 。 问题是如果爱丽丝和鲍勃在开始用信鸽传信之前没有碰过头，他们没有一个安全的方式来确立密匙。如果他们自己来在信中传递密匙，马洛里就会截获信息并发现密匙。这就使得马洛里可以在爱丽丝和鲍勃开始加密他们的信息之前或之后，阅读到他们信息的内容并按照她的意愿来篡改信息。 这是一个中间人攻击的典型例子，避免这个问题的唯一方法就是收发信的两方一起修改他们的编码系统。通过信鸽传递盒子 所以爱丽丝和鲍勃就想出了一个更好的系统。当鲍勃想要给爱丽丝发送信息时，他会按照如下的步骤来进行： 鲍勃向爱丽丝送一只没有携带任何信息的鸽子。 爱丽丝给鲍勃送回鸽子，并且这只鸽子带有一个有开着的锁的盒子，爱丽丝保管着锁的钥匙。 鲍勃把信放进盒子中，把锁锁上然后把盒子送给爱丽丝。 爱丽丝收到盒子，用钥匙打开然后阅读信息。 这样马洛里就不能通过截获鸽子来篡改信息了，因为她没有打开盒子的钥匙。当爱丽丝要给鲍勃发送消息的时候同样按照上述的流程。 爱丽丝和鲍勃所使用的流程通常被称为非对称密钥加密。之所以称之为非对称，是因为即使是你把信息编码（锁上盒子）也不能破译信息（打开锁住的盒子）。 在术语中，盒子被称为公匙而用来打开盒子的钥匙被称为私匙。 如何信任盒子如果你稍加注意你就会发现还是存在问题。当鲍勃收到盒子时他如何能确定这个盒子来自爱丽丝而不是马洛里截获了鸽子然后换了一个她有钥匙能打开的盒子呢？ 爱丽丝决定签名标记一下盒子，这样鲍勃收到盒子的时候就可以检查签名来确定是爱丽丝送出的盒子了。 那么你们之中的一些人可能就会想了，鲍勃如何打一开始就能识别出爱丽丝的签名呢？这是个好问题。爱丽丝和鲍勃也确实有这个问题，所以他们决定让泰德代替爱丽丝来标记这个盒子。 那么谁是泰德呢？泰德很有名的，是一个值得信任的家伙。他会给任何人签名并且所有人都信任他只会给合法的人签名标记盒子。 如果泰德可以确认索要签名的人是爱丽丝，他就会在爱丽丝的盒子上签名。因此马洛里就不可能搞到一个有着泰德代表爱丽丝签了名的盒子，因为鲍勃知道泰德只会给他确认过的人签名，从而识破马洛里的诡计。 泰德的角色在术语中被称为认证机构。而你阅读此文时所用的浏览器打包存有许多认证机构的签名。 所以当你首次接入一个网站的时候你可以信任来自这个站点的盒子因为你信任泰德而泰德会告诉你盒子是合法的。 沉重的盒子现在爱丽丝和鲍勃有了一个可靠的系统来进行交流，然他们也意识到让鸽子携带盒子比原本只携带信件要慢一些。 因此他们决定只有在选择用对称加密来给信息编码（还记得凯撒加密法吧？）的密匙时，使用传递盒子的方法（非对称加密）。 这样就可以二者的优点兼具了，非对称加密的可靠性和对称加密的高效性。 现实世界中我们不会用信鸽这样慢的送信手段，但用非对称加密来编码信息仍要慢于使用对称加密技术，所以我们只有在交换编码密匙的时候会使用非对称加密技术。 现在你已经了解了HTTPS是如何工作的了，你的咖啡也应该准备好了。好好享用吧你受之无愧。","categories":[{"name":"转载","slug":"转载","permalink":"https://screw-hand.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://screw-hand.com/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"JavaScript ES2019 中的 8 个新功能","slug":"ES2019","date":"2019-01-08T16:00:00.000Z","updated":"2024-03-17T09:23:22.640Z","comments":true,"path":"/post/ES2019/","link":"","permalink":"https://screw-hand.com/post/ES2019/","excerpt":"JavaScript 一直在不断改进和添加更多新功能。TC39 已经完成，并批准了 ES2019 的 8 项新功能。这个过程包含了 5 个阶段： 第 0 阶段：稻草人 第 1 阶段：提案 第 2 阶段：草案 第 3 阶段：候选 第 4 阶段：已完成 &#x2F; 已批准 第 0 阶段的提案：https://github.com/tc39/proposals/blob/master/stage-0-proposals.md 第 1 至 3 阶段的提案：https://github.com/tc39/proposals 第 4 阶段的提案：https://github.com/tc39/proposals/blob/master/finished-proposals.md 废话不多说，接下来让我们来逐一介绍这些功能。","text":"JavaScript 一直在不断改进和添加更多新功能。TC39 已经完成，并批准了 ES2019 的 8 项新功能。这个过程包含了 5 个阶段： 第 0 阶段：稻草人 第 1 阶段：提案 第 2 阶段：草案 第 3 阶段：候选 第 4 阶段：已完成 &#x2F; 已批准 第 0 阶段的提案：https://github.com/tc39/proposals/blob/master/stage-0-proposals.md 第 1 至 3 阶段的提案：https://github.com/tc39/proposals 第 4 阶段的提案：https://github.com/tc39/proposals/blob/master/finished-proposals.md 废话不多说，接下来让我们来逐一介绍这些功能。 1.可选的 catch 绑定可选的 catch 绑定提案是为了能够选择性地移除使用不到的 catch 绑定。 try &#123; &#x2F;&#x2F; trying to use a new ES2019 feature &#x2F;&#x2F; which may not be implemented in other browsers &#125; catch (unused) &#123; &#x2F;&#x2F; revert back to old way &#125; 现在可以删除使用不到的绑定。 try &#123; ... &#125; catch &#123; ... &#125; 2.JSON 超集这个提案的目的是让 JSON 字符串可以包含未转义的 U+2028 LINE SEPARATOR 和 U+2029 PARAGRAPH SEPARATOR 字符，而 ECMAScript 字符串是不能包含这些字符的。在 ES2019 生效之前，这样做会出现“SyntaxError: Invalid or unexpected token”错误。 const LS &#x3D; eval(&#39;&quot;\\u2028&quot;&#39;); const PS &#x3D; eval(&quot;&#39;\\u2029&#39;&quot;); 3. 符号描述符号是在 ES2015 中引入的，具有非常独特的功能。在 ES2019 中可以提供给定的描述，目的是避免间接从 Symbol.prototype.toString 获取描述。 const mySymbol &#x3D; Symbol(&#39;myDescription&#39;); console.log(mySymbol); &#x2F;&#x2F; Symbol(myDescription) console.log(mySymbol.toString()); &#x2F;&#x2F; Symbol(myDescription) console.log(mySymbol.description); &#x2F;&#x2F; myDescription 4. 修订版的 Function.prototype.toString之前的函数原型已经有 toString 方法，但是在 ES2019 中，它经过了修订，可以包含函数内的注释，不过不适应于箭头函数。 function &#x2F;* comment *&#x2F; foo &#x2F;* another comment *&#x2F; ()&#123;&#125; &#x2F;&#x2F; Before console.log(foo.toString()); &#x2F;&#x2F; function foo()&#123;&#125; &#x2F;&#x2F; Now ES2019 console.log(foo.toString()); &#x2F;&#x2F; function &#x2F;* comment *&#x2F; foo &#x2F;* another comment *&#x2F; ()&#123;&#125; &#x2F;&#x2F; Arrow Syntax const bar &#x2F;* comment *&#x2F; &#x3D; &#x2F;* another comment *&#x2F; () &#x3D;&gt; &#123;&#125; console.log(bar.toString()); &#x2F;&#x2F; () &#x3D;&gt; &#123;&#125; 5.Object.fromEntries它是 Object.entries 方法的反向操作，可用于克隆对象。 const obj &#x3D; &#123; prop1: 1, prop2: 2, &#125;; const entries &#x3D; Object.entries(obj); console.log(entries); &#x2F;&#x2F; [ [ &#39;prop1&#39;, 1 ], [ &#39;prop2&#39;, 2 ] ] const fromEntries &#x3D; Object.fromEntries(entries); console.log(fromEntries); &#x2F;&#x2F; Object &#123; prop1: 1, prop2: 2 &#125; console.log(obj &#x3D;&#x3D;&#x3D; fromEntries); &#x2F;&#x2F; false 不过需要注意的是，嵌入式对象 &#x2F; 数组都只是引用。 const obj &#x3D; &#123; prop1: 1, prop2: 2, deepCopy: &#123; mutateMe: true &#125; &#125;; const entries &#x3D; Object.entries(obj); const fromEntries &#x3D; Object.fromEntries(entries); fromEntries.deepCopy.mutateMe &#x3D; false; console.log(obj.deepCopy.mutateMe); &#x2F;&#x2F; false 6. 格式化的 JSON.stringify这个提案是由同一个人提出来的，与 JSON 超集有关。ES2019 将使用 JSON 转义序列表示输出结果，而不是返回 UTF-16 代码单元。 &#x2F;&#x2F; Before console.log(JSON.stringify(&#39;\\uD800&#39;)); &#x2F;&#x2F; &quot;?&quot; &#x2F;&#x2F; Now ES2019 console.log(JSON.stringify(&#39;\\uD800&#39;)); &#x2F;&#x2F; &quot;\\ud800&quot; 7.String.prototype 的 trimStart 和 trimEnd String 原型已经有了 trim 方法，用来移除字符串开头和结尾的空格。而 ES2019 引入了 trimStart 和 trimEnd。 &#x2F;&#x2F; Trim const name &#x3D; &quot; Codedam &quot;; console.log(name.trim()); &#x2F;&#x2F; &quot;Codedam&quot; &#x2F;&#x2F; Trim Start const description &#x3D; &quot; Unlocks Secret Codes &quot;; console.log(description.trimStart()); &#x2F;&#x2F; &quot;Unlocks Secret Codes &quot; &#x2F;&#x2F; Trim End const category &#x3D; &quot; JavaScript &quot;; console.log(category.trimEnd()); &#x2F;&#x2F; &quot; JavaScript&quot; 8.Array.prototype 的 flat 和 flatMapflat 方法通过将所有子数组元素以递归方式连接到指定的深度来创建数组。默认深度为 1，使数组的第一层嵌套展平。 const arr &#x3D; [1, 2, [3, 4, [5, 6]]]; arr.flat(); &#x2F;&#x2F; [1, 2, 3, 4, [5, 6]] arr.flat(2); &#x2F;&#x2F; [1, 2, 3, 4, 5, 6] &#x2F;&#x2F; You can use Infinity to flatten all the nested arrays no matter how deep the array is const arrExtreme &#x3D; [1, [2, [3, [4, [5, 6, 7, [8, 9]]]]]]; arrExtreme.flat(Infinity); &#x2F;&#x2F; [1, 2, 3, 4, 5, 6, 7, 8, 9] flatMap 方法类似于 flat，并且还与 map 相关，它会先映射数组然后将其展平。 const arr &#x3D; [&#39;Codedam&#39;, &#39;is Awsome&#39;, &#39;!&#39;]; const mapResult &#x3D; arr.map(item &#x3D;&gt; item.split(&#39; &#39;)); console.log(mapResult); &#x2F;&#x2F; [ [ &#39;Codedam&#39; ], [ &#39;is&#39;, &#39;Awsome&#39; ], [ &#39;!&#39; ] ] const flatMapResult &#x3D; arr.flatMap(chunk &#x3D;&gt; chunk.split(&#39; &#39;)); console.log(flatMapResult); &#x2F;&#x2F; [&#39;Codedam&#39;, &#39;is&#39;, &#39;Awsome&#39;, &#39;!&#39;]; 其他 我还想强调一下现在处在第 3 阶段的一些有用的特性。 globalThis； BigInt； import()； 遗留的 RegEx； 私有的实例方法； String.prototype.matchAll。 英文原文：https://codedam.com/8-new-features-javascript-es2019/ 更多内容，请关注前端之巅。","categories":[{"name":"转载","slug":"转载","permalink":"https://screw-hand.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://screw-hand.com/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"不再性感，不再赚钱，数据科学的时代变了","slug":"database","date":"2019-01-08T16:00:00.000Z","updated":"2024-03-17T09:23:23.000Z","comments":true,"path":"/post/database/","link":"","permalink":"https://screw-hand.com/post/database/","excerpt":"作者：Vicki Boykis | 译者：阿拉丁 阅读数：678 2019 年 3 月 2 日 | 话题：大数据 AI 最佳实践 当你看到“数据科学”这个词时，会想到什么？你可能会觉得它是统计学、机器学习、深度学习和“21 世纪最性感的工作”等关键词的组合，或者你的脑海里会浮现出一个数据科学家的形象，她坐在电脑旁，将 AB 测试得到的结果拼接在一起，又或者你听很多人说过干这行有赚不完的钱（根据权威部门统计：入门级数据科学家的平均年薪约人民币 744253 元）。无论是哪一种，它都是迷人、聪明和复杂的。 从本文作者 Vicki Boykis 十年前进入这一领域以来，数据科学一直给人这样的印象，但现在，数据科学已经不再是当初的样子了。以下内容由 AI 前线编译，原文来自 Vicki Boykis 发表于个人博客的文章《Data science is different now》。 我最初是一名数据分析师。 我是否曾经提到过我有多讨厌 Excel 默认的数字字符串格式？ ——Vicki Boykis（@vboykis）2012 年 5 月 18 日 我经常是一边苦等 SQL 的运行结果、整理乱糟糟的 Excel 文件，一边看着 Hacker News 上有关海量数据挖掘的文章、Facebook 数据科学团队的新闻和谷歌首席经济学家 Hal Varian 写的文章，然后一边做着白日梦。 2012 年，我很幸运地被分配到了一个数据分析工程团队，他们正在将一些 ETL 作业从 Oracle 迁移到 Hadoop 上，以便满足不断增长的数据吞吐量要求。","text":"作者：Vicki Boykis | 译者：阿拉丁 阅读数：678 2019 年 3 月 2 日 | 话题：大数据 AI 最佳实践 当你看到“数据科学”这个词时，会想到什么？你可能会觉得它是统计学、机器学习、深度学习和“21 世纪最性感的工作”等关键词的组合，或者你的脑海里会浮现出一个数据科学家的形象，她坐在电脑旁，将 AB 测试得到的结果拼接在一起，又或者你听很多人说过干这行有赚不完的钱（根据权威部门统计：入门级数据科学家的平均年薪约人民币 744253 元）。无论是哪一种，它都是迷人、聪明和复杂的。 从本文作者 Vicki Boykis 十年前进入这一领域以来，数据科学一直给人这样的印象，但现在，数据科学已经不再是当初的样子了。以下内容由 AI 前线编译，原文来自 Vicki Boykis 发表于个人博客的文章《Data science is different now》。 我最初是一名数据分析师。 我是否曾经提到过我有多讨厌 Excel 默认的数字字符串格式？ ——Vicki Boykis（@vboykis）2012 年 5 月 18 日 我经常是一边苦等 SQL 的运行结果、整理乱糟糟的 Excel 文件，一边看着 Hacker News 上有关海量数据挖掘的文章、Facebook 数据科学团队的新闻和谷歌首席经济学家 Hal Varian 写的文章，然后一边做着白日梦。 2012 年，我很幸运地被分配到了一个数据分析工程团队，他们正在将一些 ETL 作业从 Oracle 迁移到 Hadoop 上，以便满足不断增长的数据吞吐量要求。 有没有“给白痴用的 Hadoop”？ 给小白用的 Hadoop 并不适合我。 ——Vicki Boykis（@vboykis）2012 年 8 月 16 日 我自愿成为第一个使用 Pig 和 Hive 的分析师，主要是因为我不想等到工程工作完成后才能访问我的数据。而且，我沉迷于数据科学家的光环——这些人开展很酷的实验，提出很酷的分析想法，并可以使用 MacBook。 我也想成为这样的人！所以，我在线学习了 Python，重温了我在大学学习过的统计学。在早期，并没有真正形式化的方法来学习“数据科学”，最多只能看看其他人在做什么、去参加聚会或者试着从人力资源招聘的职位描述中读出点什么。 在独自摸索了很长一段时间之后，我在过去的六年时间里已经在“数据科学”领域站稳了脚跟。并且，作为一名导师（但我之前并没有导师），我一直在回复电子邮件，和那些希望进入数据科学领域的人喝咖啡会面。 自 2012 年以来，数据科学行业发展极其迅速。它几乎经历了甘特炒作周期的每个阶段。 我们已经经历了早期采用阶段、有关人工智能和偏见的负面新闻、Facebook 等公司的第二轮和第三轮风险投资，现在正处于高采用增长阶段：银行、医疗保健公司和其他财富 100 强企业（这些公司已经落后市场五年）也在为机器学习招聘数据科学家。 很多东西都变了。大数据（记得 Hadoop 和 Pig 吗？）已经出局了，R 语言的采用率急剧上升，Python 成为经济学家的宠儿，而云计算再次改变了一切。 然而，媒体针对数据科学领域的炒作却没有变，一直在鼓吹数据科学家是“21 世纪最性感的职业”。但我现在认为这是一个很严重的问题，需要引起社区的注意。希望进入这个行业的初级数据科学家供过于求，而一旦他们获得了梦寐以求的“数据科学家”头衔，他们能够得到的东西与他们的期望其实是不匹配的。新数据科学家的供过于求 首先，我们来谈谈初级数据科学家的供过于求。针对数据科学的持续媒体炒作导致过去五年中市场上的初级人才数量激增。 这纯粹是道听途说的东西，所以不要太当真。但是，基于我自己作为简历筛选者、数据科学家导师、面试官、面试者，以及与从事类似职业的朋友和同事的对话，我有一种直觉，每个给定的数据科学职位（特别是入门级的科学职位）的候选人数量从 20 个增加到 100 个或更多。我最近了解到，我的一位朋友在招聘一个职位时收到了不止 500 份简历。 这都很正常，类似的情况还有很多。机器学习教父吴恩达的 AI 创业公司每周要求工作 70 到 80 个小时，但仍然收到了大量申请，甚至有人愿意免费做志愿者。在写这篇文章时，他们的办公室已经容不下更多的人。 要评估市场需求与供应之间的真正差距是非常非常困难的，不过我们可以从这里(https://www.wired.com/story/andrew-ngs-new-online-school/)开始着手。 对 4 月份招聘广告的研究发现，美国有超过 10,000 个针对人工智能或机器学习的职位空缺。 [超过 10 万人参加了 Fast.ai](http://xn--10fast-qo7i07amn353ae9cy36wyeg.ai/)（一家专注于推广人工智能的创业公司）的深度学习课程。 假设平均 MOOC 完成率约为 7％，那意味着有 7000 人可以填补这 10,000 个工作岗位。但是，今年是这样，那么明年呢？我们是否在假设数据科学创造的就业率是稳定的？如果实际情况不是这样的，那么数据科学就业市场有可能会萎缩。 LinkedIn 提供的数据表明，市场上有 151,717 个数据科学人才空缺。虽然目前还不清楚它们是不是就是指数据科学家，或者是只拥有部分技能的人，但我们假设是前者。因此，我们可以说美国现在有 150,000 多个数据科学家职位空缺。 我们假设有 100,000 个人已经参加了数据科学课程，并且其中有 7,000 个人会完成课程。 但是，上面这数字并没有考虑到其他的数据科学候选人计划和途径：Fast.ai 之外的 MOOC，比如 Coursera、Metis（超过 10 个全国性训练营）和 General Assembly（每 12 周就有 25 人参加）、来自加州大学洛杉矶分校等地的远程学位、分析和数据科学的本科学位、YouTube，等等。还有很多博士正在从学术界转向数据科学领域，但却无法在竞争极其激烈的就业市场中找到工作。 这篇文章指出，在 2015 年有 4 万个数据科学家职位空缺。总体而言，到 2018 年，分析技能的市场供应将超过市场容量。image 参加数据科学计划的初级人才数量，再加上数百个开设数据科学课程的训练营，你将看到一场完美的风暴。 除了我从工作中了解到的以及与 100 多名同事进行的交谈之外，下面的两条推文让我确信目前存在真正的数据科学供应泡沫。 @Cal 的数据科学入门课程 Data 8 非常受欢迎。它位于有泽勒巴大剧院。2018 年秋季开学。pic.twitter.com/VBhtPnikmw ——Mike Olson（@mikeolson），2018 年 10 月 4 日 UVA（美国弗吉尼亚大学）很自豪地宣布开设数据科学学院的计划，它将满足社会对数据科学不断增长的需求。https://t.co/QlP4OUrTrO ——UVA（@UVA）2019 年 1 月 18 日 由于学术界在跟上新趋势方面通常会滞后，因此，对于所有希望在数据科学领域找到职位的初级数据科学家来说，这确实令人感到担忧。对于一个拥有数据科学新学位的人来说，要找到一个数据科学的职位是非常困难的，因为他们要在市场上与许多新人展开竞争。 但在三、四年前，情况并非如此。而现在，数据科学已经从流行语变成了连硅谷之外的公司都在招聘的职位，职位的准入门槛更高了，而且偏爱具备数据科学经验的人，数据科学面试仍然很难通过。 正如很多文章指出的那样，你不一定会在第一次尝试时就能找到你梦寐以求的工作。市场可能非常残酷，并且对于大量初入者来说非常令人沮丧。数据科学是一个具有误导性的岗位需求 第二个问题是，一旦这些初级人员进入市场，他们会对数据科学工作产生不切实际的期望。每个人都认为他们将从事与机器学习、深度学习和贝叶斯模拟相关的工作。 这不是他们的错，这就是数据科学课程和技术媒体所宣扬的。 但现实的情况却是，“数据科学”大多数时候是关于如何清理和整理数据以及将数据从一个地方移动到另一个地方。 我最近进行的一次非科学调查证实了这一点： 一段时间以来，我一直对此感到好奇，所以决定做一个民意调查。 “作为一个 2019 年被称为’数据科学家’的人，我花了大部分时间（60％以上）：” 也欢迎“其他”选项，请在回复中添加。 ——Vicki Boykis（@vboykis）2019 年 1 月 28 日 还有很多行业专家发来的推文也是如此： 对于我最近的几个 ML 项目，复杂性并不在于建模或训练，而在于输入预处理。我发现在一个项目中耗尽了 CPU（而不是 GPU），我不确定如何进一步优化 Python（我正在考虑使用 C++）。 ——mat kelcey（@mat_kelcey）2019 年 2 月 11 日 我看到初级 ML/CV 工程师对构建数据集完全缺乏兴趣。虽然这是一项无聊的工作，但我认为在整理数据集时需要学到很多东西，毕竟这占了问题的一大半。 ——Katherine Scott（@kscottz）2019 年 2 月 1 日 角色和责任： - 自动化糟糕的商业行为 - 根据需要编写临时 SQL 经验要求： · 15 年使用 Python 进行深度学习的经验 · 写过有关贝叶斯建模的博士论文 · 7 种语言的 NLP 经验 · 10 年从头开始​​创建 Hadoop 集群的经验 ——NickHeitzman（@NickDoesData）2019 年 2 月 12 日 在过去两年中，项目的工作类别所占百分比： - 涉及 ML：15％ - 涉及移动、监控和统计数据：85％ ——Vicki Boykis（@vboykis）2019 年 1 月 15 日 显而易见的是，在炒作周期的后期阶段，数据科学逐渐向工程学靠近，数据科学家需要的技能不再是基于可视化和统计学，而是更接近传统计算机科学课程所提供的那些： 像单元测试和持续集成这样的概念很快就成为数据科学家和从事 ML 工程的数值科学家的行话和常用的工具。 这导致了一些事情的发生。首先是“机器学习工程师”这个头衔的崛起，在过去的 3 到 4 年里，它带来了更多的声望和更高的收入潜力。 其次，它导致数据科学家头衔含金量严重缩水。由于数据科学家头衔的声望，像 Lyft 这样的公司会招聘数据科学，但实际上他们只需要数据分析师的技能，导致“数据科学”职位对技能的要求发生了扭曲，究竟需要多少新进入者也变得不明确。 给新数据科学家的建议因此，本着继续为初学者提供建议的初衷，如果有人问我如何在 2019 年进入数据科学领域，我会给他们发送下面这样的电子邮件。 这是一个两步走的计划： 1. 不要死盯着数据科学的工作岗位。 2. 为大多数数据科学家相关的工作做好准备，但不要成为数据科学家。调整你的技能组合。 这些话可能有点令人沮丧！但请允许我解释一下，希望它们不像听起来的那么悲观。 不要进入数据科学领域因为每个初级职位一般有 50 个（有时 100 个，有时 200 个）人申请，所以不要与这些人去竞争。不要去攻读数学科学学位，不要参加训练营（我见过的大多数训练营的效果都不太好）。 不要做别人正在做的事情，因为这样无法让你脱颖而出。你正处在一个过度饱和的行业中，这样只会给自己增加难度。在我之前提到的那份PWC 报告中，数据科学职位的数量估计为 5 万，数据工程师职位的数量为 50 万，数据分析师职位的数量是 12.5 万。 通过“后门”进入数据科学领域要容易得多，也就是说从初级开发人员开始，可以是 DevOps 工程师、项目管理人员、数据分析师、信息管理员或类似的角色。这可能需要更长的时间，但在你努力完成数据科学工作的同时，你也将学会对职业生涯来说至关重要的 IT 技能。 了解当今数据科学所需的技能以下是你在数据领域需要解决的一些问题： 1）创建 Python 包 2）将 R 语言用在生产环境中 3）优化 Spark 作业，使其更有效地运行 4）对数据进行版本控制 5）让模型和数据可重现 6）对 SQL 进行版本控制 7）在数据湖中建立和维护干净的数据 8）大规模时间序列预测工具 9）共享 Jupyter Notebook 10）寻找可用于清理数据的系统 11）JSON 作为一名数据科学家，优化模型、可视化和分析数据是职责工作的一部分，而数据科学主要是（也一直是）关于在一个地方获得用于插补的干净数据。 你应该如何为解决这些问题做好准备？如何为工作做好准备？你可以考虑学习下面这三种技能，它们都是基础技能，并彼此依赖，从简单到困难。 所有这些技能也是数据科学以外的软件开发的基础和关键，这意味着，如果你无法找到数据科学工作，可以快速转做软件开发或 DevOps。我认为这种灵活性与针对特定数据相关工作的培训同样重要。 1. 学习 SQL 首先，我建议每个人都要学习 SQL，无论他们的目标是成为数据工程师、ML 专家还是 AI 大师。 SQL 并不性感，也不是上述问题的解决方案。但为了访问数据，你很可能需要针对数据库编写一些 SQL 查询，并用它获取答案。 SQL 非常强大且非常流行，甚至有些 NoSQL 和键值存储数据库也在重新实现它。比如 Presto 推出的 Presto 和 Athena、BigQuery、KSQL、Pandas、Spark，等等。如果你发现自己陷入了数据工具海洋之中，很可能可以找到一个适合你的 SQL 工具。而且，一旦你理解了 SQL，你会发现它比其他查询语言更容易理解，从而开辟了一个全新的世界。 在熟悉了 SQL 之后，下一步是了解数据库的工作原理，这样你就可以学会如何优化查询。你不一定要成为数据库开发人员，但很多概念将延续到你的其他编程生活当中。 2. 学好一门编程语言和学习编程概念 SQL 不是一门编程语言吗？它是的，但它是声明性的。你指定所需的输出（即你要从表中获取哪些列），但不指定这些列以怎样的形式返回给你。SQL 抽象了很多数据库底层的细节。 你需要一门过程式语言，你可以自行指定如何以及从哪里获取数据。大多数现代语言都是过程式的：Java、Python、Scala、R 语言、Go 语言，等等。 关于为数据科学应该选择哪种语言存在很多争论，我不会针对任何特定情况规定说要学习哪一种语言，只是在我的职业生涯中，Python 对我来说非常有用。作为一个初学者，它很容易入门，可以说是数据领域最流行的编程语言，并且可以用来完成很多不同的事情，从将模型嵌入 scikit 中，到访问 AWS API，再到构建 Web 应用程序、清理数据，以及创建深度学习模型。 当然，也有一些任务不太适合用 Python 来完成：大型应用程序、打包依赖项和一些特定的与数字相关的任务，特别是时间序列和 R 语言提供的一系列功能。 如果你不选择 Python，也没问题。但你至少要选择一种语言，让你在数据科学领域之外保持灵活性。例如，如果你的第一份工作是数据分析师、QA 分析师、DevOps 初级工程师，或者其他职位，掌握一门语言都有助于你站稳脚跟。 在选择了一门编程语言并弄清楚如何使用它之后，就可以开始学习它背后的范式以及它与计算机科学生态系统的关系。 你是如何使用你的语言实现 OOP 的？OOP 是什么东西？你如何优化你的代码？你的语言的依赖项是如何工作的？如何使用给定语言打包代码，如何进行版本控制、持续集成，如何部署模型工件？你的语言社区在哪里，会在哪里举行聚会？ 了解你的语言，了解它的优缺点，用你的语言开发一些有趣的东西。 然后，当你有足够的信心继续下去时，也只有在这个时候，才能开始学习你的第二门语言。它将把你带入更广泛的语言设计、算法和模式的世界。 3. 了解云端的工作 现在你已经知道如何编程，现在是时候将这些技能和理论带到云端了。 如今，云无处不在，你可能需要在下一个工作中使用云。如果有更多的机器学习范例转移到云端（如 SageMaker、Cloud AI 和 Azure 机器学习），已经有现成的模板可用来实现算法，而且企业的更多数据也开始存储在那里。 你可能会与行业领导者 AWS 合作，但越来越多的公司正在采用 Google Cloud，而很多已经与微软开展业务合作的保守企业在使用 Azure。我建议深入了解这三个云供应商，然后挑选一个你最感兴趣的。云设计范式都是类似的，你必须了解如何将服务粘合在一起，如何区分云端的服务器，以及如何使用 JSON。 有趣的是，这三家供应商现在都提供了他们的产品认证。我一般不会通过认证来衡量一个人对知识的掌握程度与否，但通过认证可以学到云的工作原理，这是工程的另一个组成部分：网络。 了解这三种产品，并在开始下一份工作之前在云端构建一些有趣的东西。 这里缺失的部分当然是“软技能”——知道在什么时候构建什么，知道如何在工作场所进行交流，知道其他人想要什么。软技能与技术技能一样重要，有很多专门讨论它的文章，但为了保持这篇文章不会太长，这里就不作累述了。 最后的步骤现在，请深呼吸，我想你已经做好准备了。 如果上述有任何一点（或者所有）让你感兴趣，那说明你已经准备好在 2019 年成为数据科学家、机器学习工程师、云专家或 AI 大师了。 请记住，你的最终目标是打败那些攻读数据科学学位、参加训练营和学习教程的人。 你想要迈出第一步，获得一个与数据相关的职位，然后朝着你梦想的工作前进，同时尽可能多地了解科技行业的总体情况。 我最后一个一般性的建议是给自己打气： 这对每个人来说都很难，似乎有很多事情你必须知道。不要气馁。 不要因为想太多就望而却步。先从小处开始，做一些小的事情，学习一些小的东西，构建一些小的东西，把你做的事情告诉其他人。请记住，你在数据科学领域的第一份工作可能不是数据科学家。 祝你好运！ 英文原文：https://veekaybee.github.io/2019/02/13/data-science-is-different/","categories":[{"name":"转载","slug":"转载","permalink":"https://screw-hand.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://screw-hand.com/tags/%E8%BD%AC%E8%BD%BD/"}]}],"categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://screw-hand.com/categories/DevOps/"},{"name":"geek","slug":"geek","permalink":"https://screw-hand.com/categories/geek/"},{"name":"cli","slug":"cli","permalink":"https://screw-hand.com/categories/cli/"},{"name":"js","slug":"js","permalink":"https://screw-hand.com/categories/js/"},{"name":"工程化","slug":"工程化","permalink":"https://screw-hand.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"vue","slug":"vue","permalink":"https://screw-hand.com/categories/vue/"},{"name":"git","slug":"git","permalink":"https://screw-hand.com/categories/git/"},{"name":"转载","slug":"转载","permalink":"https://screw-hand.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://screw-hand.com/tags/linux/"},{"name":"mac","slug":"mac","permalink":"https://screw-hand.com/tags/mac/"},{"name":"env","slug":"env","permalink":"https://screw-hand.com/tags/env/"},{"name":"vscode","slug":"vscode","permalink":"https://screw-hand.com/tags/vscode/"},{"name":"cli","slug":"cli","permalink":"https://screw-hand.com/tags/cli/"},{"name":"ssh","slug":"ssh","permalink":"https://screw-hand.com/tags/ssh/"},{"name":"github","slug":"github","permalink":"https://screw-hand.com/tags/github/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://screw-hand.com/tags/ubuntu/"},{"name":"人间采访","slug":"人间采访","permalink":"https://screw-hand.com/tags/%E4%BA%BA%E9%97%B4%E9%87%87%E8%AE%BF/"},{"name":"js 读书笔记","slug":"js-读书笔记","permalink":"https://screw-hand.com/tags/js-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"webpack","slug":"webpack","permalink":"https://screw-hand.com/tags/webpack/"},{"name":"规范","slug":"规范","permalink":"https://screw-hand.com/tags/%E8%A7%84%E8%8C%83/"},{"name":"web","slug":"web","permalink":"https://screw-hand.com/tags/web/"},{"name":"js","slug":"js","permalink":"https://screw-hand.com/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://screw-hand.com/tags/vue/"},{"name":"vue-skill","slug":"vue-skill","permalink":"https://screw-hand.com/tags/vue-skill/"},{"name":"git","slug":"git","permalink":"https://screw-hand.com/tags/git/"},{"name":"debugger","slug":"debugger","permalink":"https://screw-hand.com/tags/debugger/"},{"name":"es6","slug":"es6","permalink":"https://screw-hand.com/tags/es6/"},{"name":"浏览器","slug":"浏览器","permalink":"https://screw-hand.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"随笔","slug":"随笔","permalink":"https://screw-hand.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"转载","slug":"转载","permalink":"https://screw-hand.com/tags/%E8%BD%AC%E8%BD%BD/"}]}